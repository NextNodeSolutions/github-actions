name: 'VPS Provision'
description: 'Provision a custom VPS for application deployment via Terraform'
author: 'NextNodeSolutions'

inputs:
  vps-name:
    description: 'Name of the VPS to provision'
    required: true
  project-name:
    description: 'Project name this VPS belongs to'
    required: true
  server-type:
    description: 'Hetzner server type (cx23, cx33, cx43)'
    required: false
    default: 'cx33'
  environment:
    description: 'Environment: production, staging'
    required: false
    default: 'production'
  hetzner-token:
    description: 'Hetzner Cloud API token'
    required: true
  tailscale-auth-key:
    description: 'Tailscale authentication key'
    required: true
  tailscale-api-key:
    description: 'Tailscale API key for IP resolution'
    required: true
  cloudflare-api-token:
    description: 'Cloudflare API token'
    required: true
  tf-api-token:
    description: 'Terraform Cloud API token'
    required: true
  dokploy-url:
    description: 'Dokploy instance URL'
    required: true
  dokploy-admin-email:
    description: 'Dokploy admin email'
    required: true
  dokploy-admin-password:
    description: 'Dokploy admin password'
    required: true
  dokploy-ssh-key-id:
    description: 'Dokploy SSH key ID for server registration'
    required: true

outputs:
  server-id:
    description: 'Hetzner server ID'
    value: ${{ steps.provision.outputs.server-id }}
  ipv4-address:
    description: 'Public IPv4 address'
    value: ${{ steps.provision.outputs.ipv4-address }}
  tailscale-ip:
    description: 'Tailscale IP address'
    value: ${{ steps.provision.outputs.tailscale-ip }}
  dokploy-server-id:
    description: 'Dokploy server ID'
    value: ${{ steps.register.outputs.server-id }}
  already-exists:
    description: 'Whether the VPS already existed'
    value: ${{ steps.provision.outputs.already-exists }}
  success:
    description: 'Whether provisioning succeeded'
    value: ${{ steps.register.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.7'
        cli_config_credentials_token: ${{ inputs.tf-api-token }}
        terraform_wrapper: false

    - name: Checkout Infrastructure
      uses: actions/checkout@v4
      with:
        repository: nextnodesolutions/infrastructure
        path: .infrastructure

    - name: Provision VPS
      id: provision
      shell: bash
      env:
        TF_VAR_hetzner_token: ${{ inputs.hetzner-token }}
        TF_VAR_tailscale_auth_key: ${{ inputs.tailscale-auth-key }}
        TF_VAR_cloudflare_dns_token: ${{ inputs.cloudflare-api-token }}
        TF_VAR_vps_name: ${{ inputs.vps-name }}
        TF_VAR_project_name: ${{ inputs.project-name }}
        TF_VAR_server_type: ${{ inputs.server-type }}
        TF_VAR_environment: ${{ inputs.environment }}
        TAILSCALE_API_KEY: ${{ inputs.tailscale-api-key }}
      run: |
        echo "::group::VPS Provisioning"
        cd .infrastructure/terraform/app-vps

        # Initialize Terraform
        terraform init

        # Check if server already exists in state
        if terraform state show module.app_vps.hcloud_server.this 2>/dev/null; then
          echo "VPS already exists in Terraform state"
          echo "already-exists=true" >> $GITHUB_OUTPUT

          # Get existing server info
          SERVER_ID=$(terraform output -raw server_id)
          IPV4=$(terraform output -raw ipv4_address)
          echo "server-id=$SERVER_ID" >> $GITHUB_OUTPUT
          echo "ipv4-address=$IPV4" >> $GITHUB_OUTPUT
        else
          echo "Provisioning new VPS..."
          echo "already-exists=false" >> $GITHUB_OUTPUT

          # Apply Terraform
          terraform apply -auto-approve

          # Get outputs
          SERVER_ID=$(terraform output -raw server_id)
          IPV4=$(terraform output -raw ipv4_address)
          echo "server-id=$SERVER_ID" >> $GITHUB_OUTPUT
          echo "ipv4-address=$IPV4" >> $GITHUB_OUTPUT

          echo "VPS provisioned: ${{ inputs.vps-name }} ($IPV4)"
        fi

        # Wait for VPS to appear in Tailscale
        echo "Waiting for VPS to join Tailscale..."
        TAILSCALE_IP=""
        for i in $(seq 1 30); do
          TAILSCALE_IP=$(curl -sf -H "Authorization: Bearer ${TAILSCALE_API_KEY}" \
            "https://api.tailscale.com/api/v2/tailnet/-/devices" | \
            jq -r ".devices[] | select(.hostname | startswith(\"${{ inputs.vps-name }}\")) | .addresses[0]" 2>/dev/null | head -1)

          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "null" ]]; then
            echo "VPS joined Tailscale: $TAILSCALE_IP"
            break
          fi
          echo "Attempt $i/30: waiting 10s..."
          sleep 10
        done

        if [[ -z "$TAILSCALE_IP" || "$TAILSCALE_IP" == "null" ]]; then
          echo "::error::VPS did not join Tailscale after 5 minutes"
          exit 1
        fi

        echo "tailscale-ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
        echo "::endgroup::"

    - name: Register with Dokploy
      id: register
      shell: bash
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        DOKPLOY_ADMIN_EMAIL: ${{ inputs.dokploy-admin-email }}
        DOKPLOY_ADMIN_PASSWORD: ${{ inputs.dokploy-admin-password }}
        SSH_KEY_ID: ${{ inputs.dokploy-ssh-key-id }}
        VPS_NAME: ${{ inputs.vps-name }}
        TAILSCALE_IP: ${{ steps.provision.outputs.tailscale-ip }}
      run: |
        echo "::group::Dokploy Registration"

        # Authenticate via Better Auth endpoint and get Bearer token
        echo "Authenticating with Dokploy..."
        AUTH_RESPONSE=$(curl -sf -X POST "${DOKPLOY_URL}/api/auth/sign-in/email" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg email "${DOKPLOY_ADMIN_EMAIL}" \
            --arg password "${DOKPLOY_ADMIN_PASSWORD}" \
            '{email: $email, password: $password}')" 2>&1) || true

        if [[ -z "$AUTH_RESPONSE" ]] || [[ "$AUTH_RESPONSE" == *"error"* ]] || [[ "$AUTH_RESPONSE" == *"Unauthorized"* ]]; then
          echo "::error::Authentication failed - invalid email or password"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Extract Bearer token from response
        TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.token // empty')
        if [[ -z "$TOKEN" ]]; then
          echo "::error::No token in auth response"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "Authentication successful"

        # Verify session by getting server list
        AUTH_TEST=$(curl -sf -X GET "${DOKPLOY_URL}/api/server.all" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${TOKEN}" 2>&1) || true

        if [[ -z "$AUTH_TEST" ]] || [[ "$AUTH_TEST" == *"Unauthorized"* ]]; then
          echo "::error::Session verification failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Check if server already exists
        EXISTING_SERVERS="$AUTH_TEST"

        EXISTING_ID=$(echo "$EXISTING_SERVERS" | jq -r ".[] | select(.name == \"${VPS_NAME}\") | .serverId" 2>/dev/null || echo "")

        if [[ -n "$EXISTING_ID" ]]; then
          echo "Server already registered in Dokploy: $EXISTING_ID"
          echo "server-id=$EXISTING_ID" >> $GITHUB_OUTPUT
          echo "success=true" >> $GITHUB_OUTPUT
        else
          echo "Registering server in Dokploy..."

          CREATE_RESPONSE=$(curl -sf -X POST "${DOKPLOY_URL}/api/server.create" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -d "$(jq -n \
              --arg name "${VPS_NAME}" \
              --arg ip "${TAILSCALE_IP}" \
              --arg sshKeyId "${SSH_KEY_ID}" \
              '{name: $name, ipAddress: $ip, port: 22, username: "root", sshKeyId: $sshKeyId}')")

          SERVER_ID=$(echo "$CREATE_RESPONSE" | jq -r '.serverId // empty')

          if [[ -z "$SERVER_ID" ]]; then
            echo "::error::Failed to register server in Dokploy"
            echo "Response: $CREATE_RESPONSE"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "Server registered: $SERVER_ID"

          # Setup server (installs Docker + Traefik)
          echo "Setting up server (this may take a few minutes)..."
          curl -sf -X POST "${DOKPLOY_URL}/api/server.setup" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -d "$(jq -n --arg serverId "$SERVER_ID" '{serverId: $serverId}')" || true

          echo "server-id=$SERVER_ID" >> $GITHUB_OUTPUT
          echo "success=true" >> $GITHUB_OUTPUT
        fi

        echo "::endgroup::"

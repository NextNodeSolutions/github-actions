name: 'Railway Deploy'
description: 'Deploy application to Railway platform'
author: 'NextNodeSolutions'

inputs:
  environment:
    description: 'Deployment environment (development/staging/production)'
    required: true
  app-name:
    description: 'Application name'
    required: true
  memory-mb:
    description: 'Memory allocation in MB'
    required: false
    default: '512'
  variables:
    description: 'Environment variables as JSON object'
    required: false
    default: '{}'
  wait-for-deployment:
    description: 'Wait for deployment to complete'
    required: false
    default: 'true'
  timeout-seconds:
    description: 'Deployment timeout in seconds'
    required: false
    default: '300'
  railway-token:
    description: 'Railway API token'
    required: true

outputs:
  deployment-id:
    description: 'Railway deployment ID'
    value: ${{ steps.deploy-info.outputs.deployment-id }}
  railway-url:
    description: 'Railway internal URL'
    value: ${{ steps.railway-url.outputs.railway-internal-url }}
  project-id:
    description: 'Railway project ID'
    value: ${{ steps.project-setup.outputs.project-id }}
  service-id:
    description: 'Railway service ID'
    value: ${{ steps.service-setup.outputs.service-id }}
  status:
    description: 'Deployment status'
    value: ${{ steps.wait.outputs.status }}

runs:
  using: 'composite'
  steps:
    - name: Install Railway CLI
      shell: bash
      run: |
        npm install -g @railway/cli
        railway --version
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        CI: true
        
    - name: Create or link Railway project
      id: project-setup
      shell: bash
      run: |
        # Set project name (use app-name as project name)
        PROJECT_NAME="${{ inputs.app-name }}"
        echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_ENV
        echo "project-name=$PROJECT_NAME" >> $GITHUB_OUTPUT
        
        # Check if project exists
        if railway list --json | jq -r '.[].name' | grep -q "^$PROJECT_NAME$"; then
          echo "Project $PROJECT_NAME exists, linking..."
          PROJECT_ID=$(railway list --json | jq -r ".[] | select(.name==\"$PROJECT_NAME\") | .id" | head -1)
          {
          echo 'PROJECT_ID<<EOF'
          echo "$PROJECT_ID"
          echo 'EOF'
        } >> $GITHUB_ENV
          {
          echo 'project-id<<EOF'
          echo "$PROJECT_ID"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
        else
          echo "Creating new project $PROJECT_NAME..."
          railway init --name "$PROJECT_NAME"
          
          # Get the created project ID
          sleep 2  # Wait for project creation to propagate
          PROJECT_ID=$(railway list --json | jq -r ".[] | select(.name==\"$PROJECT_NAME\") | .id" | head -1)
          
          if [ -n "$PROJECT_ID" ] && [ "$PROJECT_ID" != "null" ]; then
            {
          echo 'PROJECT_ID<<EOF'
          echo "$PROJECT_ID"
          echo 'EOF'
        } >> $GITHUB_ENV
            {
          echo 'project-id<<EOF'
          echo "$PROJECT_ID"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
            echo "Created project with ID: $PROJECT_ID"
          else
            echo "Failed to create or find project $PROJECT_NAME"
            exit 1
          fi
        fi
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        CI: true
        
    - name: Setup service
      id: service-setup
      shell: bash
      run: |
        # Helper function for consistent logging
        log_info() { echo "üîß $1"; }
        log_success() { echo "‚úÖ $1"; }
        log_error() { echo "‚ùå $1"; }
        
        # Generate service name based on environment
        # For simple setup, use env prefix (dev/staging/prod)
        if [[ "${{ inputs.environment }}" == "production" ]]; then
          SERVICE_PREFIX="prod"
        elif [[ "${{ inputs.environment }}" == "staging" ]]; then
          SERVICE_PREFIX="staging"
        else
          SERVICE_PREFIX="dev"
        fi
        
        SERVICE_NAME="${SERVICE_PREFIX}_${{ inputs.app-name }}"
        
        log_info "Service: $SERVICE_NAME"
        echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
        echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        
        # Setup environment
        ENVIRONMENT="${{ inputs.environment }}"
        log_info "Setting up environment: $ENVIRONMENT"
        
        # Direct link attempt with fallback
        if ! railway link --project "$PROJECT_ID" --environment "$ENVIRONMENT" 2>/dev/null; then
          log_info "Creating new environment: $ENVIRONMENT"
          railway link --project "$PROJECT_ID"
          railway environment new "$ENVIRONMENT" || true  # May already exist
          railway environment "$ENVIRONMENT"
        fi
        
        log_success "Environment linked: $ENVIRONMENT"
        
        # Service management with improved error handling
        log_info "Checking service existence..."
        
        # Get service info
        SERVICE_INFO=$(railway status --json 2>/dev/null | jq -r '.services.edges[]? | .node | select(.name=="'"$SERVICE_NAME"'")' 2>/dev/null || echo "{}")
        SERVICE_ID=$(echo "$SERVICE_INFO" | jq -r '.id // empty' 2>/dev/null || echo "")
        
        if [ -n "$SERVICE_ID" ] && [ "$SERVICE_ID" != "empty" ]; then
          log_success "Service found: $SERVICE_NAME (ID: ${SERVICE_ID:0:8}...)"
          {
          echo 'SERVICE_ID<<EOF'
          echo "$SERVICE_ID"
          echo 'EOF'
        } >> $GITHUB_ENV
          {
          echo 'service-id<<EOF'
          echo "$SERVICE_ID"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
        else
          log_info "Creating new service: $SERVICE_NAME"
          
          if railway add --service "$SERVICE_NAME"; then
            # Wait and retry to get service ID
            sleep 3
            for attempt in 1 2 3; do
              SERVICE_ID=$(railway status --json 2>/dev/null | jq -r '.services.edges[]? | .node | select(.name=="'"$SERVICE_NAME"'") | .id // empty' 2>/dev/null | head -1 || echo "")
              [ -n "$SERVICE_ID" ] && [ "$SERVICE_ID" != "empty" ] && break
              log_info "Waiting for service creation (attempt $attempt/3)..."
              sleep 2
            done
            
            if [ -n "$SERVICE_ID" ] && [ "$SERVICE_ID" != "empty" ]; then
              log_success "Service created: $SERVICE_NAME (ID: ${SERVICE_ID:0:8}...)"
              {
          echo 'SERVICE_ID<<EOF'
          echo "$SERVICE_ID"
          echo 'EOF'
        } >> $GITHUB_ENV
              {
          echo 'service-id<<EOF'
          echo "$SERVICE_ID"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
            else
              log_error "Failed to retrieve service ID after creation"
              exit 1
            fi
          else
            log_error "Failed to create service: $SERVICE_NAME"
            exit 1
          fi
        fi
        
        # Final service link
        log_info "Activating service context..."
        railway service "$SERVICE_NAME"
        log_success "Service setup completed: $SERVICE_NAME"
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        PROJECT_ID: ${{ env.PROJECT_ID }}
        CI: true
        
    - name: Set environment variables
      if: inputs.variables != '{}'
      shell: bash
      run: |
        echo "üîß Configuring environment variables..."
        
        VARIABLES_COUNT=0
        
        # Set custom variables from JSON
        echo "üìù Setting custom variables:"
        echo '${{ inputs.variables }}' | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while read -r var; do
          VAR_NAME="${var%%=*}"
          VAR_VALUE="${var#*=}"
          echo "   ‚Ä¢ $VAR_NAME = ***"
          railway variables --set "$var" --skip-deploys || echo "   ‚ö†Ô∏è  Failed to set $VAR_NAME"
          VARIABLES_COUNT=$((VARIABLES_COUNT + 1))
        done
        
        # Always set NODE_ENV
        echo "   ‚Ä¢ NODE_ENV = ${{ inputs.environment }}"
        railway variables --set "NODE_ENV=${{ inputs.environment }}" --skip-deploys || echo "   ‚ö†Ô∏è  Failed to set NODE_ENV"
        
        # Set memory if specified
        echo "   ‚Ä¢ MEMORY_MB = ${{ inputs.memory-mb }}"
        railway variables --set "MEMORY_MB=${{ inputs.memory-mb }}" --skip-deploys || echo "   ‚ö†Ô∏è  Failed to set MEMORY_MB"
        
        echo "‚úÖ Environment variables configured"
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        CI: true
        
    - name: Deploy application
      id: deploy
      shell: bash
      run: |
        echo "üöÄ Deploying to Railway..."
        railway up --service "$SERVICE_NAME" --detach
        
        echo "‚úÖ Deployment initiated successfully"
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        CI: true
        
    - name: Wait for deployment
      id: wait
      if: inputs.wait-for-deployment == 'true'
      shell: bash
      run: |
        # Configuration
        MAX_WAIT=${{ inputs.timeout-seconds }}
        CHECK_INTERVAL=10
        ELAPSED=0
        
        echo "üöÄ Monitoring Railway deployment..."
        echo "üìä Configuration: max_wait=${MAX_WAIT}s, check_interval=${CHECK_INTERVAL}s"
        echo "üéØ Service: $SERVICE_NAME"
        echo ""
        
        # JQ selector for reuse
        JQ_SERVICE_SELECTOR='.services.edges[] | .node | select(.name=="'"$SERVICE_NAME"'")'
        
        sleep 10  # Initial wait
        
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          # Get full service info once
          SERVICE_INFO=$(railway status --json 2>/dev/null | jq -r "$JQ_SERVICE_SELECTOR" 2>/dev/null || echo "{}")
          
          if [ "$SERVICE_INFO" = "{}" ] || [ -z "$SERVICE_INFO" ]; then
            echo "‚ö†Ô∏è  Cannot retrieve service info (${ELAPSED}s elapsed) - retrying..."
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
            continue
          fi
          
          # Extract deployment info
          DEPLOYMENT_STATUS=$(echo "$SERVICE_INFO" | jq -r '.serviceInstances.edges[].node.latestDeployment.status // "UNKNOWN"' 2>/dev/null)
          DEPLOYMENT_ID=$(echo "$SERVICE_INFO" | jq -r '.serviceInstances.edges[].node.latestDeployment.id // "N/A"' 2>/dev/null)
          
          echo "[${ELAPSED}s] Deployment: $DEPLOYMENT_STATUS"
          
          case "$DEPLOYMENT_STATUS" in
            "SUCCESS"|"LIVE")
              echo ""
              echo "‚úÖ Deployment completed successfully!"
              echo "üìã Final Status: $DEPLOYMENT_STATUS"
              echo "üÜî Deployment ID: $DEPLOYMENT_ID"
              echo "‚è±Ô∏è  Total time: ${ELAPSED}s"
              echo "status=success" >> $GITHUB_OUTPUT
              {
          echo 'deployment-id<<EOF'
          echo "$DEPLOYMENT_ID"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
              break
              ;;
            "FAILED"|"CRASHED"|"REMOVED")
              echo ""
              echo "‚ùå Deployment failed with status: $DEPLOYMENT_STATUS"
              echo "üÜî Deployment ID: $DEPLOYMENT_ID"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
              ;;
            "BUILDING"|"DEPLOYING"|"INITIALIZING"|"QUEUED")
              echo "    ‚è≥ In progress..."
              ;;
            *)
              echo "    ‚ö†Ô∏è  Unknown status: $DEPLOYMENT_STATUS"
              ;;
          esac
          
          sleep $CHECK_INTERVAL
          ELAPSED=$((ELAPSED + CHECK_INTERVAL))
        done
        
        if [ $ELAPSED -ge $MAX_WAIT ]; then
          echo ""
          echo "‚è∞ Deployment monitoring timed out after $MAX_WAIT seconds"
          echo "status=timeout" >> $GITHUB_OUTPUT
        fi
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        CI: true
        
    - name: Generate Railway URL
      id: railway-url
      shell: bash
      run: |
        echo "üîç Getting Railway URL..."
        
        # JQ selector for reuse
        JQ_SERVICE_SELECTOR='.services.edges[] | .node | select(.name=="'"$SERVICE_NAME"'")'
        
        # First check if a Railway domain already exists
        SERVICE_DOMAIN=$(railway status --json 2>/dev/null | jq -r "$JQ_SERVICE_SELECTOR | .serviceInstances.edges[].node.domains.serviceDomains[0].domain // empty" 2>/dev/null)
        
        if [ -n "$SERVICE_DOMAIN" ] && [ "$SERVICE_DOMAIN" != "empty" ]; then
          RAILWAY_INTERNAL_URL="https://$SERVICE_DOMAIN"
          echo "‚úÖ Railway URL: $RAILWAY_INTERNAL_URL"
        else
          echo "üîß Generating new Railway URL..."
          
          # Generate Railway domain
          DOMAIN_OUTPUT=$(railway domain --json --service "$SERVICE_NAME" 2>/dev/null || echo "{}")
          
          if [ "$DOMAIN_OUTPUT" != "{}" ]; then
            RAILWAY_DOMAIN=$(echo "$DOMAIN_OUTPUT" | jq -r '.domain // empty' 2>/dev/null)
            
            if [ -n "$RAILWAY_DOMAIN" ] && [ "$RAILWAY_DOMAIN" != "empty" ]; then
              RAILWAY_INTERNAL_URL="https://$RAILWAY_DOMAIN"
              echo "‚úÖ Railway URL: $RAILWAY_INTERNAL_URL"
            else
              echo "‚ö†Ô∏è  Failed to generate Railway domain"
              RAILWAY_INTERNAL_URL=""
            fi
          else
            echo "‚ö†Ô∏è  Failed to generate Railway domain"
            RAILWAY_INTERNAL_URL=""
          fi
        fi
        
        echo "railway-internal-url=$RAILWAY_INTERNAL_URL" >> $GITHUB_OUTPUT
        
        # Also set deployment info output
        {
          echo 'deployment-id<<EOF'
          echo "$DEPLOYMENT_ID"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
      env:
        RAILWAY_API_TOKEN: ${{ inputs.railway-token }}
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        CI: true
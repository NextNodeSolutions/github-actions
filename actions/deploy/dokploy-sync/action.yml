name: 'Dokploy Sync'
description: 'Sync project configuration to Dokploy and trigger deployment'
author: 'NextNodeSolutions'

inputs:
  config-file:
    description: 'Path to project dokploy.toml'
    required: false
    default: 'dokploy.toml'
  defaults-file:
    description: 'Path to defaults TOML file'
    required: false
    default: ''
  environment:
    description: 'Target environment: development, preview, production'
    required: true
  pr-number:
    description: 'PR number (for preview deployments)'
    required: false
    default: ''
  dokploy-url:
    description: 'Dokploy instance URL'
    required: true
  dokploy-admin-email:
    description: 'Dokploy admin email'
    required: true
  dokploy-admin-password:
    description: 'Dokploy admin password'
    required: true
  tailscale-api-key:
    description: 'Tailscale API key for server IP resolution'
    required: true
  cloudflare-api-token:
    description: 'Cloudflare API token for DNS'
    required: true
  action:
    description: 'Action to perform: deploy, cleanup'
    required: false
    default: 'deploy'
  docker-image:
    description: 'Docker image to deploy (e.g., admin-dokploy:5000/repo:tag). When provided, uses Docker source instead of GitHub.'
    required: false
    default: ''

outputs:
  project-id:
    description: 'Dokploy project ID'
    value: ${{ steps.sync.outputs.project-id }}
  application-id:
    description: 'Dokploy application ID'
    value: ${{ steps.sync.outputs.application-id }}
  domain:
    description: 'Deployed domain'
    value: ${{ steps.sync.outputs.domain }}
  success:
    description: 'Whether the operation succeeded'
    value: ${{ steps.sync.outputs.success }}
  server-ip:
    description: 'Server public IP address'
    value: ${{ steps.sync.outputs.server-ip }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      shell: bash
      run: pip install tomli requests

    - name: Sync to Dokploy
      id: sync
      shell: python
      env:
        CONFIG_FILE: ${{ inputs.config-file }}
        DEFAULTS_FILE: ${{ inputs.defaults-file }}
        ENVIRONMENT: ${{ inputs.environment }}
        PR_NUMBER: ${{ inputs.pr-number }}
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        DOKPLOY_ADMIN_EMAIL: ${{ inputs.dokploy-admin-email }}
        DOKPLOY_ADMIN_PASSWORD: ${{ inputs.dokploy-admin-password }}
        TAILSCALE_API_KEY: ${{ inputs.tailscale-api-key }}
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        ACTION: ${{ inputs.action }}
        DOCKER_IMAGE: ${{ inputs.docker-image }}
        GITHUB_OUTPUT: ${{ github.output }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        import os
        import sys
        import json
        import tomli
        import requests
        from pathlib import Path

        # =================================================================
        # CONFIGURATION
        # =================================================================
        CONFIG_FILE = os.environ.get('CONFIG_FILE', 'dokploy.toml')
        DEFAULTS_FILE = os.environ.get('DEFAULTS_FILE', '')
        ENVIRONMENT = os.environ.get('ENVIRONMENT', 'development')
        PR_NUMBER = os.environ.get('PR_NUMBER', '')
        DOKPLOY_URL = os.environ['DOKPLOY_URL'].rstrip('/')
        DOKPLOY_ADMIN_EMAIL = os.environ['DOKPLOY_ADMIN_EMAIL']
        DOKPLOY_ADMIN_PASSWORD = os.environ['DOKPLOY_ADMIN_PASSWORD']
        TAILSCALE_API_KEY = os.environ['TAILSCALE_API_KEY']
        CLOUDFLARE_TOKEN = os.environ['CLOUDFLARE_API_TOKEN']
        ACTION = os.environ.get('ACTION', 'deploy')
        DOCKER_IMAGE = os.environ.get('DOCKER_IMAGE', '')
        GITHUB_OUTPUT = os.environ.get('GITHUB_OUTPUT', '')
        GITHUB_REPOSITORY = os.environ.get('GITHUB_REPOSITORY', '')

        def output(key, value):
            if GITHUB_OUTPUT:
                with open(GITHUB_OUTPUT, 'a') as f:
                    f.write(f"{key}={value}\n")
            print(f"::set-output name={key}::{value}")

        def deep_merge(base, override):
            """Deep merge two dicts, override wins."""
            result = base.copy()
            for key, value in override.items():
                if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                    result[key] = deep_merge(result[key], value)
                else:
                    result[key] = value
            return result

        # =================================================================
        # LOAD AND MERGE CONFIGURATION
        # =================================================================
        print("::group::Loading configuration")

        # Load defaults
        defaults = {}
        if DEFAULTS_FILE and Path(DEFAULTS_FILE).exists():
            with open(DEFAULTS_FILE, 'rb') as f:
                defaults = tomli.load(f)
            print(f"Loaded defaults from: {DEFAULTS_FILE}")

        # Load project config (OPTIONAL now)
        project_config = {}
        if Path(CONFIG_FILE).exists():
            with open(CONFIG_FILE, 'rb') as f:
                project_config = tomli.load(f)
            print(f"Loaded project config from: {CONFIG_FILE}")
        else:
            print(f"No {CONFIG_FILE} found, using defaults only")

        # Merge configs
        config = deep_merge(defaults, project_config)

        # Get project name - infer from GitHub repository if not in config
        project_name = config.get('project', {}).get('name', '')
        if not project_name and GITHUB_REPOSITORY:
            # Extract repo name from "owner/repo" format
            project_name = GITHUB_REPOSITORY.split('/')[-1]
            print(f"Inferred project name from repository: {project_name}")
            # Store inferred name in config for later use
            if 'project' not in config:
                config['project'] = {}
            config['project']['name'] = project_name

        if not project_name:
            print("::error::Could not determine project name (set project.name in dokploy.toml or ensure GITHUB_REPOSITORY is set)")
            output('success', 'false')
            sys.exit(1)

        print(f"Project name: {project_name}")
        print("::endgroup::")

        # =================================================================
        # GENERATE DOMAIN (OPTIONAL)
        # =================================================================
        print("::group::Generating domain")

        base_domain = config.get('project', {}).get('domain', '')

        if base_domain:
            if ENVIRONMENT == 'production':
                domain = base_domain
            elif ENVIRONMENT == 'development':
                domain = f"dev.{base_domain}"
            elif ENVIRONMENT == 'preview' and PR_NUMBER:
                domain = f"pr-{PR_NUMBER}.dev.{base_domain}"
            else:
                domain = f"{ENVIRONMENT}.{base_domain}"
            print(f"Target domain: {domain}")
        else:
            domain = ''
            print("No domain configured, DNS setup will be skipped")

        print("::endgroup::")

        # =================================================================
        # SETUP API SESSION (Better Auth)
        # =================================================================
        print("::group::Setting up Dokploy API session")

        # Use session with Bearer token authentication
        session = requests.Session()
        session.headers.update({"Content-Type": "application/json"})

        # Authenticate via Better Auth endpoint
        try:
            auth_resp = session.post(
                f"{DOKPLOY_URL}/api/auth/sign-in/email",
                json={"email": DOKPLOY_ADMIN_EMAIL, "password": DOKPLOY_ADMIN_PASSWORD},
                timeout=30
            )

            if auth_resp.status_code == 401:
                print("::error::Invalid email or password")
                output('success', 'false')
                sys.exit(1)
            auth_resp.raise_for_status()

            # Extract token from response and set as Bearer auth
            auth_data = auth_resp.json()
            token = auth_data.get('token')
            if not token:
                print("::error::No token in auth response")
                output('success', 'false')
                sys.exit(1)

            session.headers.update({"Authorization": f"Bearer {token}"})
            print("Authentication successful")
        except requests.exceptions.RequestException as e:
            print(f"::error::Failed to authenticate with Dokploy: {e}")
            output('success', 'false')
            sys.exit(1)

        # Verify session works by fetching projects
        try:
            test_resp = session.get(f"{DOKPLOY_URL}/api/project.all", timeout=30)
            test_resp.raise_for_status()
            print("API session verified")
        except requests.exceptions.RequestException as e:
            print(f"::error::Session verification failed: {e}")
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

        # =================================================================
        # CLEANUP (for PR close)
        # =================================================================
        if ACTION == 'cleanup':
            print("::group::Cleanup preview deployment")
            # Find and delete the preview application
            try:
                projects_resp = session.get(f"{DOKPLOY_URL}/api/project.all", timeout=30)
                projects = projects_resp.json() if projects_resp.ok else []

                project_name = config.get('project', {}).get('name', '')
                preview_name = f"{project_name}-pr-{PR_NUMBER}"

                for project in projects:
                    if project.get('name') == project_name:
                        # Get apps via project.one (application.all endpoint doesn't exist)
                        proj_resp = session.get(
                            f"{DOKPLOY_URL}/api/project.one",
                            params={"projectId": project.get('projectId')},
                            timeout=30
                        )
                        apps = []
                        if proj_resp.ok:
                            proj_data = proj_resp.json()
                            apps = proj_data.get('applications', [])
                            for env in proj_data.get('environments', []):
                                apps.extend(env.get('applications', []))
                        for app in apps:
                            if app.get('name') == preview_name:
                                session.post(
                                    f"{DOKPLOY_URL}/api/application.delete",
                                    json={"applicationId": app.get('applicationId')},
                                    timeout=30
                                )
                                print(f"Deleted preview application: {preview_name}")
                                break
            except Exception as e:
                print(f"::warning::Cleanup failed: {e}")

            output('success', 'true')
            print("::endgroup::")
            sys.exit(0)

        # =================================================================
        # GET OR CREATE PROJECT
        # =================================================================
        print("::group::Setting up Dokploy project")

        # project_name already validated and set earlier
        try:
            projects_resp = session.get(f"{DOKPLOY_URL}/api/project.all", timeout=30)
            projects = projects_resp.json() if projects_resp.ok else []

            project_id = None
            for p in projects:
                if p.get('name') == project_name:
                    project_id = p.get('projectId')
                    print(f"Found existing project: {project_name} ({project_id})")
                    break

            if not project_id:
                create_resp = session.post(
                    f"{DOKPLOY_URL}/api/project.create",
                    json={"name": project_name, "description": config.get('project', {}).get('description', '')},
                    timeout=30
                )
                create_resp.raise_for_status()
                create_data = create_resp.json()
                # Handle both possible response formats (projectId or id)
                project_id = create_data.get('projectId') or create_data.get('id')
                if not project_id:
                    print(f"::warning::Unexpected project.create response: {create_data}")
                    # Try to find project by name as fallback
                    projects_resp2 = session.get(f"{DOKPLOY_URL}/api/project.all", timeout=30)
                    for p in projects_resp2.json() if projects_resp2.ok else []:
                        if p.get('name') == project_name:
                            project_id = p.get('projectId')
                            break
                print(f"Created project: {project_name} ({project_id})")
        except Exception as e:
            print(f"::error::Failed to setup project: {e}")
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

        # =================================================================
        # GET OR CREATE ENVIRONMENT
        # =================================================================
        print("::group::Setting up Dokploy environment")

        env_name = ENVIRONMENT if ENVIRONMENT != 'preview' else f"preview-{PR_NUMBER}" if PR_NUMBER else 'preview'

        try:
            # Get project details to find environments
            project_resp = session.get(f"{DOKPLOY_URL}/api/project.one?projectId={project_id}", timeout=30)
            project_data = project_resp.json() if project_resp.ok else {}
            environments = project_data.get('environments', [])

            environment_id = None
            for env in environments:
                if env.get('name') == env_name:
                    environment_id = env.get('environmentId')
                    print(f"Found existing environment: {env_name} ({environment_id})")
                    break

            if not environment_id:
                # Create environment
                create_env_resp = session.post(
                    f"{DOKPLOY_URL}/api/environment.create",
                    json={"projectId": project_id, "name": env_name, "description": f"Environment for {env_name}"},
                    timeout=30
                )
                if create_env_resp.ok:
                    environment_id = create_env_resp.json().get('environmentId')
                    print(f"Created environment: {env_name} ({environment_id})")
                else:
                    print(f"Failed to create environment: {create_env_resp.text}")
                    # Try to get the default environment
                    if environments:
                        environment_id = environments[0].get('environmentId')
                        print(f"Using default environment: {environment_id}")

            if not environment_id:
                print("::error::Could not get or create environment")
                output('success', 'false')
                sys.exit(1)

        except Exception as e:
            print(f"::error::Failed to setup environment: {e}")
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

        # =================================================================
        # GET SERVER INFO
        # =================================================================
        print("::group::Resolving server")

        env_config = config.get('environments', {}).get(ENVIRONMENT, {})
        if ENVIRONMENT == 'preview':
            env_config = config.get('environments', {}).get('preview', config.get('environments', {}).get('development', {}))

        server_name = env_config.get('server', 'dev-worker' if ENVIRONMENT != 'production' else 'prod-worker')

        # Override from environment-specific config in project
        if ENVIRONMENT == 'production' and 'production' in config:
            server_name = config['production'].get('server', server_name)

        print(f"Target server: {server_name}")

        # Get server ID from Dokploy
        server_public_ip = None
        try:
            servers_resp = session.get(f"{DOKPLOY_URL}/api/server.all", timeout=30)
            servers = servers_resp.json() if servers_resp.ok else []

            server_id = None
            for s in servers:
                if s.get('name') == server_name:
                    server_id = s.get('serverId')
                    # Get server's public IP
                    try:
                        ip_resp = session.get(
                            f"{DOKPLOY_URL}/api/server.publicIp",
                            params={"serverId": server_id},
                            timeout=30
                        )
                        if ip_resp.ok:
                            ip_data = ip_resp.json()
                            if isinstance(ip_data, str):
                                server_public_ip = ip_data if ip_data else None
                            elif isinstance(ip_data, dict):
                                server_public_ip = ip_data.get('public_ip') or ip_data.get('publicIp') or ip_data.get('ip')
                            else:
                                server_public_ip = None
                            if server_public_ip:
                                print(f"Server public IP: {server_public_ip}")
                    except Exception as e:
                        print(f"::warning::Failed to get server IP: {e}")
                    break

            if not server_id:
                print(f"::warning::Server {server_name} not found in Dokploy, using default")
        except Exception as e:
            print(f"::warning::Failed to get servers: {e}")
            server_id = None

        print("::endgroup::")

        # =================================================================
        # CREATE/UPDATE APPLICATION
        # =================================================================
        print("::group::Setting up application")

        app_name = project_name if ENVIRONMENT == 'production' else f"{project_name}-{ENVIRONMENT}"
        if ENVIRONMENT == 'preview' and PR_NUMBER:
            app_name = f"{project_name}-pr-{PR_NUMBER}"

        # Get build config
        build_config = config.get('build', {})
        build_type = build_config.get('type', 'dockerfile')

        # Get resource config (merge defaults with environment-specific)
        resources = config.get('resources', {}).copy()
        if ENVIRONMENT == 'production' and 'production' in config:
            resources.update({k: v for k, v in config['production'].items() if k in ['memory', 'cpu', 'replicas']})

        try:
            # Check if app exists by getting project details which include applications
            # The application.all endpoint doesn't exist - apps are nested in project.one response
            project_detail_resp = session.get(
                f"{DOKPLOY_URL}/api/project.one",
                params={"projectId": project_id},
                timeout=30
            )

            apps = []
            if project_detail_resp.ok:
                project_detail = project_detail_resp.json()

                # Applications are nested under environments in Dokploy API
                for env in project_detail.get('environments', []):
                    apps.extend(env.get('applications', []))

                print(f"Found {len(apps)} applications in project {project_name}")
            else:
                print(f"::warning::Failed to get project details: {project_detail_resp.status_code}")

            app_id = None
            app_exists = False
            for a in apps:
                if a.get('name') == app_name:
                    app_id = a.get('applicationId')
                    app_exists = True
                    print(f"Found existing application: {app_name} ({app_id})")
                    break

            # Get GitHub repository URL
            github_repo = os.environ.get('GITHUB_REPOSITORY', '')
            github_url = f"https://github.com/{github_repo}" if github_repo else ''

            if not app_id:
                # Create application
                app_data = {
                    "name": app_name,
                    "projectId": project_id,
                    "environmentId": environment_id,
                    "buildType": build_type,
                }
                if server_id:
                    app_data["serverId"] = server_id

                create_app_resp = session.post(
                    f"{DOKPLOY_URL}/api/application.create",
                    json=app_data,
                    timeout=30
                )
                create_app_resp.raise_for_status()
                app_id = create_app_resp.json().get('applicationId')
                print(f"Created application: {app_name} ({app_id})")

            # Configure source: Docker image takes precedence, else GitHub
            if DOCKER_IMAGE:
                print(f"Configuring Docker source: {DOCKER_IMAGE}")
                source_data = {
                    "applicationId": app_id,
                    "sourceType": "docker",
                    "dockerImage": DOCKER_IMAGE,
                }
                try:
                    source_resp = session.post(
                        f"{DOKPLOY_URL}/api/application.update",
                        json=source_data,
                        timeout=30
                    )
                    if source_resp.ok:
                        print(f"Application configured with Docker image: {DOCKER_IMAGE}")
                    else:
                        print(f"::warning::Docker source config response: {source_resp.status_code} - {source_resp.text[:200]}")
                except Exception as e:
                    print(f"::warning::Failed to configure Docker source: {e}")
            elif github_url:
                # Fallback to GitHub source if no Docker image provided
                source_data = {
                    "applicationId": app_id,
                    "sourceType": "github",
                    "customGitUrl": github_url,
                    "customGitBranch": "main"
                }
                try:
                    source_resp = session.post(
                        f"{DOKPLOY_URL}/api/application.update",
                        json=source_data,
                        timeout=30
                    )
                    if source_resp.ok:
                        print(f"Source configured: {github_url}")
                    else:
                        print(f"::warning::Source config response: {source_resp.status_code} - {source_resp.text[:200]}")
                except Exception as e:
                    print(f"::warning::Failed to configure source: {e}")

        except Exception as e:
            print(f"::error::Failed to setup application: {e}")
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

        # =================================================================
        # CONFIGURE DOMAIN (only if domain is set)
        # =================================================================
        print("::group::Configuring domain")

        if domain:
            try:
                domain_data = {
                    "applicationId": app_id,
                    "host": domain,
                    "https": True,
                    "certificateType": "letsencrypt"
                }

                session.post(
                    f"{DOKPLOY_URL}/api/domain.create",
                    json=domain_data,
                    timeout=30
                )
                print(f"Domain configured: {domain}")
            except Exception as e:
                print(f"::warning::Domain configuration: {e}")
        else:
            print("No domain configured, skipping domain setup")

        print("::endgroup::")

        # =================================================================
        # TRIGGER DEPLOYMENT
        # =================================================================
        print("::group::Triggering deployment")

        try:
            deploy_resp = session.post(
                f"{DOKPLOY_URL}/api/application.deploy",
                json={"applicationId": app_id},
                timeout=60
            )
            if deploy_resp.ok:
                print(f"Deployment triggered for {app_name}")
            else:
                print(f"::warning::Deployment trigger response: {deploy_resp.status_code}")
        except Exception as e:
            print(f"::warning::Failed to trigger deployment: {e}")

        print("::endgroup::")

        # =================================================================
        # OUTPUT RESULTS
        # =================================================================
        output('project-id', project_id)
        output('application-id', app_id)
        output('domain', domain)
        output('server-ip', server_public_ip or '')
        output('success', 'true')

        print("")
        print("=" * 60)
        print(f"Project: {project_name}")
        print(f"Application: {app_name}")
        if domain:
            print(f"Domain: https://{domain}")
        else:
            print("Domain: (not configured)")
        print(f"Environment: {ENVIRONMENT}")
        print("=" * 60)

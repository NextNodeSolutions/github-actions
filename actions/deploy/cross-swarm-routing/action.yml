name: 'Cross-Swarm Traefik Routing'
description: 'Auto-configure Traefik for cross-Swarm services when app runs on different server than Traefik'
author: 'NextNodeSolutions'

inputs:
  app-name:
    description: 'Dokploy application name (used for service name and Traefik config)'
    required: true
  domain:
    description: 'Domain to route to this service'
    required: true
  worker-tailscale-ip:
    description: 'Tailscale IP of the worker running the service'
    required: true
  admin-tailscale-ip:
    description: 'Tailscale IP of admin-dokploy (Traefik server)'
    required: true
  container-port:
    description: 'Container port the application listens on'
    required: true
  use-https:
    description: 'Whether to use HTTPS for the domain (with Let''s Encrypt)'
    required: false
    default: 'true'
  ssh-private-key:
    description: 'SSH private key for connecting to servers'
    required: true

outputs:
  external-port:
    description: 'Deterministic external port assigned to this service'
    value: ${{ steps.routing.outputs.external-port }}
  traefik-config-path:
    description: 'Path to generated Traefik config file'
    value: ${{ steps.routing.outputs.traefik-config-path }}

runs:
  using: 'composite'
  steps:
    - name: Configure Cross-Swarm Routing
      id: routing
      shell: bash
      run: |
        echo "::group::Cross-Swarm Routing Configuration"

        APP_NAME="${{ inputs.app-name }}"
        DOMAIN="${{ inputs.domain }}"
        WORKER_IP="${{ inputs.worker-tailscale-ip }}"
        ADMIN_IP="${{ inputs.admin-tailscale-ip }}"
        CONTAINER_PORT="${{ inputs.container-port }}"
        USE_HTTPS="${{ inputs.use-https }}"

        echo "App Name: $APP_NAME"
        echo "Domain: $DOMAIN"
        echo "Worker IP: $WORKER_IP"
        echo "Admin IP: $ADMIN_IP"
        echo "Container Port: $CONTAINER_PORT"
        echo "Use HTTPS: $USE_HTTPS"

        # Generate deterministic port from app name hash
        # Using first 8 chars of MD5 hash, converted to decimal, mapped to port range 10000-65535
        HASH=$(echo -n "$APP_NAME" | md5sum | cut -c1-8)
        HASH_DEC=$((16#$HASH))
        EXTERNAL_PORT=$((10000 + (HASH_DEC % 55535)))

        echo "Calculated external port: $EXTERNAL_PORT (from hash: $HASH)"
        echo "external-port=$EXTERNAL_PORT" >> $GITHUB_OUTPUT

        # Setup SSH key
        mkdir -p ~/.ssh
        echo "${{ inputs.ssh-private-key }}" > ~/.ssh/cross_swarm_key
        chmod 600 ~/.ssh/cross_swarm_key
        SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/cross_swarm_key"

        echo "::endgroup::"

        # Step 1: Publish port on worker server
        echo "::group::Publishing port on worker ($WORKER_IP)"

        # Dokploy creates Docker Swarm services with random names
        # We find the service by its image name which follows a predictable pattern

        ssh $SSH_OPTS root@$WORKER_IP bash <<WORKER_SCRIPT
        set -e

        echo "Looking for Docker service with image matching: $APP_NAME"

        # Find the service by its image name
        # Dokploy creates random service names like "app-navigate-haptic-array-ukwb4a"
        # But the image follows the pattern: admin-dokploy:5000/{app-name}:{commit-sha}
        SERVICE_NAME=\$(docker service ls --format '{{.Name}}\t{{.Image}}' | grep -F "/${APP_NAME}:" | cut -f1 | head -1 || echo "")

        if [ -z "\$SERVICE_NAME" ]; then
          echo "::error::No service found with image containing /${APP_NAME}:"
          echo "Available services:"
          docker service ls --format '{{.Name}}\t{{.Image}}'
          exit 1
        fi

        echo "Found service: \$SERVICE_NAME"

        # Check if port is already published
        EXISTING_PORTS=\$(docker service inspect \$SERVICE_NAME --format '{{range .Endpoint.Ports}}{{.PublishedPort}}:{{.TargetPort}} {{end}}' 2>/dev/null || echo "")
        echo "Existing published ports: \$EXISTING_PORTS"

        if echo "\$EXISTING_PORTS" | grep -q "$EXTERNAL_PORT:$CONTAINER_PORT"; then
          echo "Port $EXTERNAL_PORT:$CONTAINER_PORT already published"
        else
          echo "Publishing port $EXTERNAL_PORT:$CONTAINER_PORT"
          docker service update --publish-add $EXTERNAL_PORT:$CONTAINER_PORT \$SERVICE_NAME || {
            echo "Warning: Failed to update service (may not exist yet)"
            echo "Port will be published on next deployment"
          }
        fi
        WORKER_SCRIPT

        echo "::endgroup::"

        # Step 2: Generate and deploy Traefik config
        echo "::group::Deploying Traefik config to admin ($ADMIN_IP)"

        TRAEFIK_CONFIG_PATH="/var/lib/dokploy/traefik/dynamic/${APP_NAME}.yml"
        echo "traefik-config-path=$TRAEFIK_CONFIG_PATH" >> $GITHUB_OUTPUT

        # Generate Traefik configuration
        if [ "$USE_HTTPS" = "true" ]; then
          cat > /tmp/traefik-config.yml <<EOF
        # Auto-generated by cross-swarm-routing action
        # App: $APP_NAME
        # Worker: $WORKER_IP:$EXTERNAL_PORT -> :$CONTAINER_PORT
        http:
          routers:
            $APP_NAME:
              rule: "Host(\`$DOMAIN\`)"
              service: "$APP_NAME"
              entryPoints:
                - "websecure"
              tls:
                certResolver: "letsencrypt"
            ${APP_NAME}-http:
              rule: "Host(\`$DOMAIN\`)"
              service: "$APP_NAME"
              entryPoints:
                - "web"
              middlewares:
                - "redirect-https"
          services:
            $APP_NAME:
              loadBalancer:
                servers:
                  - url: "http://$WORKER_IP:$EXTERNAL_PORT"
        EOF
        else
          cat > /tmp/traefik-config.yml <<EOF
        # Auto-generated by cross-swarm-routing action
        # App: $APP_NAME
        # Worker: $WORKER_IP:$EXTERNAL_PORT -> :$CONTAINER_PORT
        http:
          routers:
            $APP_NAME:
              rule: "Host(\`$DOMAIN\`)"
              service: "$APP_NAME"
              entryPoints:
                - "web"
          services:
            $APP_NAME:
              loadBalancer:
                servers:
                  - url: "http://$WORKER_IP:$EXTERNAL_PORT"
        EOF
        fi

        echo "Generated Traefik config:"
        cat /tmp/traefik-config.yml

        # Copy config to admin server
        scp $SSH_OPTS /tmp/traefik-config.yml root@$ADMIN_IP:$TRAEFIK_CONFIG_PATH

        echo "Traefik config deployed to $TRAEFIK_CONFIG_PATH"
        echo "Traefik will auto-reload via file provider watch"

        # Cleanup
        rm -f /tmp/traefik-config.yml ~/.ssh/cross_swarm_key

        echo "::endgroup::"

        echo ""
        echo "Cross-Swarm routing configured successfully!"
        echo "  Domain: $DOMAIN"
        echo "  Route: Traefik ($ADMIN_IP) -> Worker ($WORKER_IP:$EXTERNAL_PORT)"

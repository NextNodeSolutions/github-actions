name: 'VPS Tailscale Wait'
description: 'Wait for VPS to join Tailscale network with robust error handling'
author: 'NextNodeSolutions'

inputs:
  vps-name:
    description: 'Name of the VPS to wait for'
    required: true
  tailscale-api-key:
    description: 'Tailscale API key for status checks'
    required: true
  timeout-seconds:
    description: 'Maximum time to wait in seconds'
    required: false
    default: '300'
  poll-interval:
    description: 'Seconds between checks'
    required: false
    default: '10'

outputs:
  tailscale-ip:
    description: 'Tailscale IP address once connected'
    value: ${{ steps.wait.outputs.tailscale-ip }}
  online:
    description: 'Whether the VPS is online in Tailscale'
    value: ${{ steps.wait.outputs.online }}

runs:
  using: 'composite'
  steps:
    - name: Wait for Tailscale Connection
      id: wait
      shell: bash
      env:
        TAILSCALE_API_KEY: ${{ inputs.tailscale-api-key }}
        VPS_NAME: ${{ inputs.vps-name }}
        TIMEOUT_SECONDS: ${{ inputs.timeout-seconds }}
        POLL_INTERVAL: ${{ inputs.poll-interval }}
      run: |
        echo "::group::Waiting for Tailscale"
        echo "VPS: $VPS_NAME"
        echo "Timeout: ${TIMEOUT_SECONDS}s"
        echo "Poll interval: ${POLL_INTERVAL}s"

        VPS_NAME_LOWER=$(echo "$VPS_NAME" | tr '[:upper:]' '[:lower:]')
        MAX_ATTEMPTS=$((TIMEOUT_SECONDS / POLL_INTERVAL))
        CONSECUTIVE_API_ERRORS=0
        MAX_CONSECUTIVE_ERRORS=3
        RESPONSE_FILE=$(mktemp)

        # Cleanup on exit
        trap "rm -f $RESPONSE_FILE" EXIT

        for attempt in $(seq 1 $MAX_ATTEMPTS); do
          # Get HTTP status code separately from response body
          HTTP_CODE=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" \
            -H "Authorization: Bearer ${TAILSCALE_API_KEY}" \
            "https://api.tailscale.com/api/v2/tailnet/-/devices" 2>/dev/null || echo "000")

          # Fail fast on authentication errors
          if [[ "$HTTP_CODE" == "401" || "$HTTP_CODE" == "403" ]]; then
            echo "::error::Tailscale API authentication failed (HTTP $HTTP_CODE)"
            echo "::error::Check that TAILSCALE_API_KEY is valid and has device read permissions"
            echo "tailscale-ip=" >> $GITHUB_OUTPUT
            echo "online=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 1
          fi

          # Handle rate limiting with backoff
          if [[ "$HTTP_CODE" == "429" ]]; then
            BACKOFF=$((POLL_INTERVAL * attempt))
            echo "::warning::Rate limited (HTTP 429), backing off for ${BACKOFF}s"
            sleep $BACKOFF
            continue
          fi

          # Handle server errors with retry limit
          if [[ "$HTTP_CODE" =~ ^5 || "$HTTP_CODE" == "000" ]]; then
            CONSECUTIVE_API_ERRORS=$((CONSECUTIVE_API_ERRORS + 1))
            if [[ $CONSECUTIVE_API_ERRORS -ge $MAX_CONSECUTIVE_ERRORS ]]; then
              echo "::error::Tailscale API unavailable after $MAX_CONSECUTIVE_ERRORS consecutive failures (HTTP $HTTP_CODE)"
              echo "tailscale-ip=" >> $GITHUB_OUTPUT
              echo "online=false" >> $GITHUB_OUTPUT
              echo "::endgroup::"
              exit 1
            fi
            BACKOFF=$((POLL_INTERVAL * CONSECUTIVE_API_ERRORS))
            echo "::warning::Tailscale API error (HTTP $HTTP_CODE), attempt $CONSECUTIVE_API_ERRORS/$MAX_CONSECUTIVE_ERRORS, backing off ${BACKOFF}s"
            sleep $BACKOFF
            continue
          fi

          # Reset error counter on successful API call
          CONSECUTIVE_API_ERRORS=0

          # Validate response structure
          if ! jq -e '.devices' "$RESPONSE_FILE" > /dev/null 2>&1; then
            echo "::error::Invalid API response - missing .devices array"
            echo "Response body:"
            cat "$RESPONSE_FILE"
            echo "tailscale-ip=" >> $GITHUB_OUTPUT
            echo "online=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 1
          fi

          # Get device count for diagnostics
          DEVICE_COUNT=$(jq '.devices | length' "$RESPONSE_FILE")

          # Find device by hostname (case-insensitive) and extract 100.x Tailscale IP
          TAILSCALE_IP=$(jq -r --arg name "$VPS_NAME_LOWER" \
            '.devices[] | select((.hostname | ascii_downcase) == $name or ((.hostname | ascii_downcase) | startswith($name + "-"))) | .addresses[] | select(startswith("100."))' \
            "$RESPONSE_FILE" 2>/dev/null | head -1)

          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "null" ]]; then
            echo "VPS joined Tailscale: $TAILSCALE_IP"
            echo "tailscale-ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
            echo "online=true" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          ELAPSED=$((attempt * POLL_INTERVAL))
          echo "Attempt $attempt/$MAX_ATTEMPTS: '$VPS_NAME' not found ($DEVICE_COUNT devices in tailnet, ${ELAPSED}s elapsed)"
          sleep $POLL_INTERVAL
        done

        # Final diagnostic output on timeout
        echo "::error::VPS did not join Tailscale after ${TIMEOUT_SECONDS} seconds"

        # Show available hostnames for debugging
        HOSTNAMES=$(jq -r '.devices[].hostname' "$RESPONSE_FILE" 2>/dev/null | sort | tr '\n' ', ' | sed 's/,$//')
        echo "::error::Available devices ($DEVICE_COUNT): $HOSTNAMES"
        echo "::error::Looking for: '$VPS_NAME' (case-insensitive)"

        echo "tailscale-ip=" >> $GITHUB_OUTPUT
        echo "online=false" >> $GITHUB_OUTPUT
        echo "::endgroup::"
        exit 1

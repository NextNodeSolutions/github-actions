name: 'Docker Build and Push'
description: 'Build Docker image and push to private registry via Tailscale'
author: 'NextNodeSolutions'

inputs:
  tailscale-oauth-client-id:
    description: 'Tailscale OAuth client ID for connecting to private network'
    required: true
  tailscale-oauth-secret:
    description: 'Tailscale OAuth secret for connecting to private network'
    required: true
  registry-host:
    description: 'Docker registry hostname'
    default: 'registry.nextnode.fr'
  dockerfile:
    description: 'Path to Dockerfile'
    default: 'Dockerfile'
  context:
    description: 'Docker build context'
    default: '.'
  build-args:
    description: 'Docker build arguments (KEY=VALUE format, one per line)'
    default: ''
  tags:
    description: 'Image tags (comma-separated). Auto-generates if empty.'
    default: ''

outputs:
  image:
    description: 'Full image reference (registry/repo:tag)'
    value: ${{ steps.push.outputs.image }}

runs:
  using: 'composite'
  steps:
    - name: Connect to Tailscale
      uses: nextnodesolutions/github-actions/actions/infrastructure/tailscale-connect@main
      with:
        oauth-client-id: ${{ inputs.tailscale-oauth-client-id }}
        oauth-secret: ${{ inputs.tailscale-oauth-secret }}
        wait-for-hostname: admin-dokploy

    - name: Test Registry Connection
      id: registry
      shell: bash
      env:
        REGISTRY_HOST: ${{ inputs.registry-host }}
      run: |
        echo "::group::Testing registry connection"

        # Get admin-dokploy Tailscale IP for fallback
        REGISTRY_IP=$(tailscale status --json | jq -r '.Peer | to_entries[] | select(.value.HostName == "admin-dokploy") | .value.TailscaleIPs[0]')

        if [[ -z "$REGISTRY_IP" || "$REGISTRY_IP" == "null" ]]; then
          echo "::error::Failed to get admin-dokploy IP from Tailscale"
          exit 1
        fi

        echo "Registry IP: $REGISTRY_IP"
        echo "registry-ip=$REGISTRY_IP" >> $GITHUB_OUTPUT

        # Primary: Try HTTPS via hostname (Traefik with proper TLS)
        if curl --resolve "${REGISTRY_HOST}:443:${REGISTRY_IP}" "https://${REGISTRY_HOST}/v2/" -sf --connect-timeout 10; then
          echo "Registry connection OK via HTTPS (${REGISTRY_HOST})"
          echo "use-fallback=false" >> $GITHUB_OUTPUT
          echo "registry-url=${REGISTRY_HOST}" >> $GITHUB_OUTPUT
        # Fallback: Direct HTTP via Tailscale IP (only accessible from Tailscale network)
        elif curl -sf "http://${REGISTRY_IP}:5000/v2/" --connect-timeout 10; then
          echo "::warning::HTTPS failed, using Tailscale fallback (HTTP on ${REGISTRY_IP}:5000)"
          echo "This is secure: only Tailscale nodes can reach this IP"
          echo "use-fallback=true" >> $GITHUB_OUTPUT
          echo "registry-url=${REGISTRY_IP}:5000" >> $GITHUB_OUTPUT
        else
          echo "::error::Cannot connect to registry via HTTPS or Tailscale fallback"
          exit 1
        fi
        echo "::endgroup::"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host
        buildkitd-config-inline: |
          [registry."${{ inputs.registry-host }}"]
            insecure = true
          [registry."${{ steps.registry.outputs.registry-ip }}:5000"]
            http = true
            insecure = true

    - name: Generate Image Tag
      id: tag
      shell: bash
      env:
        CUSTOM_TAGS: ${{ inputs.tags }}
        REGISTRY_URL: ${{ steps.registry.outputs.registry-url }}
      run: |
        echo "::group::Generating image tag"
        REPO_NAME="${GITHUB_REPOSITORY#*/}"
        SHA_SHORT="${GITHUB_SHA:0:7}"

        if [ -n "$CUSTOM_TAGS" ]; then
          FIRST_TAG="${CUSTOM_TAGS%%,*}"
        else
          FIRST_TAG="${SHA_SHORT}"
        fi

        IMAGE="${REGISTRY_URL}/${REPO_NAME}:${FIRST_TAG}"
        echo "image=${IMAGE}" >> $GITHUB_OUTPUT
        echo "Generated image tag: ${IMAGE}"
        echo "::endgroup::"

    - name: Build and Push
      id: push
      shell: bash
      env:
        DOCKERFILE: ${{ inputs.dockerfile }}
        CONTEXT: ${{ inputs.context }}
        BUILD_ARGS: ${{ inputs.build-args }}
        IMAGE: ${{ steps.tag.outputs.image }}
        REGISTRY_HOST: ${{ inputs.registry-host }}
        REGISTRY_IP: ${{ steps.registry.outputs.registry-ip }}
        USE_FALLBACK: ${{ steps.registry.outputs.use-fallback }}
      run: |
        echo "::group::Building and pushing Docker image"

        BUILD_ARGS_FLAGS=""
        if [ -n "$BUILD_ARGS" ]; then
          while IFS= read -r arg; do
            [ -n "$arg" ] && BUILD_ARGS_FLAGS="$BUILD_ARGS_FLAGS --build-arg $arg"
          done <<< "$BUILD_ARGS"
        fi

        # Add --add-host for hostname resolution when using HTTPS mode
        ADD_HOST_FLAG=""
        if [ "$USE_FALLBACK" = "false" ]; then
          ADD_HOST_FLAG="--add-host ${REGISTRY_HOST}:${REGISTRY_IP}"
        fi

        docker buildx build \
          --file "$DOCKERFILE" \
          --tag "$IMAGE" \
          $ADD_HOST_FLAG \
          --push \
          --network=host \
          $BUILD_ARGS_FLAGS \
          "$CONTEXT"

        echo "image=${IMAGE}" >> $GITHUB_OUTPUT
        echo "Successfully pushed: ${IMAGE}"
        echo "::endgroup::"

name: 'Docker Build and Push'
description: 'Build Docker image and push to private registry via Tailscale'
author: 'NextNodeSolutions'

inputs:
  tailscale-oauth-client-id:
    description: 'Tailscale OAuth client ID for connecting to private network'
    required: true
  tailscale-oauth-secret:
    description: 'Tailscale OAuth secret for connecting to private network'
    required: true
  registry-host:
    description: 'Docker registry hostname'
    default: 'registry.nextnode.fr'
  dockerfile:
    description: 'Path to Dockerfile'
    default: 'Dockerfile'
  context:
    description: 'Docker build context'
    default: '.'
  build-args:
    description: 'Docker build arguments (KEY=VALUE format, one per line)'
    default: ''
  tags:
    description: 'Image tags (comma-separated). Auto-generates if empty.'
    default: ''

outputs:
  image:
    description: 'Full image reference (registry/repo:tag)'
    value: ${{ steps.push.outputs.image }}

runs:
  using: 'composite'
  steps:
    - name: Connect to Tailscale
      uses: nextnodesolutions/github-actions/actions/infrastructure/tailscale-connect@main
      with:
        oauth-client-id: ${{ inputs.tailscale-oauth-client-id }}
        oauth-secret: ${{ inputs.tailscale-oauth-secret }}
        wait-for-hostname: admin-dokploy

    - name: Test Registry Connection
      id: registry
      shell: bash
      env:
        REGISTRY_HOST: ${{ inputs.registry-host }}
      run: |
        echo "::group::Testing registry connection"

        # Get admin-dokploy Tailscale IP (registry runs on this machine)
        # This bypasses DNS resolution issues in GitHub Actions runners
        REGISTRY_IP=$(tailscale status --json | jq -r '.Peer | to_entries[] | select(.value.HostName == "admin-dokploy") | .value.TailscaleIPs[0]')

        if [[ -z "$REGISTRY_IP" || "$REGISTRY_IP" == "null" ]]; then
          echo "::error::Failed to get admin-dokploy IP from Tailscale"
          tailscale status --json | jq '.Peer | to_entries[] | {hostname: .value.HostName, ips: .value.TailscaleIPs}'
          exit 1
        fi

        echo "Registry IP: $REGISTRY_IP"
        echo "registry-ip=$REGISTRY_IP" >> $GITHUB_OUTPUT

        # Debug: test basic connectivity
        echo "Testing TCP connectivity to ${REGISTRY_IP}:443..."
        nc -zv -w5 "$REGISTRY_IP" 443 2>&1 || echo "TCP 443 failed"

        echo "Testing TCP connectivity to ${REGISTRY_IP}:80..."
        nc -zv -w5 "$REGISTRY_IP" 80 2>&1 || echo "TCP 80 failed"

        # Test connection with verbose output
        echo "Testing HTTPS with --resolve (verbose)..."
        curl --resolve "${REGISTRY_HOST}:443:${REGISTRY_IP}" "https://${REGISTRY_HOST}/v2/" -vk 2>&1 || true

        echo "Testing HTTP with --resolve..."
        curl --resolve "${REGISTRY_HOST}:80:${REGISTRY_IP}" "http://${REGISTRY_HOST}/v2/" -vk 2>&1 || true

        # Final test
        if curl --resolve "${REGISTRY_HOST}:443:${REGISTRY_IP}" "https://${REGISTRY_HOST}/v2/" -sfLk; then
          echo "Registry connection successful (HTTPS)"
        elif curl --resolve "${REGISTRY_HOST}:80:${REGISTRY_IP}" "http://${REGISTRY_HOST}/v2/" -sfL; then
          echo "Registry connection successful (HTTP)"
        else
          echo "::error::Cannot connect to registry at ${REGISTRY_IP} (${REGISTRY_HOST})"
          exit 1
        fi
        echo "::endgroup::"

    # SECURITY: network=host is required for Tailscale connectivity to private registry.
    # The registry (admin-dokploy:5000) is only accessible via Tailscale network.
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host

    - name: Generate Image Tag
      id: tag
      shell: bash
      env:
        CUSTOM_TAGS: ${{ inputs.tags }}
        REGISTRY_HOST: ${{ inputs.registry-host }}
      run: |
        echo "::group::Generating image tag"
        REPO_NAME="${GITHUB_REPOSITORY#*/}"
        SHA_SHORT="${GITHUB_SHA:0:7}"

        if [ -n "$CUSTOM_TAGS" ]; then
          # Use first custom tag
          FIRST_TAG="${CUSTOM_TAGS%%,*}"
          IMAGE="${REGISTRY_HOST}/${REPO_NAME}:${FIRST_TAG}"
        else
          IMAGE="${REGISTRY_HOST}/${REPO_NAME}:${SHA_SHORT}"
        fi

        echo "image=${IMAGE}" >> $GITHUB_OUTPUT
        echo "Generated image tag: ${IMAGE}"
        echo "::endgroup::"

    - name: Build and Push
      id: push
      shell: bash
      env:
        DOCKERFILE: ${{ inputs.dockerfile }}
        CONTEXT: ${{ inputs.context }}
        BUILD_ARGS: ${{ inputs.build-args }}
        IMAGE: ${{ steps.tag.outputs.image }}
        REGISTRY_HOST: ${{ inputs.registry-host }}
        REGISTRY_IP: ${{ steps.registry.outputs.registry-ip }}
      run: |
        echo "::group::Building and pushing Docker image"

        BUILD_ARGS_FLAGS=""
        if [ -n "$BUILD_ARGS" ]; then
          while IFS= read -r arg; do
            [ -n "$arg" ] && BUILD_ARGS_FLAGS="$BUILD_ARGS_FLAGS --build-arg $arg"
          done <<< "$BUILD_ARGS"
        fi

        # Build and push using hostname with --add-host for DNS override
        # This properly handles TLS SNI (Server Name Indication) unlike IP-based push
        docker buildx build \
          --file "$DOCKERFILE" \
          --tag "$IMAGE" \
          --add-host "${REGISTRY_HOST}:${REGISTRY_IP}" \
          --push \
          --network=host \
          $BUILD_ARGS_FLAGS \
          "$CONTEXT"

        echo "image=${IMAGE}" >> $GITHUB_OUTPUT
        echo "Successfully pushed image: ${IMAGE}"
        echo "::endgroup::"

name: 'Dokploy Initialize Workers'
description: 'Auto-setup Dokploy and register remote servers as workers. Composes atomic actions: dokploy-admin-setup, dokploy-registry-setup, dokploy-ssh-key-import, dokploy-server-register'
author: 'NextNodeSolutions'

inputs:
  dokploy-url:
    description: 'Dokploy instance URL (e.g., https://admin.nextnode.fr)'
    required: true
  dokploy-admin-email:
    description: 'Dokploy admin email (for first-time setup only)'
    required: true
  dokploy-admin-password:
    description: 'Dokploy admin password (for first-time setup only)'
    required: true
  dokploy-api-token:
    description: 'Dokploy API token (from Settings > Profile > API/CLI) - used for worker registration'
    required: true
  dokploy-ssh-private-key:
    description: 'SSH private key to import into Dokploy for worker access'
    required: true
  tailscale-api-token:
    description: 'Tailscale API token for worker IP resolution'
    required: true
  target:
    description: 'Target server(s) to initialize: all, dev-worker, prod-worker'
    required: false
    default: 'all'
  max-retries:
    description: 'Max retries for Tailscale IP resolution'
    required: false
    default: '12'
  retry-delay:
    description: 'Delay between retries in seconds'
    required: false
    default: '10'

outputs:
  success:
    description: 'Whether initialization succeeded'
    value: ${{ steps.result.outputs.success }}
  initialized-workers:
    description: 'Comma-separated list of initialized workers'
    value: ${{ steps.result.outputs.initialized-workers }}
  first-time-setup:
    description: 'Whether this was first-time Dokploy setup'
    value: ${{ steps.admin-setup.outputs.setup-completed }}

runs:
  using: 'composite'
  steps:
    # SEC-002: Mask pass-through secrets at parent level
    # This ensures secrets are masked before being passed to child actions
    - name: Mask Sensitive Inputs
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.dokploy-admin-password }}"
        echo "::add-mask::${{ inputs.dokploy-ssh-private-key }}"
        echo "::add-mask::${{ inputs.dokploy-api-token }}"

    # Step 1: Admin setup (waits for Dokploy, creates admin if first time)
    - name: Setup Dokploy Admin
      id: admin-setup
      uses: nextnodesolutions/github-actions/actions/infrastructure/dokploy-admin-setup@main
      with:
        dokploy-url: ${{ inputs.dokploy-url }}
        admin-email: ${{ inputs.dokploy-admin-email }}
        admin-password: ${{ inputs.dokploy-admin-password }}

    # Step 2: Authenticate with session cookies (for legacy sub-actions)
    - name: Authenticate with Dokploy (Session)
      id: auth
      shell: bash
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        ADMIN_EMAIL: ${{ inputs.dokploy-admin-email }}
        ADMIN_PASSWORD: ${{ inputs.dokploy-admin-password }}
      run: |
        echo "::group::Dokploy Session Authentication"

        # SEC-002: Ensure password is masked
        echo "::add-mask::${ADMIN_PASSWORD}"

        COOKIE_JAR="/tmp/dokploy_cookies_$$.txt"
        echo "cookie-jar=$COOKIE_JAR" >> $GITHUB_OUTPUT

        LOGIN_RESPONSE=$(curl -s -c "$COOKIE_JAR" -X POST "${DOKPLOY_URL}/api/auth/sign-in/email" \
          -H "Content-Type: application/json" \
          -d "{\"email\": \"${ADMIN_EMAIL}\", \"password\": \"${ADMIN_PASSWORD}\"}")

        if ! echo "$LOGIN_RESPONSE" | jq -e '.token' > /dev/null 2>&1; then
          echo "::error::Failed to authenticate with Dokploy"
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::endgroup::"
          exit 1
        fi

        echo "Authentication successful"

        # Get organization ID
        ORGANIZATION_ID=$(echo "$LOGIN_RESPONSE" | jq -r '.user.activeOrganizationId // empty')
        if [[ -z "$ORGANIZATION_ID" ]]; then
          ORGANIZATION_ID=$(echo "$LOGIN_RESPONSE" | jq -r '.user.organizationId // empty')
        fi
        if [[ -z "$ORGANIZATION_ID" ]]; then
          SESSION_RESPONSE=$(curl -s -b "$COOKIE_JAR" "${DOKPLOY_URL}/api/auth/get-session")
          ORGANIZATION_ID=$(echo "$SESSION_RESPONSE" | jq -r '.session.activeOrganizationId // .user.activeOrganizationId // empty')
        fi
        if [[ -z "$ORGANIZATION_ID" ]]; then
          ORG_RESPONSE=$(curl -s -b "$COOKIE_JAR" "${DOKPLOY_URL}/api/organization.all")
          ORGANIZATION_ID=$(echo "$ORG_RESPONSE" | jq -r '.[0].organizationId // .[0].id // empty')
        fi

        if [[ -z "$ORGANIZATION_ID" ]]; then
          echo "::error::Could not get organization ID"
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::endgroup::"
          exit 1
        fi

        echo "Organization ID: $ORGANIZATION_ID"
        echo "organization-id=$ORGANIZATION_ID" >> $GITHUB_OUTPUT
        echo "success=true" >> $GITHUB_OUTPUT

        echo "::endgroup::"

    # Step 3: Configure internal Docker registry
    - name: Configure Registry
      id: registry
      uses: nextnodesolutions/github-actions/actions/infrastructure/dokploy-registry-setup@main
      with:
        dokploy-url: ${{ inputs.dokploy-url }}
        cookie-jar: ${{ steps.auth.outputs.cookie-jar }}

    # Step 4: Import SSH key
    - name: Import SSH Key
      id: ssh-key
      uses: nextnodesolutions/github-actions/actions/infrastructure/dokploy-ssh-key-import@main
      with:
        dokploy-url: ${{ inputs.dokploy-url }}
        cookie-jar: ${{ steps.auth.outputs.cookie-jar }}
        ssh-private-key: ${{ inputs.dokploy-ssh-private-key }}
        organization-id: ${{ steps.auth.outputs.organization-id }}

    # Step 5: Lookup dev-worker in Tailscale
    - name: Lookup dev-worker
      id: dev-worker-lookup
      if: inputs.target == 'all' || inputs.target == 'dev-worker'
      uses: nextnodesolutions/github-actions/actions/utilities/tailscale-device-lookup@main
      with:
        hostname: 'dev-worker'
        tailscale-api-key: ${{ inputs.tailscale-api-token }}
        max-retries: ${{ inputs.max-retries }}
        retry-delay: ${{ inputs.retry-delay }}

    # Step 6: Lookup prod-worker in Tailscale
    - name: Lookup prod-worker
      id: prod-worker-lookup
      if: inputs.target == 'all' || inputs.target == 'prod-worker'
      uses: nextnodesolutions/github-actions/actions/utilities/tailscale-device-lookup@main
      with:
        hostname: 'prod-worker'
        tailscale-api-key: ${{ inputs.tailscale-api-token }}
        max-retries: ${{ inputs.max-retries }}
        retry-delay: ${{ inputs.retry-delay }}

    # Step 7: Setup Python for worker registration
    - name: Setup Python
      uses: nextnodesolutions/github-actions/actions/utilities/python-setup@main
      with:
        packages: 'requests'

    # Step 8: Register workers with Dokploy using API token
    - name: Register Workers
      id: result
      shell: python
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        DOKPLOY_TOKEN: ${{ inputs.dokploy-api-token }}
        SSH_KEY_ID: ${{ steps.ssh-key.outputs.ssh-key-id }}
        TARGET: ${{ inputs.target }}
        DEV_WORKER_IP: ${{ steps.dev-worker-lookup.outputs.ip-address }}
        DEV_WORKER_EXISTS: ${{ steps.dev-worker-lookup.outputs.exists }}
        PROD_WORKER_IP: ${{ steps.prod-worker-lookup.outputs.ip-address }}
        PROD_WORKER_EXISTS: ${{ steps.prod-worker-lookup.outputs.exists }}
      run: |
        import os
        import sys

        from lib.dokploy import DokployClient, DokployError, output

        TARGET = os.environ.get('TARGET', 'all')
        SSH_KEY_ID = os.environ.get('SSH_KEY_ID', '')
        DEV_WORKER_IP = os.environ.get('DEV_WORKER_IP', '')
        DEV_WORKER_EXISTS = os.environ.get('DEV_WORKER_EXISTS', '') == 'true'
        PROD_WORKER_IP = os.environ.get('PROD_WORKER_IP', '')
        PROD_WORKER_EXISTS = os.environ.get('PROD_WORKER_EXISTS', '') == 'true'

        print("::group::Register Dokploy Workers")

        try:
            client = DokployClient.from_env()
            initialized = []

            def register_worker(name: str, ip: str, exists: bool) -> bool:
                print(f"\n=== Processing: {name} ===")

                if not exists or not ip:
                    print(f"::warning::{name} not found in Tailscale, skipping")
                    return False

                print(f"Found {name} at IP: {ip}")

                # Check if server already exists
                existing = client.get_server_by_name(name)
                if existing:
                    server_id = existing.get('serverId')
                    print(f"Server {name} already registered (ID: {server_id})")
                    return True

                # Register server
                print(f"Registering server: {name} ({ip})")
                result = client.create_server(
                    name=name,
                    ip_address=ip,
                    ssh_key_id=SSH_KEY_ID,
                    server_type='deploy',
                )

                server_id = result.get('serverId')
                if not server_id:
                    # Try to get ID by querying again
                    import time
                    time.sleep(1)
                    created = client.get_server_by_name(name)
                    if created:
                        server_id = created.get('serverId')

                if not server_id:
                    print(f"::error::Failed to register {name}")
                    return False

                print(f"Server registered: {server_id}")

                # Setup server
                print("Setting up server...")
                try:
                    client.setup_server(server_id)
                except DokployError:
                    pass  # Setup may take time

                print(f"{name} initialized successfully!")
                return True

            # Register workers based on target
            if TARGET in ('all', 'dev-worker'):
                if register_worker('dev-worker', DEV_WORKER_IP, DEV_WORKER_EXISTS):
                    initialized.append('dev-worker')

            if TARGET in ('all', 'prod-worker'):
                if register_worker('prod-worker', PROD_WORKER_IP, PROD_WORKER_EXISTS):
                    initialized.append('prod-worker')

            print("\n=== Initialization complete ===")
            print(f"Initialized workers: {', '.join(initialized) if initialized else 'none'}")

            output('success', 'true')
            output('initialized-workers', ','.join(initialized))

        except DokployError as e:
            print(f"::error::Dokploy API error: {e}")
            output('success', 'false')
            output('initialized-workers', '')
            sys.exit(1)

        print("::endgroup::")

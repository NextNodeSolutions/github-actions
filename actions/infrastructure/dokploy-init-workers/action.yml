name: 'Dokploy Initialize Workers'
description: 'Auto-setup Dokploy and register remote servers as workers. Composes atomic actions: dokploy-admin-setup, dokploy-registry-setup, dokploy-ssh-key-import, dokploy-server-register'
author: 'NextNodeSolutions'

inputs:
  dokploy-url:
    description: 'Dokploy instance URL (e.g., https://admin.nextnode.fr)'
    required: true
  dokploy-admin-email:
    description: 'Dokploy admin email (for auto-setup)'
    required: true
  dokploy-admin-password:
    description: 'Dokploy admin password (for auto-setup)'
    required: true
  dokploy-ssh-private-key:
    description: 'SSH private key to import into Dokploy for worker access'
    required: true
  tailscale-api-token:
    description: 'Tailscale API token for worker IP resolution'
    required: true
  target:
    description: 'Target server(s) to initialize: all, dev-worker, prod-worker'
    required: false
    default: 'all'
  max-retries:
    description: 'Max retries for Tailscale IP resolution'
    required: false
    default: '12'
  retry-delay:
    description: 'Delay between retries in seconds'
    required: false
    default: '10'

outputs:
  success:
    description: 'Whether initialization succeeded'
    value: ${{ steps.result.outputs.success }}
  initialized-workers:
    description: 'Comma-separated list of initialized workers'
    value: ${{ steps.result.outputs.initialized-workers }}
  first-time-setup:
    description: 'Whether this was first-time Dokploy setup'
    value: ${{ steps.admin-setup.outputs.setup-completed }}

runs:
  using: 'composite'
  steps:
    # SEC-002: Mask pass-through secrets at parent level
    # This ensures secrets are masked before being passed to child actions
    - name: Mask Sensitive Inputs
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.dokploy-admin-password }}"
        echo "::add-mask::${{ inputs.dokploy-ssh-private-key }}"

    # Step 1: Admin setup (waits for Dokploy, creates admin if first time)
    - name: Setup Dokploy Admin
      id: admin-setup
      uses: nextnodesolutions/github-actions/actions/infrastructure/dokploy-admin-setup@main
      with:
        dokploy-url: ${{ inputs.dokploy-url }}
        admin-email: ${{ inputs.dokploy-admin-email }}
        admin-password: ${{ inputs.dokploy-admin-password }}

    # Step 2: Authenticate and get session cookie
    - name: Authenticate with Dokploy
      id: auth
      shell: bash
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        ADMIN_EMAIL: ${{ inputs.dokploy-admin-email }}
        ADMIN_PASSWORD: ${{ inputs.dokploy-admin-password }}
      run: |
        echo "::group::Dokploy Authentication"

        # SEC-002: Ensure password is masked (belt and suspenders with parent mask)
        echo "::add-mask::${ADMIN_PASSWORD}"

        COOKIE_JAR="/tmp/dokploy_cookies_$$.txt"
        echo "cookie-jar=$COOKIE_JAR" >> $GITHUB_OUTPUT

        LOGIN_RESPONSE=$(curl -s -c "$COOKIE_JAR" -X POST "${DOKPLOY_URL}/api/auth/sign-in/email" \
          -H "Content-Type: application/json" \
          -d "{\"email\": \"${ADMIN_EMAIL}\", \"password\": \"${ADMIN_PASSWORD}\"}")

        if ! echo "$LOGIN_RESPONSE" | jq -e '.token' > /dev/null 2>&1; then
          echo "::error::Failed to authenticate with Dokploy"
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::endgroup::"
          exit 1
        fi

        echo "Authentication successful"

        # Get organization ID
        ORGANIZATION_ID=$(echo "$LOGIN_RESPONSE" | jq -r '.user.activeOrganizationId // empty')
        if [[ -z "$ORGANIZATION_ID" ]]; then
          ORGANIZATION_ID=$(echo "$LOGIN_RESPONSE" | jq -r '.user.organizationId // empty')
        fi
        if [[ -z "$ORGANIZATION_ID" ]]; then
          SESSION_RESPONSE=$(curl -s -b "$COOKIE_JAR" "${DOKPLOY_URL}/api/auth/get-session")
          ORGANIZATION_ID=$(echo "$SESSION_RESPONSE" | jq -r '.session.activeOrganizationId // .user.activeOrganizationId // empty')
        fi
        if [[ -z "$ORGANIZATION_ID" ]]; then
          ORG_RESPONSE=$(curl -s -b "$COOKIE_JAR" "${DOKPLOY_URL}/api/organization.all")
          ORGANIZATION_ID=$(echo "$ORG_RESPONSE" | jq -r '.[0].organizationId // .[0].id // empty')
        fi

        if [[ -z "$ORGANIZATION_ID" ]]; then
          echo "::error::Could not get organization ID"
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::endgroup::"
          exit 1
        fi

        echo "Organization ID: $ORGANIZATION_ID"
        echo "organization-id=$ORGANIZATION_ID" >> $GITHUB_OUTPUT
        echo "success=true" >> $GITHUB_OUTPUT

        echo "::endgroup::"

    # Step 3: Configure internal Docker registry
    - name: Configure Registry
      id: registry
      uses: nextnodesolutions/github-actions/actions/infrastructure/dokploy-registry-setup@main
      with:
        dokploy-url: ${{ inputs.dokploy-url }}
        cookie-jar: ${{ steps.auth.outputs.cookie-jar }}

    # Step 4: Import SSH key
    - name: Import SSH Key
      id: ssh-key
      uses: nextnodesolutions/github-actions/actions/infrastructure/dokploy-ssh-key-import@main
      with:
        dokploy-url: ${{ inputs.dokploy-url }}
        cookie-jar: ${{ steps.auth.outputs.cookie-jar }}
        ssh-private-key: ${{ inputs.dokploy-ssh-private-key }}
        organization-id: ${{ steps.auth.outputs.organization-id }}

    # Step 5: Lookup dev-worker in Tailscale
    - name: Lookup dev-worker
      id: dev-worker-lookup
      if: inputs.target == 'all' || inputs.target == 'dev-worker'
      uses: nextnodesolutions/github-actions/actions/utilities/tailscale-device-lookup@main
      with:
        hostname: 'dev-worker'
        tailscale-api-key: ${{ inputs.tailscale-api-token }}
        max-retries: ${{ inputs.max-retries }}
        retry-delay: ${{ inputs.retry-delay }}

    # Step 6: Lookup prod-worker in Tailscale
    - name: Lookup prod-worker
      id: prod-worker-lookup
      if: inputs.target == 'all' || inputs.target == 'prod-worker'
      uses: nextnodesolutions/github-actions/actions/utilities/tailscale-device-lookup@main
      with:
        hostname: 'prod-worker'
        tailscale-api-key: ${{ inputs.tailscale-api-token }}
        max-retries: ${{ inputs.max-retries }}
        retry-delay: ${{ inputs.retry-delay }}

    # Step 7: Register workers with Dokploy
    - name: Register Workers
      id: result
      shell: bash
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        COOKIE_JAR: ${{ steps.auth.outputs.cookie-jar }}
        SSH_KEY_ID: ${{ steps.ssh-key.outputs.ssh-key-id }}
        TARGET: ${{ inputs.target }}
        DEV_WORKER_IP: ${{ steps.dev-worker-lookup.outputs.ip-address }}
        DEV_WORKER_EXISTS: ${{ steps.dev-worker-lookup.outputs.exists }}
        PROD_WORKER_IP: ${{ steps.prod-worker-lookup.outputs.ip-address }}
        PROD_WORKER_EXISTS: ${{ steps.prod-worker-lookup.outputs.exists }}
      run: |
        echo "::group::Register Dokploy Workers"

        INITIALIZED=""

        register_worker() {
          local worker="$1"
          local worker_ip="$2"
          local worker_exists="$3"

          echo ""
          echo "=== Processing: $worker ==="

          if [[ "$worker_exists" != "true" || -z "$worker_ip" ]]; then
            echo "::warning::$worker not found in Tailscale, skipping"
            return
          fi

          echo "Found $worker at IP: $worker_ip"

          # Check if server already exists
          EXISTING_SERVERS=$(curl -s -b "$COOKIE_JAR" "${DOKPLOY_URL}/api/server.all" -H "Content-Type: application/json")
          EXISTING_SERVER_ID=$(echo "$EXISTING_SERVERS" | jq -r ".[] | select(.name == \"$worker\") | .serverId" 2>/dev/null || echo "")

          if [[ -n "$EXISTING_SERVER_ID" ]]; then
            echo "Server $worker already registered (ID: $EXISTING_SERVER_ID)"
            INITIALIZED="$INITIALIZED $worker"
            return
          fi

          # Register server using tRPC format
          echo "Registering server: $worker ($worker_ip)"
          CREATE_DATA=$(jq -n \
            --arg name "$worker" \
            --arg ipAddress "$worker_ip" \
            --arg sshKeyId "$SSH_KEY_ID" \
            '{name: $name, ipAddress: $ipAddress, port: 22, username: "root", sshKeyId: $sshKeyId, serverType: "deploy"}')
          WRAPPED_DATA="{\"0\":{\"json\":${CREATE_DATA}}}"

          curl -s -b "$COOKIE_JAR" -X POST "${DOKPLOY_URL}/api/trpc/server.create?batch=1" \
            -H "Content-Type: application/json" \
            -d "$WRAPPED_DATA" > /dev/null

          sleep 1
          CREATED_SERVERS=$(curl -s -b "$COOKIE_JAR" "${DOKPLOY_URL}/api/server.all" -H "Content-Type: application/json")
          SERVER_ID=$(echo "$CREATED_SERVERS" | jq -r ".[] | select(.name == \"$worker\") | .serverId" 2>/dev/null || echo "")

          if [[ -z "$SERVER_ID" ]]; then
            echo "::error::Failed to register $worker"
            return
          fi

          echo "Server registered: $SERVER_ID"

          # Setup server
          echo "Setting up server..."
          SETUP_DATA=$(jq -n --arg serverId "$SERVER_ID" '{serverId: $serverId}')
          WRAPPED_SETUP="{\"0\":{\"json\":${SETUP_DATA}}}"
          curl -s -b "$COOKIE_JAR" -X POST "${DOKPLOY_URL}/api/trpc/server.setup?batch=1" \
            -H "Content-Type: application/json" \
            -d "$WRAPPED_SETUP" > /dev/null

          echo "$worker initialized successfully!"
          INITIALIZED="$INITIALIZED $worker"
        }

        # Register workers based on target
        if [[ "$TARGET" == "all" || "$TARGET" == "dev-worker" ]]; then
          register_worker "dev-worker" "$DEV_WORKER_IP" "$DEV_WORKER_EXISTS"
        fi

        if [[ "$TARGET" == "all" || "$TARGET" == "prod-worker" ]]; then
          register_worker "prod-worker" "$PROD_WORKER_IP" "$PROD_WORKER_EXISTS"
        fi

        INITIALIZED=$(echo "$INITIALIZED" | xargs | tr ' ' ',')
        echo ""
        echo "=== Initialization complete ==="
        echo "Initialized workers: ${INITIALIZED:-none}"

        echo "success=true" >> $GITHUB_OUTPUT
        echo "initialized-workers=$INITIALIZED" >> $GITHUB_OUTPUT

        echo "::endgroup::"

name: 'Cloudflare SSL/TLS Setup'
description: 'Configure Cloudflare SSL/TLS mode for Railway deployments'

inputs:
  cloudflare-api-token:
    description: 'Cloudflare API token with Zone:Edit permissions'
    required: true
  cloudflare-zone-id:
    description: 'Cloudflare Zone ID (auto-detected if not provided)'
    required: false
  domain:
    description: 'Domain to configure (used for auto-detecting zone if zone-id not provided)'
    required: true
  ssl-mode:
    description: 'SSL/TLS mode: off, flexible, full, strict (Railway requires "full")'
    required: false
    default: 'full'

outputs:
  ssl-configured:
    description: 'Whether SSL/TLS was successfully configured'
    value: ${{ steps.configure-ssl.outputs.configured }}
  current-mode:
    description: 'Current SSL/TLS mode before configuration'
    value: ${{ steps.configure-ssl.outputs.current-mode }}
  new-mode:
    description: 'New SSL/TLS mode after configuration'
    value: ${{ steps.configure-ssl.outputs.new-mode }}
  zone-id:
    description: 'Cloudflare Zone ID (for reuse in subsequent steps)'
    value: ${{ steps.configure-ssl.outputs.zone-id }}

runs:
  using: 'composite'
  steps:
    # Use the shared zone lookup utility if zone-id not provided
    - name: Lookup Cloudflare Zone
      id: zone-lookup
      if: ${{ inputs.cloudflare-zone-id == '' }}
      uses: nextnodesolutions/github-actions/actions/utilities/cloudflare-zone-lookup@main
      with:
        domain: ${{ inputs.domain }}
        cloudflare-api-token: ${{ inputs.cloudflare-api-token }}

    - name: Configure Cloudflare SSL/TLS Mode
      id: configure-ssl
      shell: bash
      env:
        CF_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CF_ZONE_ID: ${{ inputs.cloudflare-zone-id || steps.zone-lookup.outputs.zone-id }}
        DOMAIN: ${{ inputs.domain }}
        SSL_MODE: ${{ inputs.ssl-mode }}
      run: |
        echo "::group::ðŸ”’ Configuring Cloudflare SSL/TLS Mode"

        # Validate inputs
        if [[ -z "$CF_API_TOKEN" ]]; then
          echo "âŒ Cloudflare API token is required"
          exit 1
        fi

        if [[ -z "$DOMAIN" ]]; then
          echo "âŒ Domain is required"
          exit 1
        fi

        if [[ -z "$CF_ZONE_ID" ]]; then
          echo "âŒ Could not determine Zone ID (provide cloudflare-zone-id or ensure domain lookup succeeded)"
          echo "configured=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "ðŸ”§ Configuration:"
        echo "  â€¢ Domain: $DOMAIN"
        echo "  â€¢ Zone ID: $CF_ZONE_ID"
        echo "  â€¢ Target SSL mode: $SSL_MODE"
        echo ""

        # Set zone-id output for reuse
        echo "zone-id=$CF_ZONE_ID" >> $GITHUB_OUTPUT

        # Get current SSL/TLS mode
        echo ""
        echo "ðŸ” Checking current SSL/TLS configuration..."

        SSL_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/settings/ssl" \
          -H "Authorization: Bearer $CF_API_TOKEN" \
          -H "Content-Type: application/json")

        CURRENT_MODE=$(echo "$SSL_RESPONSE" | jq -r '.result.value // empty')

        if [[ -z "$CURRENT_MODE" ]]; then
          echo "âŒ Failed to get current SSL/TLS mode"
          echo "Debug response:"
          echo "$SSL_RESPONSE" | jq '.'
          echo "configured=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "  â€¢ Current mode: $CURRENT_MODE"
        echo "current-mode=$CURRENT_MODE" >> $GITHUB_OUTPUT

        # Check if mode needs to be changed
        if [[ "$CURRENT_MODE" == "$SSL_MODE" ]]; then
          echo ""
          echo "âœ… SSL/TLS mode already set to '$SSL_MODE' - no changes needed"
          echo "configured=true" >> $GITHUB_OUTPUT
          echo "new-mode=$CURRENT_MODE" >> $GITHUB_OUTPUT
          echo "::endgroup::"
          exit 0
        fi

        # Update SSL/TLS mode
        echo ""
        echo "ðŸ”§ Updating SSL/TLS mode from '$CURRENT_MODE' to '$SSL_MODE'..."

        UPDATE_RESPONSE=$(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/settings/ssl" \
          -H "Authorization: Bearer $CF_API_TOKEN" \
          -H "Content-Type: application/json" \
          --data "{\"value\":\"$SSL_MODE\"}")

        UPDATE_SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.success // false')

        if [[ "$UPDATE_SUCCESS" == "true" ]]; then
          NEW_MODE=$(echo "$UPDATE_RESPONSE" | jq -r '.result.value // empty')
          echo "  â€¢ âœ… SSL/TLS mode updated successfully!"
          echo "  â€¢ New mode: $NEW_MODE"
          echo ""
          echo "ðŸ“‹ Summary:"
          echo "  â€¢ Previous mode: $CURRENT_MODE"
          echo "  â€¢ New mode: $NEW_MODE"
          echo "  â€¢ Domain: $DOMAIN"

          echo "configured=true" >> $GITHUB_OUTPUT
          echo "new-mode=$NEW_MODE" >> $GITHUB_OUTPUT

          # Add helpful information based on the mode
          case "$NEW_MODE" in
            "full")
              echo ""
              echo "â„¹ï¸  SSL/TLS Mode: Full"
              echo "   â€¢ Cloudflare encrypts traffic to the origin server"
              echo "   â€¢ Accepts self-signed certificates from Railway"
              echo "   â€¢ âœ… Recommended for Railway deployments"
              ;;
            "strict")
              echo ""
              echo "âš ï¸  SSL/TLS Mode: Full (Strict)"
              echo "   â€¢ Requires valid SSL certificate on Railway"
              echo "   â€¢ May fail if Railway hasn't provisioned the certificate yet"
              echo "   â€¢ Consider using 'full' mode instead"
              ;;
            "flexible")
              echo ""
              echo "âš ï¸  SSL/TLS Mode: Flexible"
              echo "   â€¢ Not recommended for production"
              echo "   â€¢ May cause SSL/TLS errors with Railway"
              echo "   â€¢ Consider using 'full' mode instead"
              ;;
          esac
        else
          echo "  â€¢ âŒ Failed to update SSL/TLS mode"
          echo "Debug response:"
          echo "$UPDATE_RESPONSE" | jq '.'

          # Check for common errors
          ERRORS=$(echo "$UPDATE_RESPONSE" | jq -r '.errors[]?' 2>/dev/null)
          if [[ -n "$ERRORS" ]]; then
            echo ""
            echo "API Errors:"
            echo "$UPDATE_RESPONSE" | jq '.errors[]?'
          fi

          echo "configured=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "::endgroup::"

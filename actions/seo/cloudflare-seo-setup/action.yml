name: 'Cloudflare SEO Setup'
description: 'Automated SEO configuration for Cloudflare - blocks dev subdomains, adds redirections, enables optimizations'

inputs:
  domain:
    description: 'Primary domain (e.g., nextnode.fr)'
    required: true
  blocked-subdomains:
    description: 'Comma-separated list of subdomains to block from search engines'
    required: false
    default: 'dev,staging,test,preview'
  cloudflare-api-token:
    description: 'Cloudflare API token with Zone:Edit permissions'
    required: true
  cloudflare-zone-id:
    description: 'Cloudflare Zone ID (auto-detected if not provided)'
    required: false
  enable-www-redirect:
    description: 'Create www -> non-www redirect'
    required: false
    default: 'true'
  enable-optimizations:
    description: 'Enable Cloudflare performance optimizations'
    required: false
    default: 'true'
  dry-run:
    description: 'Show what would be configured without making changes'
    required: false
    default: 'false'

outputs:
  seo-configured:
    description: 'Whether SEO configuration was successful'
    value: ${{ steps.seo-setup.outputs.success }}
  transform-rules-created:
    description: 'Number of transform rules created for SEO blocking'
    value: ${{ steps.seo-setup.outputs.transform-rules-count }}
  redirects-created:
    description: 'Number of redirect rules created'
    value: ${{ steps.seo-setup.outputs.redirects-count }}

runs:
  using: 'composite'
  steps:
    - name: Setup Cloudflare SEO Configuration
      id: seo-setup
      shell: bash
      env:
        CF_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CF_ZONE_ID: ${{ inputs.cloudflare-zone-id }}
        DOMAIN: ${{ inputs.domain }}
        BLOCKED_SUBDOMAINS: ${{ inputs.blocked-subdomains }}
        ENABLE_WWW_REDIRECT: ${{ inputs.enable-www-redirect }}
        ENABLE_OPTIMIZATIONS: ${{ inputs.enable-optimizations }}
        DRY_RUN: ${{ inputs.dry-run }}
      run: |
        echo "::group::üéØ Cloudflare SEO Setup for $DOMAIN (using Transform Rules)"

        # Validate inputs
        if [[ -z "$CF_API_TOKEN" ]]; then
          echo "‚ùå Cloudflare API token is required"
          exit 1
        fi

        if [[ -z "$DOMAIN" ]]; then
          echo "‚ùå Domain is required"
          exit 1
        fi

        echo "üîß Configuration:"
        echo "  ‚Ä¢ Domain: $DOMAIN"
        echo "  ‚Ä¢ Blocked subdomains: $BLOCKED_SUBDOMAINS"
        echo "  ‚Ä¢ WWW redirect: $ENABLE_WWW_REDIRECT"
        echo "  ‚Ä¢ Optimizations: $ENABLE_OPTIMIZATIONS"
        echo "  ‚Ä¢ Dry run: $DRY_RUN"
        echo ""

        # Get Zone ID if not provided
        if [[ -z "$CF_ZONE_ID" ]]; then
          echo "üîç Auto-detecting Cloudflare Zone ID..."
          ROOT_DOMAIN=$(echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}')

          ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ROOT_DOMAIN" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")

          CF_ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id // empty')

          if [[ -z "$CF_ZONE_ID" ]]; then
            echo "‚ùå Could not find Cloudflare zone for $ROOT_DOMAIN"
            echo "Please provide zone-id manually or check domain configuration"
            exit 1
          fi

          echo "‚úÖ Found Zone ID: $CF_ZONE_ID"
        fi

        # Initialize counters
        TRANSFORM_RULES_COUNT=0
        REDIRECTS_COUNT=0
        SUCCESS=true

        # Function to get or create Transform Rules ruleset
        get_transform_ruleset() {
          local phase="$1"

          # Get existing rulesets for the phase
          RULESET_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/rulesets" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")

          # Check if API call was successful
          API_SUCCESS=$(echo "$RULESET_RESPONSE" | jq -r '.success // false')
          if [[ "$API_SUCCESS" != "true" ]]; then
            echo "‚ùå Failed to get rulesets from Cloudflare API"
            echo "$RULESET_RESPONSE" | jq '.errors[]?' 2>/dev/null || echo "$RULESET_RESPONSE"
            return 1
          fi

          # Look for existing ruleset with the specified phase
          RULESET_ID=$(echo "$RULESET_RESPONSE" | jq -r --arg phase "$phase" '.result // [] | .[] | select(.phase == $phase) | .id // empty')

          if [[ -z "$RULESET_ID" ]]; then
            echo "üìù Creating new $phase ruleset..."

            if [[ "$DRY_RUN" == "true" ]]; then
              echo "  ‚Ä¢ [DRY RUN] Would create ruleset for phase: $phase"
              return 0
            fi

            # Create new ruleset
            CREATE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/rulesets" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{
                "name": "Generated ruleset",
                "description": "Cloudflare SEO Setup - Generated ruleset",
                "kind": "zone",
                "phase": "'"$phase"'"
              }')

            RULESET_ID=$(echo "$CREATE_RESPONSE" | jq -r '.result.id // empty')

            if [[ -z "$RULESET_ID" ]]; then
              echo "‚ùå Failed to create ruleset for phase: $phase"
              echo "$CREATE_RESPONSE" | jq '.errors[]?' 2>/dev/null || echo "$CREATE_RESPONSE"
              return 1
            fi

            echo "‚úÖ Created ruleset: $RULESET_ID"
          else
            echo "‚úÖ Found existing ruleset: $RULESET_ID"
          fi

          echo "$RULESET_ID"
        }

        # Function to create Transform Rules for X-Robots-Tag headers
        create_transform_rules() {
          echo "ü§ñ Creating Transform Rules for X-Robots-Tag headers..."

          # Get or create the http_response_headers_transform ruleset
          TRANSFORM_RULESET_ID=$(get_transform_ruleset "http_response_headers_transform")

          if [[ -z "$TRANSFORM_RULESET_ID" ]]; then
            echo "‚ùå Failed to get Transform Rules ruleset"
            echo "This may indicate insufficient API permissions for Transform Rules"
            SUCCESS=false
            return 1
          fi

          echo "  ‚Ä¢ Using ruleset ID: $TRANSFORM_RULESET_ID"

          # Build rules array for all blocked subdomains
          RULES_JSON="[]"

          IFS=',' read -ra SUBDOMAINS <<< "$BLOCKED_SUBDOMAINS"
          for subdomain in "${SUBDOMAINS[@]}"; do
            subdomain=$(echo "$subdomain" | xargs) # trim whitespace
            if [[ -n "$subdomain" ]]; then
              FULL_DOMAIN="$subdomain.$DOMAIN"

              # Add rule to JSON array
              RULE=$(jq -n \
                --arg expression "http.host eq \"$FULL_DOMAIN\"" \
                --arg description "Block $FULL_DOMAIN from search engines" \
                '{
                  action: "rewrite",
                  expression: $expression,
                  description: $description,
                  action_parameters: {
                    headers: {
                      "X-Robots-Tag": {
                        operation: "set",
                        value: "noindex, nofollow"
                      }
                    }
                  }
                }')

              RULES_JSON=$(echo "$RULES_JSON" | jq --argjson rule "$RULE" '. + [$rule]')

              echo "  ‚Ä¢ üö´ Blocking $FULL_DOMAIN from search engines"
            fi
          done

          if [[ "$DRY_RUN" == "true" ]]; then
            echo "  ‚Ä¢ [DRY RUN] Would create $(echo "$RULES_JSON" | jq 'length') transform rules"
            TRANSFORM_RULES_COUNT=$(echo "$RULES_JSON" | jq 'length')
            return 0
          fi

          # Update the ruleset with new rules
          UPDATE_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/rulesets/$TRANSFORM_RULESET_ID" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$(jq -n --argjson rules "$RULES_JSON" '{rules: $rules}')")

          TRANSFORM_SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.success // false')

          if [[ "$TRANSFORM_SUCCESS" == "true" ]]; then
            TRANSFORM_RULES_COUNT=$(echo "$RULES_JSON" | jq 'length')
            echo "  ‚Ä¢ ‚úÖ Created $TRANSFORM_RULES_COUNT Transform Rules successfully"
          else
            echo "  ‚Ä¢ ‚ùå Failed to create Transform Rules"
            echo "$UPDATE_RESPONSE" | jq '.errors[]?' 2>/dev/null || echo "$UPDATE_RESPONSE"
            SUCCESS=false
          fi
        }

        # Function to create Single Redirect for www -> non-www
        create_redirect_rules() {
          if [[ "$ENABLE_WWW_REDIRECT" != "true" ]]; then
            return 0
          fi

          echo "üîÄ Creating Single Redirect for www ‚Üí non-www..."

          # Get or create the http_request_dynamic_redirect ruleset
          REDIRECT_RULESET_ID=$(get_transform_ruleset "http_request_dynamic_redirect")

          if [[ -z "$REDIRECT_RULESET_ID" ]]; then
            echo "‚ùå Failed to get Single Redirects ruleset"
            SUCCESS=false
            return 1
          fi

          if [[ "$DRY_RUN" == "true" ]]; then
            echo "  ‚Ä¢ [DRY RUN] Would create www ‚Üí non-www redirect rule"
            REDIRECTS_COUNT=1
            return 0
          fi

          # Create redirect rule
          REDIRECT_RULE=$(jq -n \
            --arg expression "http.host eq \"www.$DOMAIN\"" \
            --arg target_url "concat(\"https://$DOMAIN\", http.request.uri.path)" \
            --arg description "Redirect www.$DOMAIN to $DOMAIN" \
            '{
              action: "redirect",
              expression: $expression,
              description: $description,
              action_parameters: {
                from_value: {
                  target_url: {
                    expression: $target_url
                  },
                  status_code: 301,
                  preserve_query_string: true
                }
              }
            }')

          # Update the ruleset with redirect rule
          REDIRECT_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/rulesets/$REDIRECT_RULESET_ID" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$(jq -n --argjson rules "[$REDIRECT_RULE]" '{rules: $rules}')")

          REDIRECT_SUCCESS=$(echo "$REDIRECT_RESPONSE" | jq -r '.success // false')

          if [[ "$REDIRECT_SUCCESS" == "true" ]]; then
            REDIRECTS_COUNT=1
            echo "  ‚Ä¢ ‚úÖ Created www ‚Üí non-www redirect successfully"
          else
            echo "  ‚Ä¢ ‚ùå Failed to create redirect rule"
            echo "$REDIRECT_RESPONSE" | jq '.errors[]?' 2>/dev/null || echo "$REDIRECT_RESPONSE"
            SUCCESS=false
          fi
        }

        # Execute SEO configuration
        create_transform_rules
        create_redirect_rules

        # Enable Cloudflare optimizations if requested
        if [[ "$ENABLE_OPTIMIZATIONS" == "true" ]]; then
          echo ""
          echo "‚ö° Enabling Cloudflare optimizations..."

          if [[ "$DRY_RUN" == "true" ]]; then
            echo "  ‚Ä¢ [DRY RUN] Would enable optimizations:"
            echo "    - Auto Minify (CSS, JS, HTML)"
            echo "    - Brotli compression"
            echo "    - Always Use HTTPS"
            echo "    - Security Level: Medium"
          else
            # Enable Auto Minify
            curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/settings/minify" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"value":{"css":"on","html":"on","js":"on"}}' > /dev/null

            # Enable Brotli
            curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/settings/brotli" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"value":"on"}' > /dev/null

            # Enable Always Use HTTPS
            curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/settings/always_use_https" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"value":"on"}' > /dev/null

            # Set Security Level to Medium
            curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/settings/security_level" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"value":"medium"}' > /dev/null

            echo "  ‚Ä¢ ‚úÖ Cloudflare optimizations enabled"
          fi
        fi

        echo ""
        echo "üìä SEO Configuration Summary:"
        echo "  ‚Ä¢ Transform Rules created: $TRANSFORM_RULES_COUNT"
        echo "  ‚Ä¢ Redirect rules created: $REDIRECTS_COUNT"
        echo "  ‚Ä¢ Overall success: $SUCCESS"
        echo ""
        echo "‚úÖ All SEO configuration completed automatically!"
        echo "   ‚Ä¢ X-Robots-Tag headers configured via Transform Rules"
        echo "   ‚Ä¢ WWW redirects configured via Single Redirects"
        echo "   ‚Ä¢ No manual Cloudflare dashboard steps required"

        # Set outputs
        echo "success=$SUCCESS" >> $GITHUB_OUTPUT
        echo "transform-rules-count=$TRANSFORM_RULES_COUNT" >> $GITHUB_OUTPUT
        echo "redirects-count=$REDIRECTS_COUNT" >> $GITHUB_OUTPUT

        echo "::endgroup::"

        if [[ "$SUCCESS" != "true" ]]; then
          exit 1
        fi

name: 'Log Step'
description: 'Atomic action for consistent logging across workflows'
inputs:
  title:
    description: 'Log title/header'
    required: true
  message:
    description: 'Log message content'
    required: false
    default: ''
  level:
    description: 'Log level (info/warning/error/success/debug)'
    required: false
    default: 'info'
  group:
    description: 'Whether to group the log output'
    required: false
    default: 'false'
  details:
    description: 'Additional details as JSON array or multiline string'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Log Output
      shell: bash
      run: |
        # Define colors and emojis for different levels
        case "${{ inputs.level }}" in
          "error")
            EMOJI="‚ùå"
            COLOR="\033[31m"  # Red
            ;;
          "warning")
            EMOJI="‚ö†Ô∏è"
            COLOR="\033[33m"  # Yellow
            ;;
          "success")
            EMOJI="‚úÖ"
            COLOR="\033[32m"  # Green
            ;;
          "debug")
            EMOJI="üîç"
            COLOR="\033[36m"  # Cyan
            ;;
          *)
            EMOJI="‚ÑπÔ∏è"
            COLOR="\033[34m"  # Blue
            ;;
        esac
        
        RESET="\033[0m"
        
        # Start group if requested
        if [[ "${{ inputs.group }}" == "true" ]]; then
          echo "::group::$EMOJI ${{ inputs.title }}"
        else
          echo -e "${COLOR}$EMOJI ${{ inputs.title }}${RESET}"
        fi
        
        # Output message if provided
        if [[ -n "${{ inputs.message }}" ]]; then
          echo "${{ inputs.message }}"
        fi
        
        # Output details if provided
        if [[ -n "${{ inputs.details }}" ]]; then
          echo ""
          # Check if details is JSON array or multiline string
          if [[ "${{ inputs.details }}" =~ ^\[.*\]$ ]]; then
            # Parse JSON array
            while IFS= read -r line; do
              echo "  ‚Ä¢ $line"
            done < <(echo "${{ inputs.details }}" | jq -r '.[]')
          else
            # Output multiline string
            while IFS= read -r line; do
              [[ -n "$line" ]] && echo "  ‚Ä¢ $line"
            done <<< "${{ inputs.details }}"
          fi
        fi
        
        # End group if started
        if [[ "${{ inputs.group }}" == "true" ]]; then
          echo "::endgroup::"
        fi
        
        # Set appropriate exit code for error level
        if [[ "${{ inputs.level }}" == "error" ]]; then
          exit 1
        else
          exit 0
        fi
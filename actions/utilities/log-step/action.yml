name: 'Log Step'
description: 'Atomic action for consistent logging across workflows'
inputs:
  title:
    description: 'Log title/header'
    required: true
  message:
    description: 'Log message content'
    required: false
    default: ''
  level:
    description: 'Log level (info/warning/error/success/debug)'
    required: false
    default: 'info'
  group:
    description: 'Whether to group the log output'
    required: false
    default: 'false'
  details:
    description: 'Additional details as JSON array or multiline string'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Log Output
      shell: bash
      env:
        INPUT_LEVEL: ${{ inputs.level }}
        INPUT_GROUP: ${{ inputs.group }}
        INPUT_TITLE: ${{ inputs.title }}
        INPUT_MESSAGE: ${{ inputs.message }}
        INPUT_DETAILS: ${{ inputs.details }}
      run: |
        # Define colors and emojis for different levels
        case "$INPUT_LEVEL" in
          "error")
            EMOJI="‚ùå"
            COLOR="\033[31m"  # Red
            ;;
          "warning")
            EMOJI="‚ö†Ô∏è"
            COLOR="\033[33m"  # Yellow
            ;;
          "success")
            EMOJI="‚úÖ"
            COLOR="\033[32m"  # Green
            ;;
          "debug")
            EMOJI="üîç"
            COLOR="\033[36m"  # Cyan
            ;;
          *)
            EMOJI="‚ÑπÔ∏è"
            COLOR="\033[34m"  # Blue
            ;;
        esac

        RESET="\033[0m"

        # Start group if requested
        if [[ "$INPUT_GROUP" == "true" ]]; then
          echo "::group::$EMOJI $INPUT_TITLE"
        else
          echo -e "${COLOR}$EMOJI $INPUT_TITLE${RESET}"
        fi

        # Output message if provided
        if [[ -n "$INPUT_MESSAGE" ]]; then
          echo "$INPUT_MESSAGE"
        fi

        # Output details if provided
        if [[ -n "$INPUT_DETAILS" ]]; then
          echo ""
          # Check if details is JSON array or multiline string
          if [[ "$INPUT_DETAILS" =~ ^\[.*\]$ ]]; then
            # Parse JSON array
            while IFS= read -r line; do
              echo "  ‚Ä¢ $line"
            done < <(echo "$INPUT_DETAILS" | jq -r '.[]')
          else
            # Output multiline string
            while IFS= read -r line; do
              [[ -n "$line" ]] && echo "  ‚Ä¢ $line"
            done <<< "$INPUT_DETAILS"
          fi
        fi

        # End group if started
        if [[ "$INPUT_GROUP" == "true" ]]; then
          echo "::endgroup::"
        fi

        # Set appropriate exit code for error level
        if [[ "$INPUT_LEVEL" == "error" ]]; then
          exit 1
        else
          exit 0
        fi
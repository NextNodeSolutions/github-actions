name: 'Dokploy Compose Sync'
description: 'Create or update Dokploy compose stack'
author: 'NextNodeSolutions'

inputs:
  dokploy-url:
    description: 'Dokploy instance URL'
    required: true
  dokploy-token:
    description: 'Dokploy bearer token'
    required: true
  project-id:
    description: 'Dokploy project ID'
    required: true
  environment-id:
    description: 'Dokploy environment ID'
    required: true
  app-name:
    description: 'Compose stack name'
    required: true
  server-id:
    description: 'Dokploy server ID'
    required: false
    default: ''
  compose-file:
    description: 'Path to docker-compose.yml file'
    required: true
  env:
    description: 'Environment variables for compose (newline-separated KEY=VALUE)'
    required: false
    default: ''
  mounts:
    description: 'File mounts as JSON array of {source, target} objects'
    required: false
    default: '[]'

outputs:
  compose-id:
    description: 'Dokploy compose ID'
    value: ${{ steps.sync.outputs.compose-id }}
  created:
    description: 'Whether compose was created'
    value: ${{ steps.sync.outputs.created }}
  success:
    description: 'Whether operation succeeded'
    value: ${{ steps.sync.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: nextnodesolutions/github-actions/actions/utilities/python-setup@main
      with:
        packages: 'requests'

    - name: Sync compose stack
      id: sync
      shell: python
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        DOKPLOY_TOKEN: ${{ inputs.dokploy-token }}
        PROJECT_ID: ${{ inputs.project-id }}
        ENVIRONMENT_ID: ${{ inputs.environment-id }}
        APP_NAME: ${{ inputs.app-name }}
        SERVER_ID: ${{ inputs.server-id }}
        COMPOSE_FILE: ${{ inputs.compose-file }}
        COMPOSE_ENV: ${{ inputs.env }}
        COMPOSE_MOUNTS: ${{ inputs.mounts }}
      run: |
        import json
        import os
        import sys
        from pathlib import Path

        from lib.dokploy import DEPLOY_TIMEOUT, DokployClient, DokployError, Endpoints, output

        PROJECT_ID = os.environ['PROJECT_ID']
        ENVIRONMENT_ID = os.environ['ENVIRONMENT_ID']
        APP_NAME = os.environ['APP_NAME']
        SERVER_ID = os.environ.get('SERVER_ID', '')
        COMPOSE_FILE = os.environ['COMPOSE_FILE']
        COMPOSE_ENV = os.environ.get('COMPOSE_ENV', '')
        COMPOSE_MOUNTS = os.environ.get('COMPOSE_MOUNTS', '[]')

        print("::group::Syncing compose stack")
        print(f"Compose: {APP_NAME}")

        # Read compose file
        compose_path = Path(COMPOSE_FILE)
        if not compose_path.exists():
            print(f"::error::Compose file not found: {COMPOSE_FILE}")
            output('success', 'false')
            sys.exit(1)

        compose_content = compose_path.read_text()
        print(f"Compose file: {COMPOSE_FILE} ({len(compose_content)} bytes)")

        try:
            client = DokployClient.from_env()

            # Get project details to find existing compose stacks
            project_detail = client.get(
                Endpoints.PROJECT_ONE,
                params={"projectId": PROJECT_ID},
                raise_for_status=False
            )

            composes = []
            if isinstance(project_detail, dict):
                composes = project_detail.get('compose', [])
                for env in project_detail.get('environments', []):
                    composes.extend(env.get('compose', []))

            # Find existing compose
            compose_id = None
            for c in composes:
                if c.get('name') == APP_NAME:
                    compose_id = c.get('composeId')
                    print(f"Found existing compose: {APP_NAME} ({compose_id})")
                    break

            created = False
            if not compose_id:
                # Create compose stack
                compose_data = {
                    "name": APP_NAME,
                    "projectId": PROJECT_ID,
                    "environmentId": ENVIRONMENT_ID,
                    "composeType": "docker-compose",
                }
                if SERVER_ID:
                    compose_data["serverId"] = SERVER_ID

                create_result = client.post(Endpoints.COMPOSE_CREATE, json=compose_data)
                compose_id = create_result.get('composeId')
                created = True
                print(f"Created compose: {APP_NAME} ({compose_id})")

            # Create file mounts before updating compose
            mounts = json.loads(COMPOSE_MOUNTS)
            if mounts:
                print(f"Creating {len(mounts)} file mount(s)...")
                compose_dir = compose_path.parent
                for mount in mounts:
                    source = mount.get('source', '')
                    target = mount.get('target', '')
                    if not source or not target:
                        print(f"::warning::Skipping invalid mount: {mount}")
                        continue

                    source_path = compose_dir / source
                    if not source_path.exists():
                        print(f"::error::Mount source not found: {source_path}")
                        output('success', 'false')
                        sys.exit(1)

                    content = source_path.read_text()
                    mount_payload = {
                        "type": "file",
                        "serviceId": compose_id,
                        "serviceType": "compose",
                        "filePath": target,
                        "mountPath": f"/files/{target}",
                        "content": content,
                    }
                    try:
                        client.post(Endpoints.MOUNT_CREATE, json=mount_payload)
                        print(f"Created mount: {source} -> /files/{target}")
                    except DokployError as e:
                        # Mount may already exist, treat as warning
                        print(f"::warning::Mount creation failed (may exist): {e}")

            # Update compose with file content and environment
            update_payload = {
                "composeId": compose_id,
                "sourceType": "raw",
                "composeFile": compose_content,
            }
            if COMPOSE_ENV:
                update_payload["env"] = COMPOSE_ENV
                print(f"Including {len(COMPOSE_ENV.splitlines())} environment variables")

            try:
                client.post(Endpoints.COMPOSE_UPDATE, json=update_payload)
                print("Compose file updated")
            except DokployError as e:
                print(f"::warning::Compose update failed: {e}")

            # Trigger deployment
            try:
                client.post(
                    Endpoints.COMPOSE_DEPLOY,
                    json={"composeId": compose_id},
                    timeout=DEPLOY_TIMEOUT
                )
                print("Deployment triggered")
            except DokployError as e:
                print(f"::warning::Deployment trigger failed: {e}")

            output('compose-id', compose_id)
            output('created', 'true' if created else 'false')
            output('success', 'true')

        except DokployError as e:
            print(f"::error::Failed to sync compose: {e}")
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

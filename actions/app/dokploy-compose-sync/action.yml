name: 'Dokploy Compose Sync'
description: 'Create or update Dokploy compose stack'
author: 'NextNodeSolutions'

inputs:
  dokploy-url:
    description: 'Dokploy instance URL'
    required: true
  dokploy-token:
    description: 'Dokploy bearer token'
    required: true
  project-id:
    description: 'Dokploy project ID'
    required: true
  environment-id:
    description: 'Dokploy environment ID'
    required: true
  app-name:
    description: 'Compose stack name'
    required: true
  server-id:
    description: 'Dokploy server ID'
    required: false
    default: ''
  compose-file:
    description: 'Path to docker-compose.yml file'
    required: true

outputs:
  compose-id:
    description: 'Dokploy compose ID'
    value: ${{ steps.sync.outputs.compose-id }}
  created:
    description: 'Whether compose was created'
    value: ${{ steps.sync.outputs.created }}
  success:
    description: 'Whether operation succeeded'
    value: ${{ steps.sync.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      shell: bash
      run: pip install requests

    - name: Sync compose stack
      id: sync
      shell: python
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        DOKPLOY_TOKEN: ${{ inputs.dokploy-token }}
        PROJECT_ID: ${{ inputs.project-id }}
        ENVIRONMENT_ID: ${{ inputs.environment-id }}
        APP_NAME: ${{ inputs.app-name }}
        SERVER_ID: ${{ inputs.server-id }}
        COMPOSE_FILE: ${{ inputs.compose-file }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        import os
        import sys
        import requests
        from pathlib import Path

        DOKPLOY_URL = os.environ['DOKPLOY_URL'].rstrip('/')
        DOKPLOY_TOKEN = os.environ['DOKPLOY_TOKEN']
        PROJECT_ID = os.environ['PROJECT_ID']
        ENVIRONMENT_ID = os.environ['ENVIRONMENT_ID']
        APP_NAME = os.environ['APP_NAME']
        SERVER_ID = os.environ.get('SERVER_ID', '')
        COMPOSE_FILE = os.environ['COMPOSE_FILE']
        GITHUB_OUTPUT = os.environ.get('GITHUB_OUTPUT', '')

        def output(key, value):
            if GITHUB_OUTPUT:
                with open(GITHUB_OUTPUT, 'a') as f:
                    f.write(f"{key}={value}\n")

        headers = {
            "Authorization": f"Bearer {DOKPLOY_TOKEN}",
            "Content-Type": "application/json"
        }

        print("::group::Syncing compose stack")
        print(f"Compose: {APP_NAME}")

        # Read compose file
        compose_path = Path(COMPOSE_FILE)
        if not compose_path.exists():
            print(f"::error::Compose file not found: {COMPOSE_FILE}")
            output('success', 'false')
            sys.exit(1)

        compose_content = compose_path.read_text()
        print(f"Compose file: {COMPOSE_FILE} ({len(compose_content)} bytes)")

        try:
            # Get project details to find existing compose stacks
            project_resp = requests.get(
                f"{DOKPLOY_URL}/api/project.one",
                params={"projectId": PROJECT_ID},
                headers=headers,
                timeout=30
            )

            composes = []
            if project_resp.ok:
                project_detail = project_resp.json()
                composes = project_detail.get('compose', [])
                for env in project_detail.get('environments', []):
                    composes.extend(env.get('compose', []))

            # Find existing compose
            compose_id = None
            for c in composes:
                if c.get('name') == APP_NAME:
                    compose_id = c.get('composeId')
                    print(f"Found existing compose: {APP_NAME} ({compose_id})")
                    break

            created = False
            if not compose_id:
                # Create compose stack
                compose_data = {
                    "name": APP_NAME,
                    "projectId": PROJECT_ID,
                    "environmentId": ENVIRONMENT_ID,
                    "composeType": "docker-compose",
                }
                if SERVER_ID:
                    compose_data["serverId"] = SERVER_ID

                create_resp = requests.post(
                    f"{DOKPLOY_URL}/api/compose.create",
                    headers=headers,
                    json=compose_data,
                    timeout=30
                )
                if not create_resp.ok:
                    print(f"::warning::compose.create: {create_resp.status_code} - {create_resp.text[:500]}")
                create_resp.raise_for_status()
                compose_id = create_resp.json().get('composeId')
                created = True
                print(f"Created compose: {APP_NAME} ({compose_id})")

            # Update compose with file content
            update_resp = requests.post(
                f"{DOKPLOY_URL}/api/compose.update",
                headers=headers,
                json={
                    "composeId": compose_id,
                    "sourceType": "raw",
                    "composeFile": compose_content,
                },
                timeout=30
            )
            if update_resp.ok:
                print("Compose file updated")
            else:
                print(f"::warning::Compose update: {update_resp.status_code}")

            # Trigger deployment
            deploy_resp = requests.post(
                f"{DOKPLOY_URL}/api/compose.deploy",
                headers=headers,
                json={"composeId": compose_id},
                timeout=60
            )
            if deploy_resp.ok:
                print("Deployment triggered")
            else:
                print(f"::warning::Deployment trigger: {deploy_resp.status_code}")

            output('compose-id', compose_id)
            output('created', 'true' if created else 'false')
            output('success', 'true')

        except Exception as e:
            print(f"::error::Failed to sync compose: {e}")
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

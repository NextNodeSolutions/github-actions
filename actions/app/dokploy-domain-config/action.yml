name: 'Dokploy Domain Config'
description: 'Configure domain on Dokploy application'
author: 'NextNodeSolutions'

inputs:
  dokploy-url:
    description: 'Dokploy instance URL'
    required: true
  dokploy-token:
    description: 'Dokploy bearer token'
    required: true
  app-id:
    description: 'Dokploy application ID (for application deployments)'
    required: false
    default: ''
  compose-id:
    description: 'Dokploy compose ID (for compose deployments)'
    required: false
    default: ''
  service-name:
    description: 'Service name within compose stack (required for compose)'
    required: false
    default: ''
  domain:
    description: 'Domain hostname'
    required: true
  port:
    description: 'Application port'
    required: false
    default: '3000'
  https:
    description: 'Enable HTTPS'
    required: false
    default: 'true'
  certificate-type:
    description: 'Certificate type (letsencrypt, none). Default is none since Traefik handles wildcard certs.'
    required: false
    default: 'none'

outputs:
  domain-id:
    description: 'Dokploy domain ID'
    value: ${{ steps.config.outputs.domain-id }}
  configured:
    description: 'Whether domain was configured successfully'
    value: ${{ steps.config.outputs.configured }}
  success:
    description: 'Whether operation succeeded'
    value: ${{ steps.config.outputs.success }}
  existed:
    description: 'Whether domain already existed'
    value: ${{ steps.config.outputs.existed }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: nextnodesolutions/github-actions/actions/utilities/python-setup@main
      with:
        packages: 'requests'

    - name: Configure domain
      id: config
      shell: python
      env:
        DOKPLOY_URL: ${{ inputs.dokploy-url }}
        DOKPLOY_TOKEN: ${{ inputs.dokploy-token }}
        APP_ID: ${{ inputs.app-id }}
        COMPOSE_ID: ${{ inputs.compose-id }}
        SERVICE_NAME: ${{ inputs.service-name }}
        DOMAIN: ${{ inputs.domain }}
        PORT: ${{ inputs.port }}
        HTTPS: ${{ inputs.https }}
        CERTIFICATE_TYPE: ${{ inputs.certificate-type }}
      run: |
        import os
        import sys

        from lib.dokploy import DEFAULT_PORT, DokployClient, DokployError, Endpoints, output

        APP_ID = os.environ.get('APP_ID', '')
        COMPOSE_ID = os.environ.get('COMPOSE_ID', '')
        SERVICE_NAME = os.environ.get('SERVICE_NAME', '')
        DOMAIN = os.environ['DOMAIN']
        PORT = int(os.environ.get('PORT', str(DEFAULT_PORT)))
        HTTPS = os.environ.get('HTTPS', 'true').lower() == 'true'
        CERTIFICATE_TYPE = os.environ.get('CERTIFICATE_TYPE', 'letsencrypt')

        # Validate inputs
        if not APP_ID and not COMPOSE_ID:
            print("::error::Either app-id or compose-id must be provided")
            output('success', 'false')
            sys.exit(1)

        if COMPOSE_ID and not SERVICE_NAME:
            print("::error::service-name is required for compose deployments")
            output('success', 'false')
            sys.exit(1)

        is_compose = bool(COMPOSE_ID)
        print("::group::Configuring domain")
        print(f"Domain: {DOMAIN} (port {PORT})")
        if is_compose:
            print(f"Compose: {COMPOSE_ID} (service: {SERVICE_NAME})")
        else:
            print(f"Application: {APP_ID}")

        try:
            client = DokployClient.from_env()

            # Check if domain already exists for this compose/app
            existing_domain_id = None
            try:
                if is_compose:
                    domains = client.get(
                        Endpoints.DOMAIN_BY_COMPOSE_ID,
                        params={"composeId": COMPOSE_ID}
                    )
                else:
                    domains = client.get(
                        Endpoints.DOMAIN_BY_APPLICATION_ID,
                        params={"applicationId": APP_ID}
                    )

                # Check if domain with same host already exists
                if isinstance(domains, list):
                    for d in domains:
                        if d.get('host') == DOMAIN:
                            existing_domain_id = d.get('domainId')
                            print(f"Domain already exists: {DOMAIN} ({existing_domain_id})")
                            break
            except DokployError as e:
                print(f"::warning::Could not check existing domains: {e}")

            if existing_domain_id:
                # Domain already exists, skip creation
                print(f"Using existing domain: {existing_domain_id}")
                output('domain-id', existing_domain_id)
                output('configured', 'true')
                output('existed', 'true')
                output('success', 'true')
            else:
                # Create new domain
                payload = {
                    "host": DOMAIN,
                    "port": PORT,
                    "https": HTTPS,
                    "certificateType": CERTIFICATE_TYPE if HTTPS else "none",
                    "path": "/",
                    "stripPath": False
                }

                if is_compose:
                    payload["composeId"] = COMPOSE_ID
                    payload["serviceName"] = SERVICE_NAME
                else:
                    payload["applicationId"] = APP_ID

                result = client.post(Endpoints.DOMAIN_CREATE, json=payload)

                domain_id = result.get('domainId', '')
                print(f"Domain created: {DOMAIN} ({domain_id})")
                output('domain-id', domain_id)
                output('configured', 'true')
                output('existed', 'false')
                output('success', 'true')

        except DokployError as e:
            print(f"::error::Failed to configure domain: {e}")
            output('domain-id', '')
            output('configured', 'false')
            output('existed', 'false')
            output('success', 'false')
            sys.exit(1)

        print("::endgroup::")

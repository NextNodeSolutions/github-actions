name: 'Config Load'
description: 'Load and merge Dokploy configuration from defaults and project config'
author: 'NextNodeSolutions'

inputs:
  config-file:
    description: 'Path to project dokploy.toml'
    required: false
    default: 'dokploy.toml'
  defaults-file:
    description: 'Path to defaults TOML file'
    required: false
    default: ''
  environment:
    description: 'Target environment: development, preview, production'
    required: true
  pr-number:
    description: 'PR number (for preview deployments)'
    required: false
    default: ''

outputs:
  config-json:
    description: 'Full merged configuration as JSON'
    value: ${{ steps.load.outputs.config-json }}
  project-name:
    description: 'Project name'
    value: ${{ steps.load.outputs.project-name }}
  domain:
    description: 'Computed domain for this environment'
    value: ${{ steps.load.outputs.domain }}
  url:
    description: 'Computed URL for this environment'
    value: ${{ steps.load.outputs.url }}
  app-name:
    description: 'Dokploy application/compose name'
    value: ${{ steps.load.outputs.app-name }}
  server:
    description: 'Target server name'
    value: ${{ steps.load.outputs.server }}
  port:
    description: 'Application port'
    value: ${{ steps.load.outputs.port }}
  is-compose:
    description: 'Whether this is a compose deployment'
    value: ${{ steps.load.outputs.is-compose }}
  compose-file:
    description: 'Path to docker-compose.yml (if compose mode)'
    value: ${{ steps.load.outputs.compose-file }}
  traefik-server:
    description: 'Traefik ingress server name'
    value: ${{ steps.load.outputs.traefik-server }}
  environment-enabled:
    description: 'Whether the environment is enabled'
    value: ${{ steps.load.outputs.environment-enabled }}
  vps-enabled:
    description: 'Whether custom VPS is needed'
    value: ${{ steps.load.outputs.vps-enabled }}
  vps-name:
    description: 'Custom VPS name if VPS enabled'
    value: ${{ steps.load.outputs.vps-name }}
  vps-type:
    description: 'Hetzner server type for VPS'
    value: ${{ steps.load.outputs.vps-type }}
  success:
    description: 'Whether configuration loading succeeded'
    value: ${{ steps.load.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: nextnodesolutions/github-actions/actions/utilities/python-setup@main

    - name: Load configuration
      id: load
      shell: python
      env:
        CONFIG_FILE: ${{ inputs.config-file }}
        DEFAULTS_FILE: ${{ inputs.defaults-file }}
        ENVIRONMENT: ${{ inputs.environment }}
        PR_NUMBER: ${{ inputs.pr-number }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        import os
        import sys
        import json
        from pathlib import Path

        from lib.dokploy.output import output
        from lib.dokploy.config import deep_merge, load_toml
        from lib.dokploy.port import get_port
        from lib.dokploy.domain import compute_domain, compute_url, compute_app_name

        # Configuration from environment
        CONFIG_FILE = os.environ.get('CONFIG_FILE', 'dokploy.toml')
        DEFAULTS_FILE = os.environ.get('DEFAULTS_FILE', '')
        ENVIRONMENT = os.environ.get('ENVIRONMENT', 'development')
        PR_NUMBER = os.environ.get('PR_NUMBER', '')
        GITHUB_REPOSITORY = os.environ.get('GITHUB_REPOSITORY', '')

        # Load and merge configuration
        print("::group::Loading configuration")

        defaults = load_toml(DEFAULTS_FILE) if DEFAULTS_FILE else {}
        if defaults:
            print(f"Loaded defaults from: {DEFAULTS_FILE}")

        project_config = load_toml(CONFIG_FILE)
        if project_config:
            print(f"Loaded project config from: {CONFIG_FILE}")
        else:
            print(f"No {CONFIG_FILE} found, using defaults only")

        config = deep_merge(defaults, project_config)
        print("::endgroup::")

        # Get project name
        project_name = config.get('project', {}).get('name', '')
        if not project_name and GITHUB_REPOSITORY:
            project_name = GITHUB_REPOSITORY.split('/')[-1]
            print(f"Inferred project name from repository: {project_name}")

        if not project_name:
            print("::error::Could not determine project name")
            output('success', 'false')
            sys.exit(1)

        # Get environment config
        env_config = config.get('environments', {}).get(ENVIRONMENT, {})
        if ENVIRONMENT == 'preview':
            env_config = config.get('environments', {}).get('preview', config.get('environments', {}).get('development', {}))

        # Check if environment is enabled
        environment_enabled = True
        if ENVIRONMENT != 'production':
            environment_enabled = env_config.get('enabled', True)

        # Compute domain and URL
        base_domain = config.get('project', {}).get('domain', '')
        domain = compute_domain(base_domain, ENVIRONMENT, PR_NUMBER)
        url = compute_url(domain)

        # Compute app name
        app_name = compute_app_name(project_name, ENVIRONMENT, PR_NUMBER)

        # Get server
        server_name = env_config.get('server', 'dev-worker' if ENVIRONMENT != 'production' else 'prod-worker')

        # Handle custom VPS
        vps_config = config.get('vps', {})
        vps_enabled = vps_config.get('enabled', False)
        vps_type = vps_config.get('type', 'cx23')
        vps_name = ''

        # Scenario 1: Global [vps] -> PROVISION new VPS, all envs deploy on it
        if vps_enabled:
            vps_name = vps_config.get('name', f"{project_name}-worker")
            server_name = vps_name
        # Scenario 2: Deploy on EXISTING VPS (no provisioning)
        elif server_name == 'custom':
            server_name = env_config.get('vps')
            if not server_name:
                print(f"::error::server='custom' requires 'vps' to be set in [environments.{ENVIRONMENT}]")
                output('success', 'false')
                sys.exit(1)
            # vps_enabled stays False - no provisioning needed
        # Scenario 3: Default behavior (dev-worker, prod-worker) - no changes needed

        # Detect port
        config_port = config.get('project', {}).get('port')
        app_port, _ = get_port(config_port)

        # Check compose mode
        compose_config = config.get('compose', {})
        is_compose = compose_config.get('enabled', False)
        compose_file = compose_config.get('file', 'docker-compose.yml') if is_compose else ''

        # Get cluster config
        traefik_server = config.get('cluster', {}).get('traefik-server', 'admin-dokploy')

        # Output results
        output('config-json', json.dumps(config, indent=2))
        output('project-name', project_name)
        output('domain', domain)
        output('url', url)
        output('app-name', app_name)
        output('server', server_name)
        output('port', str(app_port))
        output('is-compose', 'true' if is_compose else 'false')
        output('compose-file', compose_file)
        output('traefik-server', traefik_server)
        output('environment-enabled', 'true' if environment_enabled else 'false')
        output('vps-enabled', 'true' if vps_enabled else 'false')
        output('vps-name', vps_name)
        output('vps-type', vps_type)
        output('success', 'true')

        print("")
        print("=" * 60)
        print(f"Project: {project_name}")
        print(f"Environment: {ENVIRONMENT}")
        print(f"App name: {app_name}")
        print(f"Server: {server_name}")
        print(f"Port: {app_port}")
        if domain:
            print(f"Domain: https://{domain}")
        if is_compose:
            print(f"Compose: {compose_file}")
        print("=" * 60)

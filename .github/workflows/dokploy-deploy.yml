name: Dokploy Deploy

# EXTERNAL WORKFLOW - Deploy to Dokploy
# Syncs project configuration and triggers deployment
# Supports custom VPS provisioning when server = "custom" in config

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment: development, preview, production'
        required: true
        type: string
      config-file:
        description: 'Path to project dokploy.toml'
        required: false
        default: 'dokploy.toml'
        type: string
      pr-number:
        description: 'PR number (for preview deployments)'
        required: false
        default: ''
        type: string
      action:
        description: 'Action: deploy or cleanup'
        required: false
        default: 'deploy'
        type: string
      dockerfile:
        description: 'Path to Dockerfile'
        required: false
        default: 'Dockerfile'
        type: string
      build-context:
        description: 'Docker build context'
        required: false
        default: '.'
        type: string
      build-args:
        description: 'Docker build arguments (KEY=VALUE format, one per line)'
        required: false
        default: ''
        type: string
    secrets:
      DOKPLOY_ADMIN_EMAIL:
        description: 'Dokploy admin email'
        required: true
      DOKPLOY_ADMIN_PASSWORD:
        description: 'Dokploy admin password'
        required: true
      TAILSCALE_OAUTH_CLIENT_ID:
        description: 'Tailscale OAuth client ID'
        required: true
      TAILSCALE_OAUTH_SECRET:
        description: 'Tailscale OAuth secret'
        required: true
      TAILSCALE_API_KEY:
        description: 'Tailscale API key'
        required: true
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token'
        required: true
      # Optional: Required only for custom VPS provisioning
      HETZNER_TOKEN:
        description: 'Hetzner Cloud API token (for custom VPS)'
        required: false
      TAILSCALE_AUTH_KEY:
        description: 'Tailscale auth key for connecting to private registry'
        required: true
      TF_API_TOKEN:
        description: 'Terraform Cloud API token (for custom VPS)'
        required: false
      DOKPLOY_SSH_KEY_ID:
        description: 'Dokploy SSH key ID (for custom VPS)'
        required: false
    outputs:
      project-id:
        description: 'Dokploy project ID'
        value: ${{ jobs.deploy.outputs.project-id }}
      application-id:
        description: 'Dokploy application ID'
        value: ${{ jobs.deploy.outputs.application-id }}
      domain:
        description: 'Deployed domain'
        value: ${{ jobs.deploy.outputs.domain }}
      success:
        description: 'Whether deployment succeeded'
        value: ${{ jobs.deploy.outputs.success }}
      custom-vps-provisioned:
        description: 'Whether a custom VPS was provisioned'
        value: ${{ jobs.deploy.outputs.custom-vps-provisioned }}
      skipped:
        description: 'Whether deployment was skipped (environment disabled)'
        value: ${{ jobs.deploy.outputs.skipped }}
      docker-image:
        description: 'Docker image that was built and pushed'
        value: ${{ jobs.build.outputs.image }}

jobs:
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    if: inputs.action == 'deploy'
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Build and Push to Registry
        id: build
        uses: ./.github-actions/actions/build/docker-build-push
        with:
          tailscale-auth-key: ${{ secrets.TAILSCALE_AUTH_KEY }}
          dockerfile: ${{ inputs.dockerfile }}
          context: ${{ inputs.build-context }}
          build-args: ${{ inputs.build-args }}

  deploy:
    name: Deploy to Dokploy
    runs-on: ubuntu-latest
    needs: [build]
    if: always() && (inputs.action == 'cleanup' || needs.build.result == 'success')
    outputs:
      project-id: ${{ steps.sync.outputs.project-id }}
      application-id: ${{ steps.sync.outputs.application-id }}
      domain: ${{ steps.sync.outputs.domain }}
      success: ${{ steps.check-enabled.outputs.enabled == 'false' && 'skipped' || steps.sync.outputs.success }}
      custom-vps-provisioned: ${{ steps.check-vps.outputs.needs-custom-vps }}
      skipped: ${{ steps.check-enabled.outputs.enabled == 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install tomli
        shell: bash
        run: pip install tomli

      - name: Get Dokploy URL
        id: dokploy-url
        uses: ./.github-actions/actions/infrastructure/tailscale-dokploy-url
        with:
          tailscale-oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          tailscale-oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}

      - name: Check Environment Enabled
        id: check-enabled
        shell: python
        env:
          CONFIG_FILE: ${{ inputs.config-file }}
          DEFAULTS_FILE: .github-actions/config/dokploy-defaults.toml
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          import os
          import tomli
          from pathlib import Path

          config_file = os.environ.get('CONFIG_FILE', 'dokploy.toml')
          defaults_file = os.environ.get('DEFAULTS_FILE', '')
          environment = os.environ.get('ENVIRONMENT', 'production')
          output_file = os.environ.get('GITHUB_OUTPUT', '')

          def deep_merge(base, override):
              result = base.copy()
              for key, value in override.items():
                  if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                      result[key] = deep_merge(result[key], value)
                  else:
                      result[key] = value
              return result

          # Load defaults
          defaults = {}
          if defaults_file and Path(defaults_file).exists():
              with open(defaults_file, 'rb') as f:
                  defaults = tomli.load(f)

          # Load project config
          config = {}
          if Path(config_file).exists():
              with open(config_file, 'rb') as f:
                  config = tomli.load(f)

          # Merge configs
          merged = deep_merge(defaults, config)

          # Check if environment is enabled (production is always enabled)
          enabled = True
          if environment != 'production':
              env_config = merged.get('environments', {}).get(environment, {})
              enabled = env_config.get('enabled', True)

          with open(output_file, 'a') as f:
              f.write(f"enabled={'true' if enabled else 'false'}\n")

          if enabled:
              print(f"Environment '{environment}' is enabled")
          else:
              print(f"::notice::Environment '{environment}' is disabled in config, skipping deployment")

      - name: Skip Disabled Environment
        if: steps.check-enabled.outputs.enabled == 'false'
        run: |
          echo "## Deployment Skipped" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Environment \`${{ inputs.environment }}\` is disabled in \`dokploy.toml\`." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enable, set:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`toml" >> $GITHUB_STEP_SUMMARY
          echo "[environments.${{ inputs.environment }}]" >> $GITHUB_STEP_SUMMARY
          echo "enabled = true" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Check for Custom VPS
        id: check-vps
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && inputs.environment == 'production'
        shell: python
        env:
          CONFIG_FILE: ${{ inputs.config-file }}
          DEFAULTS_FILE: .github-actions/config/dokploy-defaults.toml
        run: |
          import os
          import tomli
          from pathlib import Path

          config_file = os.environ.get('CONFIG_FILE', 'dokploy.toml')
          defaults_file = os.environ.get('DEFAULTS_FILE', '')
          output_file = os.environ.get('GITHUB_OUTPUT', '')

          # Load and merge configs
          defaults = {}
          if defaults_file and Path(defaults_file).exists():
              with open(defaults_file, 'rb') as f:
                  defaults = tomli.load(f)

          config = {}
          if Path(config_file).exists():
              with open(config_file, 'rb') as f:
                  config = tomli.load(f)

          # Check production config for custom server
          prod_config = config.get('production', {})
          server = prod_config.get('server', 'prod-worker')
          vps_name = prod_config.get('vps', '')
          vps_type = prod_config.get('vps_type', 'cx33')
          project_name = config.get('project', {}).get('name', '')

          needs_custom = server == 'custom' and vps_name

          with open(output_file, 'a') as f:
              f.write(f"needs-custom-vps={'true' if needs_custom else 'false'}\n")
              f.write(f"vps-name={vps_name}\n")
              f.write(f"vps-type={vps_type}\n")
              f.write(f"project-name={project_name}\n")

          if needs_custom:
              print(f"Custom VPS required: {vps_name} ({vps_type})")
          else:
              print(f"Using shared worker: {server}")

      - name: Provision Custom VPS
        id: provision-vps
        if: steps.check-enabled.outputs.enabled == 'true' && steps.check-vps.outputs.needs-custom-vps == 'true'
        uses: ./.github-actions/actions/deploy/vps-provision
        with:
          vps-name: ${{ steps.check-vps.outputs.vps-name }}
          project-name: ${{ steps.check-vps.outputs.project-name }}
          server-type: ${{ steps.check-vps.outputs.vps-type }}
          environment: production
          hetzner-token: ${{ secrets.HETZNER_TOKEN }}
          tailscale-auth-key: ${{ secrets.TAILSCALE_AUTH_KEY }}
          tailscale-api-key: ${{ secrets.TAILSCALE_API_KEY }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          tf-api-token: ${{ secrets.TF_API_TOKEN }}
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-admin-email: ${{ secrets.DOKPLOY_ADMIN_EMAIL }}
          dokploy-admin-password: ${{ secrets.DOKPLOY_ADMIN_PASSWORD }}
          dokploy-ssh-key-id: ${{ secrets.DOKPLOY_SSH_KEY_ID }}

      - name: Sync to Dokploy
        id: sync
        if: steps.check-enabled.outputs.enabled == 'true'
        uses: ./.github-actions/actions/deploy/dokploy-sync
        with:
          config-file: ${{ inputs.config-file }}
          defaults-file: .github-actions/config/dokploy-defaults.toml
          environment: ${{ inputs.environment }}
          pr-number: ${{ inputs.pr-number }}
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-admin-email: ${{ secrets.DOKPLOY_ADMIN_EMAIL }}
          dokploy-admin-password: ${{ secrets.DOKPLOY_ADMIN_PASSWORD }}
          tailscale-api-key: ${{ secrets.TAILSCALE_API_KEY }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          hcloud-token: ${{ secrets.HETZNER_TOKEN }}
          action: ${{ inputs.action }}
          docker-image: ${{ needs.build.outputs.image }}

      - name: Configure DNS
        id: dns
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && steps.sync.outputs.success == 'true' && steps.sync.outputs.domain != '' && steps.sync.outputs.server-ip != ''
        uses: ./.github-actions/actions/infrastructure/cloudflare-dns-upsert
        with:
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          domain: ${{ steps.sync.outputs.domain }}
          content: ${{ steps.sync.outputs.server-ip }}
          proxied: 'true'

      - name: Deployment Summary
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && steps.sync.outputs.success == 'true'
        run: |
          echo "## Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ inputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ steps.sync.outputs.domain }}" ]]; then
            echo "| Domain | https://${{ steps.sync.outputs.domain }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Domain | _(not configured)_ |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| Project ID | \`${{ steps.sync.outputs.project-id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Application ID | \`${{ steps.sync.outputs.application-id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Image | \`${{ needs.build.outputs.image }}\` |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.check-vps.outputs.needs-custom-vps }}" == "true" ]]; then
            echo "| Custom VPS | \`${{ steps.check-vps.outputs.vps-name }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ -n "${{ steps.dns.outputs.action }}" ]]; then
            echo "| DNS | ${{ steps.dns.outputs.action }} (\`${{ steps.sync.outputs.server-ip }}\`) |" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Cleanup Summary
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'cleanup' && steps.sync.outputs.success == 'true'
        run: |
          echo "## Preview Cleanup Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "PR #${{ inputs.pr-number }} preview environment has been cleaned up." >> $GITHUB_STEP_SUMMARY

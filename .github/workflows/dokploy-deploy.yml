name: Dokploy Deploy

# EXTERNAL WORKFLOW - Deploy to Dokploy
# Syncs project configuration and triggers deployment
# Supports custom VPS provisioning when server = "custom" in config

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment: development, preview, production'
        required: true
        type: string
      config-file:
        description: 'Path to project dokploy.toml'
        required: false
        default: 'dokploy.toml'
        type: string
      pr-number:
        description: 'PR number (for preview deployments)'
        required: false
        default: ''
        type: string
      action:
        description: 'Action: deploy or cleanup'
        required: false
        default: 'deploy'
        type: string
      dockerfile:
        description: 'Path to Dockerfile'
        required: false
        default: 'Dockerfile'
        type: string
      build-context:
        description: 'Docker build context'
        required: false
        default: '.'
        type: string
      build-args:
        description: 'Docker build arguments (KEY=VALUE format, one per line)'
        required: false
        default: ''
        type: string
      notify-slack:
        description: 'Send Slack notification on deploy success/failure'
        required: false
        default: false
        type: boolean
      compose-file:
        description: 'Path to docker-compose.yml (skip build if provided, use compose deployment)'
        required: false
        default: ''
        type: string
    secrets:
      DOKPLOY_ADMIN_EMAIL:
        description: 'Dokploy admin email'
        required: true
      DOKPLOY_ADMIN_PASSWORD:
        description: 'Dokploy admin password'
        required: true
      TAILSCALE_OAUTH_CLIENT_ID:
        description: 'Tailscale OAuth client ID'
        required: true
      TAILSCALE_OAUTH_SECRET:
        description: 'Tailscale OAuth secret'
        required: true
      # TAILSCALE_API_KEY removed - OAuth tokens are used instead
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token'
        required: true
      # Optional: Required only for custom VPS provisioning
      HETZNER_TOKEN:
        description: 'Hetzner Cloud API token (for custom VPS)'
        required: false
      # TAILSCALE_AUTH_KEY removed - OAuth credentials are used instead
      TF_API_TOKEN:
        description: 'Terraform Cloud API token (for custom VPS)'
        required: false
      DOKPLOY_SSH_KEY_ID:
        description: 'Dokploy SSH key ID (for custom VPS)'
        required: false
      # Optional: Required for Infisical secrets management
      INFISICAL_CLIENT_ID:
        description: 'Infisical Machine Identity client ID'
        required: false
      INFISICAL_CLIENT_SECRET:
        description: 'Infisical Machine Identity client secret'
        required: false
      SLACK_WEBHOOK_URL:
        description: 'Slack webhook URL for notifications'
        required: false
    outputs:
      project-id:
        description: 'Dokploy project ID'
        value: ${{ jobs.deploy.outputs.project-id }}
      application-id:
        description: 'Dokploy application ID'
        value: ${{ jobs.deploy.outputs.application-id }}
      domain:
        description: 'Deployed domain'
        value: ${{ jobs.deploy.outputs.domain }}
      success:
        description: 'Whether deployment succeeded'
        value: ${{ jobs.deploy.outputs.success }}
      custom-vps-provisioned:
        description: 'Whether a custom VPS was provisioned'
        value: ${{ jobs.deploy.outputs.custom-vps-provisioned }}
      skipped:
        description: 'Whether deployment was skipped (environment disabled)'
        value: ${{ jobs.deploy.outputs.skipped }}
      docker-image:
        description: 'Docker image that was built and pushed'
        value: ${{ jobs.build.outputs.image }}

jobs:
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    if: inputs.action == 'deploy' && inputs.compose-file == ''
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install tomli
        shell: bash
        run: pip install tomli

      - name: Calculate Build URL
        id: url
        shell: python
        env:
          CONFIG_FILE: ${{ inputs.config-file }}
          DEFAULTS_FILE: .github-actions/config/dokploy-defaults.toml
          ENVIRONMENT: ${{ inputs.environment }}
          PR_NUMBER: ${{ inputs.pr-number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_OUTPUT: ${{ github.output }}
        run: |
          import os
          import tomli
          from pathlib import Path

          def deep_merge(base, override):
              result = base.copy()
              for key, value in override.items():
                  if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                      result[key] = deep_merge(result[key], value)
                  else:
                      result[key] = value
              return result

          config_file = os.environ.get('CONFIG_FILE', 'dokploy.toml')
          defaults_file = os.environ.get('DEFAULTS_FILE', '')
          environment = os.environ.get('ENVIRONMENT', 'production')
          pr_number = os.environ.get('PR_NUMBER', '')
          output_file = os.environ.get('GITHUB_OUTPUT', '')

          # Load defaults
          defaults = {}
          if defaults_file and Path(defaults_file).exists():
              with open(defaults_file, 'rb') as f:
                  defaults = tomli.load(f)
              print(f"Loaded defaults from: {defaults_file}")

          # Load project config
          config = {}
          if Path(config_file).exists():
              with open(config_file, 'rb') as f:
                  config = tomli.load(f)
              print(f"Loaded project config from: {config_file}")

          # Merge configs
          merged = deep_merge(defaults, config)
          base_domain = merged.get('project', {}).get('domain', '')

          # Generate URL based on environment
          url = ''
          if base_domain:
              if environment == 'production':
                  url = f"https://{base_domain}"
              elif environment == 'development':
                  url = f"https://dev.{base_domain}"
              elif environment == 'preview' and pr_number:
                  url = f"https://pr-{pr_number}.dev.{base_domain}"
              else:
                  url = f"https://{environment}.{base_domain}"
              print(f"Calculated URL: {url}")
          else:
              print("No domain configured, URL will be empty")

          with open(output_file, 'a') as f:
              f.write(f"url={url}\n")

      - name: Build and Push to Registry
        id: build
        uses: ./.github-actions/actions/build/docker-build-push
        with:
          tailscale-oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          tailscale-oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
          dockerfile: ${{ inputs.dockerfile }}
          context: ${{ inputs.build-context }}
          build-args: |
            URL=${{ steps.url.outputs.url }}
            ${{ inputs.build-args }}

  deploy:
    name: Deploy to Dokploy
    runs-on: ubuntu-latest
    needs: [build]
    if: always() && (inputs.action == 'cleanup' || inputs.compose-file != '' || needs.build.result == 'success')
    outputs:
      project-id: ${{ steps.sync.outputs.project-id }}
      application-id: ${{ steps.sync.outputs.application-id }}
      domain: ${{ steps.sync.outputs.domain }}
      success: ${{ steps.check-enabled.outputs.enabled == 'false' && 'skipped' || steps.sync.outputs.success }}
      custom-vps-provisioned: ${{ steps.check-vps.outputs.needs-custom-vps }}
      skipped: ${{ steps.check-enabled.outputs.enabled == 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install tomli
        shell: bash
        run: pip install tomli

      - name: Check Infisical Config
        id: check-infisical
        shell: python
        env:
          CONFIG_FILE: ${{ inputs.config-file }}
          DEFAULTS_FILE: .github-actions/config/dokploy-defaults.toml
        run: |
          import os
          import tomli
          from pathlib import Path

          config_file = os.environ.get('CONFIG_FILE', 'dokploy.toml')
          defaults_file = os.environ.get('DEFAULTS_FILE', '')
          output_file = os.environ.get('GITHUB_OUTPUT', '')

          def deep_merge(base, override):
              result = base.copy()
              for key, value in override.items():
                  if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                      result[key] = deep_merge(result[key], value)
                  else:
                      result[key] = value
              return result

          # Load defaults
          defaults = {}
          if defaults_file and Path(defaults_file).exists():
              with open(defaults_file, 'rb') as f:
                  defaults = tomli.load(f)

          # Load project config
          config = {}
          if Path(config_file).exists():
              with open(config_file, 'rb') as f:
                  config = tomli.load(f)

          # Merge configs
          merged = deep_merge(defaults, config)

          # Check if Infisical is enabled
          enabled = merged.get('services', {}).get('infisical', {}).get('enabled', False)

          with open(output_file, 'a') as f:
              f.write(f"enabled={'true' if enabled else 'false'}\n")

          if enabled:
              print("Infisical secrets enabled")
          else:
              print("Infisical secrets disabled (default)")

      - name: Fetch App Secrets from Infisical
        if: steps.check-infisical.outputs.enabled == 'true'
        uses: Infisical/secrets-action@v1.0.7
        with:
          method: "universal-auth"
          env-slug: ${{ inputs.environment == 'production' && 'prod' || (inputs.environment == 'preview' && 'staging' || 'dev') }}
          project-slug: ${{ github.event.repository.name }}
          client-id: ${{ secrets.INFISICAL_CLIENT_ID }}
          client-secret: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          domain: "https://secrets.nextnode.fr"

      - name: Get Dokploy URL
        id: dokploy-url
        uses: ./.github-actions/actions/infrastructure/tailscale-dokploy-url
        with:
          tailscale-oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          tailscale-oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}

      - name: Check Environment Enabled
        id: check-enabled
        shell: python
        env:
          CONFIG_FILE: ${{ inputs.config-file }}
          DEFAULTS_FILE: .github-actions/config/dokploy-defaults.toml
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          import os
          import tomli
          from pathlib import Path

          config_file = os.environ.get('CONFIG_FILE', 'dokploy.toml')
          defaults_file = os.environ.get('DEFAULTS_FILE', '')
          environment = os.environ.get('ENVIRONMENT', 'production')
          output_file = os.environ.get('GITHUB_OUTPUT', '')

          def deep_merge(base, override):
              result = base.copy()
              for key, value in override.items():
                  if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                      result[key] = deep_merge(result[key], value)
                  else:
                      result[key] = value
              return result

          # Load defaults
          defaults = {}
          if defaults_file and Path(defaults_file).exists():
              with open(defaults_file, 'rb') as f:
                  defaults = tomli.load(f)

          # Load project config
          config = {}
          if Path(config_file).exists():
              with open(config_file, 'rb') as f:
                  config = tomli.load(f)

          # Merge configs
          merged = deep_merge(defaults, config)

          # Check if environment is enabled (production is always enabled)
          enabled = True
          if environment != 'production':
              env_config = merged.get('environments', {}).get(environment, {})
              enabled = env_config.get('enabled', True)

          with open(output_file, 'a') as f:
              f.write(f"enabled={'true' if enabled else 'false'}\n")

          if enabled:
              print(f"Environment '{environment}' is enabled")
          else:
              print(f"::notice::Environment '{environment}' is disabled in config, skipping deployment")

      - name: Skip Disabled Environment
        if: steps.check-enabled.outputs.enabled == 'false'
        run: |
          echo "## Deployment Skipped" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Environment \`${{ inputs.environment }}\` is disabled in \`dokploy.toml\`." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enable, set:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`toml" >> $GITHUB_STEP_SUMMARY
          echo "[environments.${{ inputs.environment }}]" >> $GITHUB_STEP_SUMMARY
          echo "enabled = true" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Check for Custom VPS
        id: check-vps
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && inputs.environment == 'production'
        shell: python
        env:
          CONFIG_FILE: ${{ inputs.config-file }}
          DEFAULTS_FILE: .github-actions/config/dokploy-defaults.toml
        run: |
          import os
          import tomli
          from pathlib import Path

          config_file = os.environ.get('CONFIG_FILE', 'dokploy.toml')
          defaults_file = os.environ.get('DEFAULTS_FILE', '')
          output_file = os.environ.get('GITHUB_OUTPUT', '')

          # Load and merge configs
          defaults = {}
          if defaults_file and Path(defaults_file).exists():
              with open(defaults_file, 'rb') as f:
                  defaults = tomli.load(f)

          config = {}
          if Path(config_file).exists():
              with open(config_file, 'rb') as f:
                  config = tomli.load(f)

          # Check production config for custom server
          prod_config = config.get('environments', {}).get('production', {})
          server = prod_config.get('server', 'prod-worker')
          vps_name = prod_config.get('vps', '')
          vps_type = prod_config.get('vps_type', 'cx33')
          project_name = config.get('project', {}).get('name', '')

          needs_custom = server == 'custom' and vps_name

          with open(output_file, 'a') as f:
              f.write(f"needs-custom-vps={'true' if needs_custom else 'false'}\n")
              f.write(f"vps-name={vps_name}\n")
              f.write(f"vps-type={vps_type}\n")
              f.write(f"project-name={project_name}\n")

          if needs_custom:
              print(f"Custom VPS required: {vps_name} ({vps_type})")
          else:
              print(f"Using shared worker: {server}")

      - name: Get VPS Provisioning Credentials
        id: vps-tailscale
        if: steps.check-enabled.outputs.enabled == 'true' && steps.check-vps.outputs.needs-custom-vps == 'true'
        uses: ./.github-actions/actions/infrastructure/tailscale-oauth
        with:
          oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
          generate-auth-key: 'true'
          auth-key-tags: 'tag:server'
          auth-key-expiry: '3600'

      - name: Provision Custom VPS
        id: provision-vps
        if: steps.check-enabled.outputs.enabled == 'true' && steps.check-vps.outputs.needs-custom-vps == 'true'
        uses: ./.github-actions/actions/deploy/vps-provision
        with:
          vps-name: ${{ steps.check-vps.outputs.vps-name }}
          project-name: ${{ steps.check-vps.outputs.project-name }}
          server-type: ${{ steps.check-vps.outputs.vps-type }}
          environment: production
          hetzner-token: ${{ secrets.HETZNER_TOKEN }}
          tailscale-auth-key: ${{ steps.vps-tailscale.outputs.auth-key }}
          tailscale-api-token: ${{ steps.vps-tailscale.outputs.api-token }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          tf-api-token: ${{ secrets.TF_API_TOKEN }}
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-admin-email: ${{ secrets.DOKPLOY_ADMIN_EMAIL }}
          dokploy-admin-password: ${{ secrets.DOKPLOY_ADMIN_PASSWORD }}
          dokploy-ssh-key-id: ${{ secrets.DOKPLOY_SSH_KEY_ID }}

      - name: Get Tailscale API Token
        id: tailscale-api
        if: steps.check-enabled.outputs.enabled == 'true'
        uses: ./.github-actions/actions/infrastructure/tailscale-oauth
        with:
          oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}

      - name: Sync to Dokploy
        id: sync
        if: steps.check-enabled.outputs.enabled == 'true'
        uses: ./.github-actions/actions/deploy/dokploy-sync
        with:
          config-file: ${{ inputs.config-file }}
          defaults-file: .github-actions/config/dokploy-defaults.toml
          environment: ${{ inputs.environment }}
          pr-number: ${{ inputs.pr-number }}
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-admin-email: ${{ secrets.DOKPLOY_ADMIN_EMAIL }}
          dokploy-admin-password: ${{ secrets.DOKPLOY_ADMIN_PASSWORD }}
          tailscale-api-token: ${{ steps.tailscale-api.outputs.api-token }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          hcloud-token: ${{ secrets.HETZNER_TOKEN }}
          action: ${{ inputs.action }}
          docker-image: ${{ needs.build.outputs.image }}
          compose-file: ${{ inputs.compose-file }}

      - name: Detect Sub-subdomain
        id: detect-subdomain
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && steps.sync.outputs.success == 'true' && steps.sync.outputs.domain != ''
        shell: bash
        run: |
          DOMAIN="${{ steps.sync.outputs.domain }}"
          # Count dots in domain: 1 dot = apex (example.com), 2+ dots = subdomain/sub-subdomain
          DOT_COUNT=$(echo "$DOMAIN" | tr -cd '.' | wc -c)

          # Sub-subdomains (3+ levels like pr-5.dev.ya6ou.com) cannot use Cloudflare proxy
          # because free SSL only covers *.domain.com, not *.subdomain.domain.com
          if [[ $DOT_COUNT -ge 2 ]]; then
            echo "Domain '$DOMAIN' is a sub-subdomain ($DOT_COUNT dots), disabling Cloudflare proxy"
            echo "proxied=false" >> $GITHUB_OUTPUT
          else
            echo "Domain '$DOMAIN' is a standard domain ($DOT_COUNT dots), enabling Cloudflare proxy"
            echo "proxied=true" >> $GITHUB_OUTPUT
          fi

      - name: Configure DNS
        id: dns
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && steps.sync.outputs.success == 'true' && steps.sync.outputs.domain != '' && steps.sync.outputs.server-ip != ''
        uses: ./.github-actions/actions/infrastructure/cloudflare-dns-upsert
        with:
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          domain: ${{ steps.sync.outputs.domain }}
          content: ${{ steps.sync.outputs.server-ip }}
          proxied: ${{ steps.detect-subdomain.outputs.proxied || 'true' }}

      - name: Configure Cross-Swarm Routing
        id: cross-swarm
        if: |
          steps.check-enabled.outputs.enabled == 'true' &&
          inputs.action == 'deploy' &&
          steps.sync.outputs.success == 'true' &&
          steps.sync.outputs.cross-swarm == 'true' &&
          steps.sync.outputs.worker-tailscale-ip != ''
        uses: ./.github-actions/actions/deploy/cross-swarm-routing
        with:
          app-name: ${{ steps.sync.outputs.application-name }}
          domain: ${{ steps.sync.outputs.domain }}
          worker-tailscale-ip: ${{ steps.sync.outputs.worker-tailscale-ip }}
          admin-tailscale-ip: ${{ steps.dokploy-url.outputs.ip }}
          container-port: ${{ steps.sync.outputs.container-port }}
          use-https: 'true'
          expected-image: ${{ needs.build.outputs.image }}

      - name: Deployment Summary
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'deploy' && steps.sync.outputs.success == 'true'
        run: |
          echo "## Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ inputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ steps.sync.outputs.domain }}" ]]; then
            echo "| Domain | https://${{ steps.sync.outputs.domain }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Domain | _(not configured)_ |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| Project ID | \`${{ steps.sync.outputs.project-id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Application ID | \`${{ steps.sync.outputs.application-id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Image | \`${{ needs.build.outputs.image }}\` |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.check-vps.outputs.needs-custom-vps }}" == "true" ]]; then
            echo "| Custom VPS | \`${{ steps.check-vps.outputs.vps-name }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ -n "${{ steps.dns.outputs.action }}" ]]; then
            PROXY_STATUS="${{ steps.detect-subdomain.outputs.proxied }}"
            if [[ "$PROXY_STATUS" == "false" ]]; then
              echo "| DNS | ${{ steps.dns.outputs.action }} (\`${{ steps.sync.outputs.server-ip }}\`, DNS-only) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| DNS | ${{ steps.dns.outputs.action }} (\`${{ steps.sync.outputs.server-ip }}\`, proxied) |" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          if [[ "${{ steps.sync.outputs.cross-swarm }}" == "true" ]]; then
            echo "| Cross-Swarm | Traefik â†’ \`${{ steps.sync.outputs.worker-tailscale-ip }}:${{ steps.cross-swarm.outputs.external-port }}\` |" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Cleanup Summary
        if: steps.check-enabled.outputs.enabled == 'true' && inputs.action == 'cleanup' && steps.sync.outputs.success == 'true'
        run: |
          echo "## Preview Cleanup Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "PR #${{ inputs.pr-number }} preview environment has been cleaned up." >> $GITHUB_STEP_SUMMARY

  notify:
    name: Slack Notification
    needs: [deploy]
    if: inputs.notify-slack && always()
    runs-on: ubuntu-latest
    steps:
      - name: Notify Slack
        uses: slackapi/slack-github-action@v2
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "${{ needs.deploy.result == 'success' && 'Deployed' || 'Failed' }}: ${{ inputs.environment }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*${{ inputs.environment }} deployment ${{ needs.deploy.result }}*\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow>"
                  }
                }
              ]
            }

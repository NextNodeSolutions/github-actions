name: App Deploy

# EXTERNAL WORKFLOW - Deploy application to Dokploy
# Composes atomic actions for configuration, build, and deployment
# Supports both application and compose deployments

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment: development, preview, production'
        required: true
        type: string
      config-file:
        description: 'Path to project dokploy.toml'
        required: false
        default: 'dokploy.toml'
        type: string
      pr-number:
        description: 'PR number (for preview deployments)'
        required: false
        default: ''
        type: string
      action:
        description: 'Action: deploy or cleanup'
        required: false
        default: 'deploy'
        type: string
      dockerfile:
        description: 'Path to Dockerfile'
        required: false
        default: 'Dockerfile'
        type: string
      build-context:
        description: 'Docker build context'
        required: false
        default: '.'
        type: string
      build-args:
        description: 'Docker build arguments (KEY=VALUE format, one per line)'
        required: false
        default: ''
        type: string
      compose-file:
        description: 'Path to docker-compose.yml (skip build if provided)'
        required: false
        default: ''
        type: string
      create-tag:
        description: 'Tag to create after successful production deployment (e.g., v1.2.3)'
        required: false
        default: ''
        type: string
    secrets:
      compose-env:
        description: 'Environment variables for compose deployments (newline-separated KEY=VALUE, e.g., "DB_HOST=localhost\nDB_PORT=5432")'
        required: false
      TAILSCALE_OAUTH_CLIENT_ID:
        description: 'Tailscale OAuth client ID'
        required: true
      TAILSCALE_OAUTH_SECRET:
        description: 'Tailscale OAuth client secret'
        required: true
      DOKPLOY_API_TOKEN:
        description: 'Dokploy API token (from Settings > Profile > API/CLI)'
        required: true
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token for DNS management'
        required: false
      HETZNER_TOKEN:
        description: 'Hetzner Cloud API token for VPS provisioning'
        required: false
      TF_API_TOKEN:
        description: 'Terraform Cloud API token'
        required: false
      NEXTNODE_APP_ID:
        description: 'GitHub App ID for cross-repo operations'
        required: false
      NEXTNODE_APP_PRIVATE_KEY:
        description: 'GitHub App private key'
        required: false
      SLACK_WEBHOOK_URL:
        description: 'Slack incoming webhook URL for deployment notifications'
        required: false
      ORCHESTRATION_SECRET:
        description: 'Orchestration secret for worker registration'
        required: false
    outputs:
      project-id:
        description: 'Dokploy project ID'
        value: ${{ jobs.deploy.outputs.project-id }}
      application-id:
        description: 'Dokploy application ID'
        value: ${{ jobs.deploy.outputs.application-id }}
      compose-id:
        description: 'Dokploy compose ID'
        value: ${{ jobs.deploy.outputs.compose-id }}
      domain:
        description: 'Deployed domain'
        value: ${{ jobs.deploy.outputs.domain }}
      success:
        description: 'Whether deployment succeeded'
        value: ${{ jobs.deploy.outputs.success }}
      docker-image:
        description: 'Docker image that was built'
        value: ${{ jobs.build.outputs.image }}
      tag-created:
        description: 'Tag that was created (if any)'
        value: ${{ jobs.deploy.outputs.tag-created }}

jobs:
  # ==========================================================================
  # CONFIGURATION
  # ==========================================================================
  config:
    name: Load Configuration
    runs-on: ubuntu-latest
    outputs:
      project-name: ${{ steps.config.outputs.project-name }}
      domain: ${{ steps.config.outputs.domain }}
      url: ${{ steps.config.outputs.url }}
      app-name: ${{ steps.config.outputs.app-name }}
      server: ${{ steps.config.outputs.server }}
      port: ${{ steps.config.outputs.port }}
      is-compose: ${{ steps.config.outputs.is-compose }}
      compose-file: ${{ steps.config.outputs.compose-file }}
      compose-mounts: ${{ steps.config.outputs.compose-mounts }}
      service-name: ${{ steps.config.outputs.service-name }}
      traefik-server: ${{ steps.config.outputs.traefik-server }}
      environment-enabled: ${{ steps.config.outputs.environment-enabled }}
      vps-enabled: ${{ steps.config.outputs.vps-enabled }}
      vps-name: ${{ steps.config.outputs.vps-name }}
      vps-type: ${{ steps.config.outputs.vps-type }}
      vps-location: ${{ steps.config.outputs.vps-location }}
      vps-has-volume: ${{ steps.config.outputs.vps-has-volume }}
      vps-volume-size: ${{ steps.config.outputs.vps-volume-size }}
      exposure: ${{ steps.config.outputs.exposure }}
      slack-enabled: ${{ steps.check-slack.outputs.enabled }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Load Configuration
        id: config
        uses: ./.github-actions/actions/app/config-load
        with:
          config-file: ${{ inputs.config-file }}
          defaults-file: .github-actions/config/dokploy-defaults.toml
          environment: ${{ inputs.environment }}
          pr-number: ${{ inputs.pr-number }}

      - name: Check Slack Configuration
        id: check-slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
            echo "enabled=true" >> $GITHUB_OUTPUT
          else
            echo "enabled=false" >> $GITHUB_OUTPUT
          fi

  # ==========================================================================
  # DEPLOYMENT STARTED NOTIFICATION (before build)
  # ==========================================================================
  notify-started:
    name: Notify Deployment Started
    runs-on: ubuntu-latest
    needs: [config]
    if: |
      inputs.action == 'deploy' &&
      needs.config.outputs.environment-enabled == 'true' &&
      needs.config.outputs.slack-enabled == 'true'
    steps:
      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Send Started Notification
        uses: ./.github-actions/actions/notifications/slack-deploy
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          status: started
          project-name: ${{ needs.config.outputs.project-name }}
          environment: ${{ inputs.environment }}
          domain: ${{ needs.config.outputs.domain }}
          url: ${{ needs.config.outputs.url }}
          pr-number: ${{ inputs.pr-number }}

  # ==========================================================================
  # BUILD (skip for compose or cleanup)
  # ==========================================================================
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [config, notify-started]
    if: |
      always() &&
      inputs.action == 'deploy' &&
      needs.config.outputs.environment-enabled == 'true' &&
      needs.config.outputs.is-compose == 'false' &&
      inputs.compose-file == '' &&
      (needs.notify-started.result == 'success' || needs.notify-started.result == 'skipped')
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Build and Push to Registry
        id: build
        uses: ./.github-actions/actions/build/docker-build-push
        with:
          tailscale-oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          tailscale-oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
          dockerfile: ${{ inputs.dockerfile }}
          context: ${{ inputs.build-context }}
          build-args: |
            URL=${{ needs.config.outputs.url }}
            ${{ inputs.build-args }}

  # ==========================================================================
  # APPROVAL NOTIFICATION (production only)
  # ==========================================================================
  notify-approval-pending:
    name: Notify Approval Pending
    runs-on: ubuntu-latest
    needs: [config, build]
    if: |
      inputs.action == 'deploy' &&
      inputs.environment == 'production' &&
      needs.config.outputs.environment-enabled == 'true' &&
      (needs.build.result == 'success' || needs.build.result == 'skipped') &&
      needs.config.outputs.slack-enabled == 'true'
    steps:
      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Send Approval Pending Notification
        uses: ./.github-actions/actions/notifications/slack-deploy
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          status: pending-approval
          project-name: ${{ needs.config.outputs.project-name }}
          environment: ${{ inputs.environment }}
          domain: ${{ needs.config.outputs.domain }}
          url: ${{ needs.config.outputs.url }}
          docker-image: ${{ needs.build.outputs.image }}
          create-tag: ${{ inputs.create-tag }}

  # ==========================================================================
  # VPS PROVISIONING (if needed)
  # ==========================================================================
  provision:
    name: Provision VPS
    runs-on: ubuntu-latest
    needs: [config]
    if: |
      inputs.action == 'deploy' &&
      needs.config.outputs.environment-enabled == 'true' &&
      needs.config.outputs.vps-enabled == 'true' &&
      inputs.environment == 'production'
    outputs:
      server-ip: ${{ steps.provision.outputs.server-ip }}
      tailscale-ip: ${{ steps.provision.outputs.tailscale-ip }}
      server-id: ${{ steps.provision.outputs.server-id }}
      provisioned: ${{ steps.provision.outputs.provisioned }}
      success: ${{ steps.provision.outputs.success }}
    steps:
      - name: Validate VPS Secrets
        shell: bash
        env:
          HETZNER_TOKEN: ${{ secrets.HETZNER_TOKEN }}
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          NEXTNODE_APP_ID: ${{ secrets.NEXTNODE_APP_ID }}
          NEXTNODE_APP_PRIVATE_KEY: ${{ secrets.NEXTNODE_APP_PRIVATE_KEY }}
        run: |
          MISSING=""
          [[ -z "$HETZNER_TOKEN" ]] && MISSING="$MISSING HETZNER_TOKEN"
          [[ -z "$TF_API_TOKEN" ]] && MISSING="$MISSING TF_API_TOKEN"
          [[ -z "$NEXTNODE_APP_ID" ]] && MISSING="$MISSING NEXTNODE_APP_ID"
          [[ -z "$NEXTNODE_APP_PRIVATE_KEY" ]] && MISSING="$MISSING NEXTNODE_APP_PRIVATE_KEY"
          if [[ -n "$MISSING" ]]; then
            echo "::error::Missing required secrets for VPS provisioning:$MISSING"
            exit 1
          fi
          echo "All required VPS secrets are present"

      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Get Dokploy URL
        id: dokploy-url
        uses: ./.github-actions/actions/infrastructure/tailscale-dokploy-url
        with:
          tailscale-oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          tailscale-oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}

      - name: Get Tailscale Auth Key
        id: tailscale
        uses: ./.github-actions/actions/infrastructure/tailscale-oauth
        with:
          oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
          generate-auth-key: 'true'
          auth-key-tags: 'tag:server'
          auth-key-expiry: '7200'

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.NEXTNODE_APP_ID }}
          private-key: ${{ secrets.NEXTNODE_APP_PRIVATE_KEY }}
          owner: nextnodesolutions
          repositories: infrastructure

      - name: Cleanup Stale Tailscale Device
        uses: ./.github-actions/actions/infrastructure/tailscale-device-cleanup
        with:
          tailscale-api-token: ${{ steps.tailscale.outputs.api-token }}
          target: ${{ needs.config.outputs.vps-name }}
        continue-on-error: true

      - name: Provision Custom VPS
        id: provision
        uses: ./.github-actions/actions/deploy/vps-provision
        with:
          vps-name: ${{ needs.config.outputs.vps-name }}
          project-name: ${{ needs.config.outputs.project-name }}
          server-type: ${{ needs.config.outputs.vps-type }}
          location: ${{ needs.config.outputs.vps-location }}
          environment: production
          hetzner-token: ${{ secrets.HETZNER_TOKEN }}
          tailscale-auth-key: ${{ steps.tailscale.outputs.auth-key }}
          tailscale-api-token: ${{ steps.tailscale.outputs.api-token }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          tf-api-token: ${{ secrets.TF_API_TOKEN }}
          github-token: ${{ steps.app-token.outputs.token }}
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-api-token: ${{ secrets.DOKPLOY_API_TOKEN }}
          orchestration-secret: ${{ secrets.ORCHESTRATION_SECRET }}
          has-volume: ${{ needs.config.outputs.vps-has-volume }}
          volume-size: ${{ needs.config.outputs.vps-volume-size }}

  # ==========================================================================
  # DEPLOY
  # ==========================================================================
  deploy:
    name: Deploy to Dokploy
    runs-on: ubuntu-latest
    needs: [config, build, provision, notify-approval-pending]
    # Use environment gate for production deployments (enables approval workflow)
    environment: ${{ inputs.environment == 'production' && inputs.action == 'deploy' && 'production' || '' }}
    if: always() && needs.config.outputs.environment-enabled == 'true' && (inputs.action == 'cleanup' || needs.build.result == 'success' || needs.build.result == 'skipped')
    outputs:
      project-id: ${{ steps.project.outputs.project-id }}
      application-id: ${{ steps.app.outputs.application-id }}
      compose-id: ${{ steps.compose.outputs.compose-id }}
      domain: ${{ needs.config.outputs.domain }}
      success: ${{ steps.final.outputs.success }}
      tag-created: ${{ steps.tag.outputs.tag }}
      cleanup-deleted: ${{ steps.cleanup.outputs.deleted }}
    steps:
      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Get Dokploy URL
        id: dokploy-url
        uses: ./.github-actions/actions/infrastructure/tailscale-dokploy-url
        with:
          tailscale-oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          tailscale-oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}

      - name: Authenticate with Dokploy
        id: auth
        uses: ./.github-actions/actions/app/dokploy-auth
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-api-token: ${{ secrets.DOKPLOY_API_TOKEN }}

      # ---------- CLEANUP ----------
      - name: Cleanup Preview
        id: cleanup
        if: inputs.action == 'cleanup'
        uses: ./.github-actions/actions/app/dokploy-cleanup
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          project-name: ${{ needs.config.outputs.project-name }}
          pr-number: ${{ inputs.pr-number }}
          is-compose: ${{ needs.config.outputs.is-compose }}

      # ---------- DEPLOY ----------
      - name: Sync Project
        id: project
        if: inputs.action == 'deploy'
        uses: ./.github-actions/actions/app/dokploy-project-sync
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          project-name: ${{ needs.config.outputs.project-name }}

      - name: Sync Environment
        id: environment
        if: inputs.action == 'deploy'
        uses: ./.github-actions/actions/app/dokploy-environment-sync
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          project-id: ${{ steps.project.outputs.project-id }}
          environment: ${{ inputs.environment }}
          pr-number: ${{ inputs.pr-number }}

      - name: Get Tailscale API Token
        id: tailscale
        if: inputs.action == 'deploy'
        uses: ./.github-actions/actions/infrastructure/tailscale-oauth
        with:
          oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}

      - name: Resolve Server
        id: server
        if: inputs.action == 'deploy'
        uses: ./.github-actions/actions/app/server-resolve
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          server-name: ${{ needs.config.outputs.server }}
          traefik-server: ${{ needs.config.outputs.traefik-server }}
          exposure: ${{ needs.config.outputs.exposure }}
          hcloud-token: ${{ secrets.HETZNER_TOKEN }}
          tailscale-api-token: ${{ steps.tailscale.outputs.api-token }}
          server-id-override: ${{ needs.provision.outputs.server-id }}
          server-tailscale-ip-override: ${{ needs.provision.outputs.tailscale-ip }}

      # Deploy application (if not compose)
      - name: Sync Application
        id: app
        if: inputs.action == 'deploy' && needs.config.outputs.is-compose == 'false' && inputs.compose-file == ''
        uses: ./.github-actions/actions/app/dokploy-app-sync
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          project-id: ${{ steps.project.outputs.project-id }}
          environment-id: ${{ steps.environment.outputs.environment-id }}
          app-name: ${{ needs.config.outputs.app-name }}
          server-id: ${{ steps.server.outputs.server-id }}
          docker-image: ${{ needs.build.outputs.image }}
          domain: ${{ needs.config.outputs.domain }}
          port: ${{ needs.config.outputs.port }}

      # Checkout project repo for compose file (if compose mode)
      - name: Checkout Project
        if: inputs.action == 'deploy' && (needs.config.outputs.is-compose == 'true' || inputs.compose-file != '')
        uses: actions/checkout@v4
        with:
          path: project

      # Deploy compose (if compose mode)
      - name: Sync Compose
        id: compose
        if: inputs.action == 'deploy' && (needs.config.outputs.is-compose == 'true' || inputs.compose-file != '')
        uses: ./.github-actions/actions/app/dokploy-compose-sync
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          project-id: ${{ steps.project.outputs.project-id }}
          environment-id: ${{ steps.environment.outputs.environment-id }}
          app-name: ${{ needs.config.outputs.app-name }}
          server-id: ${{ steps.server.outputs.server-id }}
          compose-file: project/${{ inputs.compose-file || needs.config.outputs.compose-file }}
          env: ${{ secrets.compose-env }}
          mounts: ${{ needs.config.outputs.compose-mounts }}

      # Configure domain for compose (if domain and service-name provided)
      - name: Configure Compose Domain
        if: |
          inputs.action == 'deploy' &&
          (needs.config.outputs.is-compose == 'true' || inputs.compose-file != '') &&
          needs.config.outputs.domain != '' &&
          needs.config.outputs.service-name != ''
        uses: ./.github-actions/actions/app/dokploy-domain-config
        with:
          dokploy-url: ${{ steps.dokploy-url.outputs.url }}
          dokploy-token: ${{ steps.auth.outputs.token }}
          compose-id: ${{ steps.compose.outputs.compose-id }}
          domain: ${{ needs.config.outputs.domain }}
          port: ${{ needs.config.outputs.port }}
          service-name: ${{ needs.config.outputs.service-name }}

      # SSL Strategy Determination
      - name: Determine SSL Strategy
        id: ssl-strategy
        if: |
          inputs.action == 'deploy' &&
          needs.config.outputs.domain != ''
        uses: ./.github-actions/actions/ssl/ssl-strategy
        with:
          domain: ${{ needs.config.outputs.domain }}

      # File-based Traefik routing for compose (NixOS servers with file provider)
      - name: Configure Compose Traefik Routing
        if: |
          inputs.action == 'deploy' &&
          (needs.config.outputs.is-compose == 'true' || inputs.compose-file != '') &&
          needs.config.outputs.domain != '' &&
          steps.server.outputs.traefik-tailscale-ip != ''
        uses: ./.github-actions/actions/deploy/compose-traefik-routing
        with:
          compose-name: ${{ needs.config.outputs.app-name }}
          domain: ${{ needs.config.outputs.domain }}
          service-port: ${{ needs.config.outputs.port }}
          server-tailscale-ip: ${{ steps.server.outputs.server-tailscale-ip }}
          traefik-tailscale-ip: ${{ steps.server.outputs.traefik-tailscale-ip }}
          same-server: ${{ needs.config.outputs.server == needs.config.outputs.traefik-server }}
          use-https: ${{ steps.ssl-strategy.outputs.use_https }}

      # DNS Configuration (only if app or compose deployment succeeded)
      - name: Configure DNS
        id: dns
        if: |
          inputs.action == 'deploy' &&
          needs.config.outputs.domain != '' &&
          steps.server.outputs.dns-ip != '' &&
          (steps.app.outputs.success == 'true' || steps.compose.outputs.success == 'true')
        uses: ./.github-actions/actions/infrastructure/cloudflare-dns-upsert
        with:
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          domain: ${{ needs.config.outputs.domain }}
          content: ${{ steps.server.outputs.dns-ip }}
          proxied: ${{ needs.config.outputs.exposure == 'external' && !contains(needs.config.outputs.domain, '.dev.') }}

      # Wildcard Certificate Configuration (skip for HTTP-only environments like previews)
      - name: Configure Wildcard Certificate
        id: wildcard
        if: |
          inputs.action == 'deploy' &&
          needs.config.outputs.domain != '' &&
          steps.server.outputs.traefik-tailscale-ip != '' &&
          steps.ssl-strategy.outputs.ssl_type != 'http_only' &&
          (steps.app.outputs.success == 'true' || steps.compose.outputs.success == 'true')
        uses: ./.github-actions/actions/ssl/traefik-wildcard-config
        with:
          domain: ${{ needs.config.outputs.domain }}
          router-name: ${{ needs.config.outputs.app-name }}
          traefik-server-ip: ${{ steps.server.outputs.traefik-tailscale-ip }}
          container-port: ${{ needs.config.outputs.port }}

      - name: Set Final Status
        id: final
        if: always()
        run: |
          if [[ "${{ inputs.action }}" == "cleanup" ]]; then
            # Cleanup success is determined by cleanup step
            echo "success=${{ steps.cleanup.outputs.success }}" >> $GITHUB_OUTPUT
          else
            # Deploy success requires app or compose step to have actually succeeded
            APP_SUCCESS="${{ steps.app.outputs.success }}"
            COMPOSE_SUCCESS="${{ steps.compose.outputs.success }}"

            if [[ "$APP_SUCCESS" == "true" || "$COMPOSE_SUCCESS" == "true" ]]; then
              echo "success=true" >> $GITHUB_OUTPUT
            else
              echo "success=false" >> $GITHUB_OUTPUT
            fi
          fi

      # ---------- TAG CREATION (production only) ----------
      - name: Checkout Project for Tag
        if: |
          inputs.action == 'deploy' &&
          inputs.environment == 'production' &&
          inputs.create-tag != '' &&
          steps.final.outputs.success == 'true'
        uses: actions/checkout@v4
        with:
          path: project-tag
          fetch-depth: 0

      - name: Create Tag
        id: tag
        if: |
          inputs.action == 'deploy' &&
          inputs.environment == 'production' &&
          inputs.create-tag != '' &&
          steps.final.outputs.success == 'true'
        working-directory: project-tag
        run: |
          echo "::group::Create tag"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ inputs.create-tag }}" -m "Release ${{ inputs.create-tag }}"
          git push origin "${{ inputs.create-tag }}"
          echo "tag=${{ inputs.create-tag }}" >> $GITHUB_OUTPUT
          echo "Created and pushed tag: ${{ inputs.create-tag }}"
          echo "::endgroup::"

      - name: Deployment Summary
        if: inputs.action == 'deploy' && steps.final.outputs.success == 'true'
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          DOMAIN: ${{ needs.config.outputs.domain }}
          PROJECT_NAME: ${{ needs.config.outputs.project-name }}
          DOCKER_IMAGE: ${{ needs.build.outputs.image }}
          SSL_TYPE: ${{ steps.ssl-strategy.outputs.ssl_type }}
          WILDCARD_DOMAIN: ${{ steps.ssl-strategy.outputs.wildcard_domain }}
          USE_HTTPS: ${{ steps.ssl-strategy.outputs.use_https }}
          SSL_WARNINGS: ${{ steps.ssl-strategy.outputs.warnings }}
        run: |
          echo "## Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`$ENVIRONMENT\` |" >> $GITHUB_STEP_SUMMARY
          if [[ -n "$DOMAIN" ]]; then
            if [[ "$USE_HTTPS" == "true" ]]; then
              echo "| Domain | https://$DOMAIN |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Domain | http://$DOMAIN |" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          echo "| Project | \`$PROJECT_NAME\` |" >> $GITHUB_STEP_SUMMARY
          if [[ -n "$DOCKER_IMAGE" ]]; then
            echo "| Image | \`$DOCKER_IMAGE\` |" >> $GITHUB_STEP_SUMMARY
          fi

          # SSL Configuration status
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### SSL Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          case "$SSL_TYPE" in
            wildcard)
              echo "| SSL | Wildcard (\`$WILDCARD_DOMAIN\`) |" >> $GITHUB_STEP_SUMMARY
              ;;
            new_wildcard)
              echo "| SSL | New Wildcard (DNS-01 challenge) |" >> $GITHUB_STEP_SUMMARY
              ;;
            http_only)
              echo "| SSL | HTTP Only (preview environment) |" >> $GITHUB_STEP_SUMMARY
              echo "::warning::SSL: Preview environment runs HTTP-only to avoid Let's Encrypt rate limits"
              ;;
            auto_cert)
              echo "| SSL | Auto-cert (sub-subdomain not covered by wildcard) |" >> $GITHUB_STEP_SUMMARY
              echo "::warning::SSL: Using per-host certificate - consider restructuring domain"
              ;;
          esac

          # Output any warnings from SSL strategy
          if [[ -n "$SSL_WARNINGS" && "$SSL_WARNINGS" != "[]" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**SSL Warnings:**" >> $GITHUB_STEP_SUMMARY
            echo "$SSL_WARNINGS" | jq -r '.[]' 2>/dev/null | while read -r warning; do
              echo "- $warning" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: Cleanup Summary
        if: inputs.action == 'cleanup'
        run: |
          echo "## Preview Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.cleanup.outputs.deleted }}" == "true" ]]; then
            echo "PR #${{ inputs.pr-number }} preview environment has been cleaned up." >> $GITHUB_STEP_SUMMARY
          else
            echo "No preview environment found for PR #${{ inputs.pr-number }}." >> $GITHUB_STEP_SUMMARY
          fi

  # ==========================================================================
  # RESULT NOTIFICATION
  # ==========================================================================
  notify-result:
    name: Notify Deployment Result
    runs-on: ubuntu-latest
    needs: [config, build, deploy]
    if: |
      always() &&
      needs.config.outputs.slack-enabled == 'true'
    steps:
      - name: Checkout Shared Actions
        uses: actions/checkout@v4
        with:
          repository: nextnodesolutions/github-actions
          path: .github-actions

      - name: Notify Deployment Success
        if: |
          inputs.action == 'deploy' &&
          needs.deploy.outputs.success == 'true'
        uses: ./.github-actions/actions/notifications/slack-deploy
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          status: success
          project-name: ${{ needs.config.outputs.project-name }}
          environment: ${{ inputs.environment }}
          domain: ${{ needs.config.outputs.domain }}
          url: ${{ needs.config.outputs.url }}
          docker-image: ${{ needs.build.outputs.image }}
          create-tag: ${{ needs.deploy.outputs.tag-created }}
          pr-number: ${{ inputs.pr-number }}

      - name: Notify Deployment Failure
        if: |
          inputs.action == 'deploy' &&
          needs.deploy.outputs.success != 'true'
        uses: ./.github-actions/actions/notifications/slack-deploy
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          status: failure
          project-name: ${{ needs.config.outputs.project-name }}
          environment: ${{ inputs.environment }}
          domain: ${{ needs.config.outputs.domain }}
          pr-number: ${{ inputs.pr-number }}

      - name: Notify Cleanup Complete
        if: inputs.action == 'cleanup'
        uses: ./.github-actions/actions/notifications/slack-deploy
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          status: cleanup
          project-name: ${{ needs.config.outputs.project-name }}
          environment: preview
          pr-number: ${{ inputs.pr-number }}
          cleanup-deleted: ${{ needs.deploy.outputs.cleanup-deleted }}

name: Railway GraphQL - Deploy Service

# ATOMIC WORKFLOW - Deploy Railway service via GraphQL API
# Creates or updates service with variables, custom domain, and monitors deployment

on:
  workflow_call:
    inputs:
      project-id:
        description: 'Railway project ID'
        required: true
        type: string
      environment-id:
        description: 'Railway environment ID'
        required: true
        type: string
      service-id:
        description: 'Existing service ID (optional - will create if empty)'
        required: false
        type: string
        default: ''
      service-name:
        description: 'Service name'
        required: true
        type: string
      repository:
        description: 'GitHub repository (owner/repo format)'
        required: true
        type: string
      branch:
        description: 'Git branch to deploy'
        required: true
        type: string
      commit-sha:
        description: 'Git commit SHA to deploy'
        required: true
        type: string
      custom-domain:
        description: 'Custom domain (optional)'
        required: false
        type: string
        default: ''
      variables-json:
        description: 'Environment variables as JSON object'
        required: true
        type: string
      timeout-seconds:
        description: 'Deployment timeout in seconds'
        required: false
        type: number
        default: 300
    secrets:
      railway-token:
        required: true
    outputs:
      service-id:
        description: 'Railway service ID'
        value: ${{ jobs.deploy.outputs.service-id }}
      deployment-id:
        description: 'Railway deployment ID'
        value: ${{ jobs.deploy.outputs.deployment-id }}
      deployment-status:
        description: 'Deployment status (SUCCESS/FAILED)'
        value: ${{ jobs.deploy.outputs.deployment-status }}
      deployment-url:
        description: 'Service deployment URL'
        value: ${{ jobs.deploy.outputs.deployment-url }}

jobs:
  deploy:
    name: Deploy Service
    runs-on: ubuntu-latest
    outputs:
      service-id: ${{ steps.deploy.outputs.service-id }}
      deployment-id: ${{ steps.monitor.outputs.deployment-id }}
      deployment-status: ${{ steps.monitor.outputs.deployment-status }}
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Deploy Railway Service
        id: deploy
        env:
          RAILWAY_TOKEN: ${{ secrets.railway-token }}
          PROJECT_ID: ${{ inputs.project-id }}
          ENVIRONMENT_ID: ${{ inputs.environment-id }}
          SERVICE_ID: ${{ inputs.service-id }}
          SERVICE_NAME: ${{ inputs.service-name }}
          REPOSITORY: ${{ inputs.repository }}
          BRANCH: ${{ inputs.branch }}
          COMMIT_SHA: ${{ inputs.commit-sha }}
          CUSTOM_DOMAIN: ${{ inputs.custom-domain }}
          VARIABLES_JSON: ${{ inputs.variables-json }}
        run: |
          echo "::group::üöÄ Deploying Railway Service"

          RAILWAY_API="https://backboard.railway.app/graphql/v2"

          # Validate variables JSON
          if ! echo "$VARIABLES_JSON" | jq empty 2>/dev/null; then
            echo "‚ùå Invalid variables JSON format"
            exit 1
          fi

          echo "üì¶ Configuration:"
          echo "  ‚Ä¢ Service: $SERVICE_NAME"
          echo "  ‚Ä¢ Repository: $REPOSITORY"
          echo "  ‚Ä¢ Branch: $BRANCH"
          echo "  ‚Ä¢ Commit: ${COMMIT_SHA:0:7}"
          echo "  ‚Ä¢ Variables: $(echo "$VARIABLES_JSON" | jq -c 'keys')"

          # Determine if creating or updating
          if [[ -z "$SERVICE_ID" ]]; then
            echo "üÜï Creating new service..."

            # Create service with source
            CREATE_RESPONSE=$(curl -s -X POST "$RAILWAY_API" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$(jq -n \
                --arg projectId "$PROJECT_ID" \
                --arg envId "$ENVIRONMENT_ID" \
                --arg name "$SERVICE_NAME" \
                --arg repo "$REPOSITORY" \
                --arg branch "$BRANCH" \
                '{
                  query: "mutation($input: ServiceCreateInput!) { serviceCreate(input: $input) { id name } }",
                  variables: {
                    input: {
                      projectId: $projectId,
                      environmentId: $envId,
                      name: $name,
                      source: {
                        repo: $repo,
                        branch: $branch
                      }
                    }
                  }
                }')")

            ERRORS=$(echo "$CREATE_RESPONSE" | jq -r '.errors // empty')
            if [[ -n "$ERRORS" ]]; then
              echo "‚ùå Service creation failed: $ERRORS"
              exit 1
            fi

            SERVICE_ID=$(echo "$CREATE_RESPONSE" | jq -r '.data.serviceCreate.id')
            echo "‚úÖ Service created: $SERVICE_ID"
          else
            echo "‚ôªÔ∏è  Updating existing service: $SERVICE_ID"
          fi

          # Set environment variables (one by one)
          echo "üìù Setting environment variables..."
          VAR_COUNT=0
          VAR_ERRORS=0

          # Loop through each variable and upsert individually
          for row in $(echo "$VARIABLES_JSON" | jq -r 'to_entries | .[] | @base64'); do
            _jq() {
              echo "${row}" | base64 --decode | jq -r "${1}"
            }

            VAR_NAME=$(_jq '.key')
            VAR_VALUE=$(_jq '.value')

            VAR_RESPONSE=$(curl -s -X POST "$RAILWAY_API" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$(jq -n \
                --arg projectId "$PROJECT_ID" \
                --arg environmentId "$ENVIRONMENT_ID" \
                --arg serviceId "$SERVICE_ID" \
                --arg name "$VAR_NAME" \
                --arg value "$VAR_VALUE" \
                '{
                  query: "mutation variableUpsert($input: VariableUpsertInput!) { variableUpsert(input: $input) }",
                  variables: {
                    input: {
                      projectId: $projectId,
                      environmentId: $environmentId,
                      serviceId: $serviceId,
                      name: $name,
                      value: $value,
                      skipDeploys: true
                    }
                  }
                }')")

            ERRORS=$(echo "$VAR_RESPONSE" | jq -r '.errors // empty')
            if [[ -n "$ERRORS" ]]; then
              echo "  ‚ö†Ô∏è  Failed to set $VAR_NAME"
              VAR_ERRORS=$((VAR_ERRORS + 1))
            else
              echo "  ‚úÖ Set $VAR_NAME"
              VAR_COUNT=$((VAR_COUNT + 1))
            fi
          done

          echo "üìä Variables: $VAR_COUNT set, $VAR_ERRORS failed"

          # Set deployment URL (custom domain configuration via Railway CLI separately)
          if [[ -n "$CUSTOM_DOMAIN" ]]; then
            echo "‚ÑπÔ∏è  Custom domain: $CUSTOM_DOMAIN (configure via Railway dashboard)"
            DEPLOYMENT_URL="https://$CUSTOM_DOMAIN"
          else
            DEPLOYMENT_URL="https://$(echo "$SERVICE_NAME" | tr '_' '-').up.railway.app"
          fi

          # Trigger deployment with specific commit
          echo "üîÑ Triggering deployment..."
          DEPLOY_RESPONSE=$(curl -s -X POST "$RAILWAY_API" \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg serviceId "$SERVICE_ID" \
              --arg environmentId "$ENVIRONMENT_ID" \
              '{
                query: "mutation($serviceId: String!, $environmentId: String!) { serviceInstanceRedeploy(serviceId: $serviceId, environmentId: $environmentId) }",
                variables: {
                  serviceId: $serviceId,
                  environmentId: $environmentId
                }
              }')")

          echo "‚úÖ Deployment triggered"

          echo "service-id=$SERVICE_ID" >> $GITHUB_OUTPUT
          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Monitor Deployment Status
        id: monitor
        env:
          RAILWAY_TOKEN: ${{ secrets.railway-token }}
          SERVICE_ID: ${{ steps.deploy.outputs.service-id }}
          ENVIRONMENT_ID: ${{ inputs.environment-id }}
          TIMEOUT: ${{ inputs.timeout-seconds }}
        run: |
          echo "::group::‚è≥ Monitoring Deployment Status"

          RAILWAY_API="https://backboard.railway.app/graphql/v2"
          START_TIME=$(date +%s)
          DEPLOYMENT_ID=""
          LAST_STATUS=""

          while true; do
            ELAPSED=$(($(date +%s) - START_TIME))

            if [[ $ELAPSED -ge $TIMEOUT ]]; then
              echo "‚ùå Deployment timeout after ${TIMEOUT}s"
              echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
              echo "deployment-status=TIMEOUT" >> $GITHUB_OUTPUT
              exit 1
            fi

            # Query latest deployment
            DEPLOY_RESPONSE=$(curl -s -X POST "$RAILWAY_API" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$(jq -n \
                --arg serviceId "$SERVICE_ID" \
                --arg envId "$ENVIRONMENT_ID" \
                '{
                  query: "query($serviceId: String!, $environmentId: String!) { deployments(first: 1, input: { serviceId: $serviceId, environmentId: $environmentId }) { edges { node { id status createdAt } } } }",
                  variables: {
                    serviceId: $serviceId,
                    environmentId: $envId
                  }
                }')")

            ERRORS=$(echo "$DEPLOY_RESPONSE" | jq -r '.errors // empty')
            if [[ -n "$ERRORS" ]]; then
              echo "‚ö†Ô∏è  Query error: $ERRORS"
              sleep 15
              continue
            fi

            DEPLOYMENT_ID=$(echo "$DEPLOY_RESPONSE" | jq -r '.data.deployments.edges[0].node.id // empty')
            STATUS=$(echo "$DEPLOY_RESPONSE" | jq -r '.data.deployments.edges[0].node.status // empty')

            if [[ -z "$DEPLOYMENT_ID" ]]; then
              echo "‚è≥ Waiting for deployment to start... (${ELAPSED}s)"
              sleep 15
              continue
            fi

            if [[ "$STATUS" != "$LAST_STATUS" ]]; then
              echo "üìä Status: $STATUS (${ELAPSED}s)"
              LAST_STATUS="$STATUS"
            fi

            case "$STATUS" in
              SUCCESS)
                echo "‚úÖ Deployment successful! (${ELAPSED}s)"
                echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "deployment-status=SUCCESS" >> $GITHUB_OUTPUT
                echo "::endgroup::"
                exit 0
                ;;
              FAILED|CRASHED)
                echo "‚ùå Deployment failed: $STATUS (${ELAPSED}s)"
                echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "deployment-status=$STATUS" >> $GITHUB_OUTPUT
                echo "::endgroup::"
                exit 1
                ;;
              BUILDING|DEPLOYING|INITIALIZING)
                # Still in progress
                sleep 15
                ;;
              *)
                echo "‚è≥ Status: $STATUS (${ELAPSED}s)"
                sleep 15
                ;;
            esac
          done

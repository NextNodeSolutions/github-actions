name: Deploy to Railway

on:
  workflow_call:
    inputs:
      env:
        description: 'Deployment environment (development/production/staging)'
        required: true
        type: string
      short-env:
        description: 'Short environment prefix for service naming (dev/prod/test)'
        required: true
        type: string
      app-name:
        description: 'Application name for Railway project'
        required: true
        type: string
      domain:
        description: 'Custom domain (will be prefixed with short-env for non-prod environments)'
        required: false
        default: ''
        type: string
      health-check-url:
        description: 'URL for health check'
        required: false
        default: ''
        type: string
      memory-mb:
        description: 'Memory allocation in MB'
        required: false
        default: '512'
        type: string
      checkout-ref:
        description: 'Git ref to checkout'
        required: false
        default: ''
        type: string
      app-env:
        description: 'Application environment (LOCAL/DEV/PROD)'
        required: false
        default: ''
        type: string
      variables:
        description: 'Environment variables as JSON object'
        required: false
        default: '{}'
        type: string
      working-directory:
        description: 'Working directory'
        required: false
        default: '.'
        type: string
    secrets:
      RAILWAY_API_TOKEN:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: false
    outputs:
      railway-url:
        description: 'Railway internal URL'
        value: ${{ jobs.deploy.outputs.railway-url }}
      custom-url:
        description: 'Custom domain URL (if configured)'
        value: ${{ jobs.deploy.outputs.custom-url }}
      final-url:
        description: 'Final application URL (custom or Railway)'
        value: ${{ jobs.deploy.outputs.final-url }}
      project-id:
        description: 'Railway project ID'
        value: ${{ jobs.deploy.outputs.project-id }}
      service-id:
        description: 'Railway service ID'
        value: ${{ jobs.deploy.outputs.service-id }}
      deployed:
        description: 'Deployment status'
        value: ${{ jobs.deploy.outputs.deployed }}

jobs:
  deploy:
    name: Deploy to Railway
    runs-on: ubuntu-latest
    environment: ${{ inputs.env }}
    outputs:
      railway-url: ${{ steps.deploy-info.outputs.railway-url }}
      custom-url: ${{ steps.deploy-info.outputs.custom-url }}
      final-url: ${{ steps.deploy-info.outputs.final-url }}
      project-id: ${{ steps.deploy-info.outputs.project-id }}
      service-id: ${{ steps.deploy-info.outputs.service-id }}
      deployed: ${{ steps.deploy-info.outputs.deployed }}
      
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.checkout-ref || github.ref }}
          
      - name: Setup Railway CLI
        run: |
          npm install -g @railway/cli
          railway --version
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          CI: true
          
      - name: Create or link Railway project
        id: project-setup
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Set project name (single project for all environments)
          PROJECT_NAME="${{ inputs.app-name }}"
          echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_ENV
          echo "project-name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          
          # Check if project exists
          if railway list --json | jq -r '.[].name' | grep -q "^$PROJECT_NAME$"; then
            echo "Project $PROJECT_NAME exists, linking..."
            PROJECT_ID=$(railway list --json | jq -r ".[] | select(.name==\"$PROJECT_NAME\") | .id")
            echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_ENV
            echo "project-id=$PROJECT_ID" >> $GITHUB_OUTPUT
          else
            echo "Creating new project $PROJECT_NAME..."
            railway init --name "$PROJECT_NAME"
            
            # Get the created project ID
            sleep 2  # Wait for project creation to propagate
            PROJECT_ID=$(railway list --json | jq -r ".[] | select(.name==\"$PROJECT_NAME\") | .id")
            
            if [ -n "$PROJECT_ID" ] && [ "$PROJECT_ID" != "null" ]; then
              echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_ENV
              echo "project-id=$PROJECT_ID" >> $GITHUB_OUTPUT
              echo "Created project with ID: $PROJECT_ID"
            else
              echo "Failed to create or find project $PROJECT_NAME"
              exit 1
            fi
          fi
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          CI: true
          
      - name: Setup service
        id: service-setup
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Helper function for consistent logging
          log_info() { echo "üîß $1"; }
          log_success() { echo "‚úÖ $1"; }
          log_error() { echo "‚ùå $1"; }
          
          # Generate service name using required inputs
          SERVICE_NAME="${{ inputs.short-env }}_${{ inputs.app-name }}"
          
          log_info "Service: $SERVICE_NAME"
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          
          # Setup environment (simplified approach)
          ENVIRONMENT="${{ inputs.env }}"
          log_info "Setting up environment: $ENVIRONMENT"
          
          # Direct link attempt with fallback
          if ! railway link --project "$PROJECT_ID" --environment "$ENVIRONMENT" 2>/dev/null; then
            log_info "Creating new environment: $ENVIRONMENT"
            railway link --project "$PROJECT_ID"
            railway environment new "$ENVIRONMENT" || true  # May already exist
            railway environment "$ENVIRONMENT"
          fi
          
          log_success "Environment linked: $ENVIRONMENT"
          
          # Service management with improved error handling
          log_info "Checking service existence..."
          
          # Get service info in one call
          SERVICE_INFO=$(railway status --json 2>/dev/null | jq -r '.services.edges[]? | .node | select(.name=="'"$SERVICE_NAME"'")' 2>/dev/null || echo "{}")
          SERVICE_ID=$(echo "$SERVICE_INFO" | jq -r '.id // empty' 2>/dev/null || echo "")
          
          if [ -n "$SERVICE_ID" ] && [ "$SERVICE_ID" != "empty" ]; then
            log_success "Service found: $SERVICE_NAME (ID: ${SERVICE_ID:0:8}...)"
            echo "SERVICE_ID=$SERVICE_ID" >> $GITHUB_ENV
            echo "service-id=$SERVICE_ID" >> $GITHUB_OUTPUT
          else
            log_info "Creating new service: $SERVICE_NAME"
            
            if railway add --service "$SERVICE_NAME"; then
              # Wait and retry to get service ID
              sleep 3
              for attempt in 1 2 3; do
                SERVICE_ID=$(railway status --json 2>/dev/null | jq -r '.services.edges[]? | .node | select(.name=="'"$SERVICE_NAME"'") | .id // empty' 2>/dev/null || echo "")
                [ -n "$SERVICE_ID" ] && [ "$SERVICE_ID" != "empty" ] && break
                log_info "Waiting for service creation (attempt $attempt/3)..."
                sleep 2
              done
              
              if [ -n "$SERVICE_ID" ] && [ "$SERVICE_ID" != "empty" ]; then
                log_success "Service created: $SERVICE_NAME (ID: ${SERVICE_ID:0:8}...)"
                echo "SERVICE_ID=$SERVICE_ID" >> $GITHUB_ENV
                echo "service-id=$SERVICE_ID" >> $GITHUB_OUTPUT
              else
                log_error "Failed to retrieve service ID after creation"
                exit 1
              fi
            else
              log_error "Failed to create service: $SERVICE_NAME"
              exit 1
            fi
          fi
          
          # Final service link
          log_info "Activating service context..."
          railway service "$SERVICE_NAME"
          log_success "Service setup completed: $SERVICE_NAME"
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          PROJECT_ID: ${{ steps.project-setup.outputs.project-id }}
          CI: true
          
      - name: Set environment variables
        if: inputs.variables != '{}' || inputs.app-env != ''
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "üîß Configuring environment variables..."
          
          VARIABLES_COUNT=0
          
          # Set custom variables from JSON
          if [ "${{ inputs.variables }}" != "{}" ]; then
            echo "üìù Setting custom variables:"
            echo '${{ inputs.variables }}' | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while read -r var; do
              VAR_NAME="${var%%=*}"
              VAR_VALUE="${var#*=}"
              echo "   ‚Ä¢ $VAR_NAME = $VAR_VALUE"
              railway variables --set "$var" || echo "   ‚ö†Ô∏è  Failed to set $VAR_NAME"
              VARIABLES_COUNT=$((VARIABLES_COUNT + 1))
            done
          fi
          
          # Set APP_ENV if provided
          if [ -n "${{ inputs.app-env }}" ]; then
            echo "üìù Setting application environment:"
            echo "   ‚Ä¢ APP_ENV = ${{ inputs.app-env }}"
            railway variables --set "APP_ENV=${{ inputs.app-env }}" || echo "   ‚ö†Ô∏è  Failed to set APP_ENV"
            VARIABLES_COUNT=$((VARIABLES_COUNT + 1))
          fi
          
          echo "‚úÖ Environment variables configured ($VARIABLES_COUNT variables set)"
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          CI: true
          
      - name: Deploy application
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "Deploying to Railway..."
          railway up --service "$SERVICE_NAME" --detach
          
          echo "Deployment initiated successfully"
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          SERVICE_NAME: ${{ steps.service-setup.outputs.service-name }}
          CI: true
          
      - name: Wait for deployment
        working-directory: ${{ inputs.working-directory }}
        run: |
          # Configuration
          MAX_WAIT=300  # 5 minutes
          CHECK_INTERVAL=20  # Check every 20 seconds for better responsiveness
          ELAPSED=0
          
          echo "üöÄ Monitoring Railway deployment..."
          echo "üìä Configuration: max_wait=${MAX_WAIT}s, check_interval=${CHECK_INTERVAL}s"
          echo "üéØ Service: $SERVICE_NAME"
          echo ""
          
          # JQ selector for reuse
          JQ_SERVICE_SELECTOR='.services.edges[] | .node | select(.name=="'"$SERVICE_NAME"'")'
          
          sleep 15  # Initial shorter wait
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Get full service info once
            SERVICE_INFO=$(railway status --json 2>/dev/null | jq -r "$JQ_SERVICE_SELECTOR" 2>/dev/null || echo "{}")
            
            if [ "$SERVICE_INFO" = "{}" ] || [ -z "$SERVICE_INFO" ]; then
              echo "‚ö†Ô∏è  Cannot retrieve service info (${ELAPSED}s elapsed) - retrying..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi
            
            # Extract deployment info
            DEPLOYMENT_STATUS=$(echo "$SERVICE_INFO" | jq -r '.serviceInstances.edges[].node.latestDeployment.status // "UNKNOWN"' 2>/dev/null)
            DEPLOYMENT_ID=$(echo "$SERVICE_INFO" | jq -r '.serviceInstances.edges[].node.latestDeployment.id // "N/A"' 2>/dev/null)
            
            # Progress indicator
            PROGRESS_DOTS=$(printf "%*s" $((ELAPSED / 10)) | tr ' ' '.')
            echo "[${ELAPSED}s] $PROGRESS_DOTS Deployment: $DEPLOYMENT_STATUS (ID: ${DEPLOYMENT_ID:0:8}...)"
            
            case "$DEPLOYMENT_STATUS" in
              "SUCCESS"|"LIVE")
                echo ""
                echo "‚úÖ Deployment completed successfully!"
                echo "üìã Final Status: $DEPLOYMENT_STATUS"
                echo "üÜî Deployment ID: $DEPLOYMENT_ID"
                echo "‚è±Ô∏è  Total time: ${ELAPSED}s"
                break
                ;;
              "FAILED"|"CRASHED"|"REMOVED")
                echo ""
                echo "‚ùå Deployment failed with status: $DEPLOYMENT_STATUS"
                echo "üÜî Deployment ID: $DEPLOYMENT_ID"
                echo "üîç Check Railway logs: https://railway.app/project/$PROJECT_ID"
                exit 1
                ;;
              "BUILDING"|"DEPLOYING"|"INITIALIZING"|"QUEUED")
                echo "    ‚è≥ In progress..."
                ;;
              *)
                echo "    ‚ö†Ô∏è  Unknown status: $DEPLOYMENT_STATUS"
                ;;
            esac
            
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo ""
            echo "‚è∞ Deployment monitoring timed out after $MAX_WAIT seconds"
            echo "‚ÑπÔ∏è  Service may still be deploying in the background"
            echo "üåê Check Railway dashboard: https://railway.app/project/$PROJECT_ID"
            echo "    Status was: $DEPLOYMENT_STATUS"
            # Continue without failing to allow URL retrieval
          fi
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          SERVICE_NAME: ${{ steps.service-setup.outputs.service-name }}
          CI: true
          
      - name: Generate Railway internal URL
        id: railway-url
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "üîç Ensuring Railway internal URL exists..."
          
          # JQ selector for reuse
          JQ_SERVICE_SELECTOR='.services.edges[] | .node | select(.name=="'"$SERVICE_NAME"'")'
          
          # First check if a Railway domain already exists
          SERVICE_DOMAIN=$(railway status --json 2>/dev/null | jq -r "$JQ_SERVICE_SELECTOR | .serviceInstances.edges[].node.domains.serviceDomains[0].domain // empty" 2>/dev/null)
          
          if [ -n "$SERVICE_DOMAIN" ] && [ "$SERVICE_DOMAIN" != "empty" ]; then
            # Use the existing Railway domain
            DOMAIN="$SERVICE_DOMAIN"
            RAILWAY_INTERNAL_URL="https://$DOMAIN"
            
            echo "‚úÖ Railway internal URL already exists!"
            echo "üåê URL: $RAILWAY_INTERNAL_URL"
            echo "üìã Domain: $DOMAIN"
          else
            echo "üîß Generating new Railway internal URL..."
            
            # Generate Railway domain (this will create a new one if none exists)
            DOMAIN_OUTPUT=$(railway domain --json --service "$SERVICE_NAME" 2>/dev/null || echo "{}")
            
            if [ "$DOMAIN_OUTPUT" != "{}" ]; then
              # Extract domain from JSON response
              RAILWAY_DOMAIN=$(echo "$DOMAIN_OUTPUT" | jq -r '.domain // empty' 2>/dev/null)
              
              if [ -n "$RAILWAY_DOMAIN" ] && [ "$RAILWAY_DOMAIN" != "empty" ]; then
                RAILWAY_INTERNAL_URL="https://$RAILWAY_DOMAIN"
                echo "‚úÖ Railway internal URL generated!"
                echo "üåê URL: $RAILWAY_INTERNAL_URL"
                echo "üìã Domain: $RAILWAY_DOMAIN"
              else
                echo "‚ö†Ô∏è  Failed to generate Railway domain"
                RAILWAY_INTERNAL_URL=""
              fi
            else
              echo "‚ö†Ô∏è  Failed to generate Railway domain - command error"
              RAILWAY_INTERNAL_URL=""
            fi
          fi
          
          # Set outputs
          echo "RAILWAY_INTERNAL_URL=$RAILWAY_INTERNAL_URL" >> $GITHUB_ENV
          echo "railway-internal-url=$RAILWAY_INTERNAL_URL" >> $GITHUB_OUTPUT
          
          if [ -z "$RAILWAY_INTERNAL_URL" ]; then
            echo "üåê Check Railway dashboard: https://railway.app/project/$PROJECT_ID"
            echo "üí° URL will be available once the service generates a domain"
          fi
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          SERVICE_NAME: ${{ steps.service-setup.outputs.service-name }}
          CI: true
          
      - name: Configure custom domain
        id: custom-domain
        if: inputs.domain != ''
        working-directory: ${{ inputs.working-directory }}
        run: |
          echo "üåê Configuring custom domain..."
          
          # Determine the final domain with prefix
          if [ "${{ inputs.short-env }}" = "prod" ]; then
            # Production uses domain as-is
            FINAL_DOMAIN="${{ inputs.domain }}"
          else
            # Non-production environments get prefix
            FINAL_DOMAIN="${{ inputs.short-env }}.${{ inputs.domain }}"
          fi
          
          echo "üìã Target domain: $FINAL_DOMAIN"
          
          # First, check if custom domain already exists for this service
          echo "üîç Checking existing custom domains..."
          JQ_SERVICE_SELECTOR='.services.edges[] | .node | select(.name=="'"$SERVICE_NAME"'")'
          
          # Get current service domains and remove any existing custom domains (Railway plan limit workaround)
          ALL_CUSTOM_DOMAINS=$(railway status --json 2>/dev/null | jq -r "$JQ_SERVICE_SELECTOR | .serviceInstances.edges[].node.domains.customDomains[]?" 2>/dev/null || echo "")
          
          # If there are any custom domains, remove them first
          if [ -n "$ALL_CUSTOM_DOMAINS" ]; then
            echo "üóëÔ∏è  Found existing custom domains, removing them first..."
            echo "$ALL_CUSTOM_DOMAINS" | jq -r '.id' | while read -r DOMAIN_ID; do
              if [ -n "$DOMAIN_ID" ] && [ "$DOMAIN_ID" != "null" ]; then
                echo "üóëÔ∏è  Deleting custom domain: $DOMAIN_ID"
                curl -s -X POST "https://backboard.railway.app/graphql/v2" \
                  -H "Authorization: Bearer ${{ secrets.RAILWAY_API_TOKEN }}" \
                  -H "Content-Type: application/json" \
                  -d "{\"query\":\"mutation { customDomainDelete(id: \\\"$DOMAIN_ID\\\") }\"}" > /dev/null
                sleep 2  # Wait for deletion to propagate
              fi
            done
            echo "‚úÖ Existing custom domains removed"
          fi
          
          # Now create the new custom domain
          echo "üîß Configuring Railway custom domain: $FINAL_DOMAIN"
          
          # Configure custom domain on Railway
          DOMAIN_OUTPUT=$(railway domain "$FINAL_DOMAIN" --service "$SERVICE_NAME" --json 2>/dev/null || echo "{}")
          
          if [ "$DOMAIN_OUTPUT" != "{}" ]; then
            echo "‚úÖ Railway custom domain configured!"
            
            # Extract DNS records needed for Cloudflare from the new response structure
            CNAME_TARGET=$(echo "$DOMAIN_OUTPUT" | jq -r '.customDomainCreate.status.dnsRecords[] | select(.recordType=="DNS_RECORD_TYPE_CNAME") | .requiredValue' 2>/dev/null || echo "")
            
            if [ -z "$CNAME_TARGET" ]; then
              # Try fallback extraction methods for older API responses
              CNAME_TARGET=$(echo "$DOMAIN_OUTPUT" | jq -r '.dnsRecords[] | select(.type=="CNAME") | .value // empty' 2>/dev/null || echo "")
            fi
            
            DOMAIN_CONFIGURED=true
          else
            echo "‚ö†Ô∏è  Failed to configure Railway custom domain"
            echo "üåê Check Railway dashboard: https://railway.app/project/$PROJECT_ID"
            DOMAIN_CONFIGURED=false
          fi
          
          # Set outputs based on configuration result
          if [ "$DOMAIN_CONFIGURED" = "true" ]; then
            echo "üìã Domain: $FINAL_DOMAIN"
            
            if [ -n "$CNAME_TARGET" ]; then
              echo "üîç CNAME target: $CNAME_TARGET"
              echo "CNAME_TARGET=$CNAME_TARGET" >> $GITHUB_ENV
              echo "cname-target=$CNAME_TARGET" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è  No CNAME target found in Railway response"
            fi
            
            CUSTOM_URL="https://$FINAL_DOMAIN"
            echo "CUSTOM_URL=$CUSTOM_URL" >> $GITHUB_ENV
            echo "custom-url=$CUSTOM_URL" >> $GITHUB_OUTPUT
            echo "final-domain=$FINAL_DOMAIN" >> $GITHUB_OUTPUT
          else
            echo "final-domain=" >> $GITHUB_OUTPUT
            echo "custom-url=" >> $GITHUB_OUTPUT
            echo "cname-target=" >> $GITHUB_OUTPUT
          fi
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          SERVICE_NAME: ${{ steps.service-setup.outputs.service-name }}
          CI: true
          
      - name: Configure Cloudflare DNS
        id: cloudflare-dns
        if: inputs.domain != '' && steps.custom-domain.outputs.final-domain != ''
        run: |
          echo "‚òÅÔ∏è  Configuring Cloudflare DNS..."
          
          # Check if Cloudflare API token is provided
          if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
            echo "‚ö†Ô∏è  No Cloudflare API token provided - skipping DNS configuration"
            echo "üí° Set CLOUDFLARE_API_TOKEN secret to enable automatic DNS setup"
            echo "cloudflare-configured=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          FINAL_DOMAIN="${{ steps.custom-domain.outputs.final-domain }}"
          CNAME_TARGET="${{ steps.custom-domain.outputs.cname-target }}"
          
          if [ -z "$CNAME_TARGET" ]; then
            echo "‚ö†Ô∏è  No CNAME target available - skipping DNS configuration"
            echo "üí° Railway domain may not be ready yet or custom domain setup failed"
            echo "cloudflare-configured=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get zone ID for the root domain
          ROOT_DOMAIN=$(echo "${{ inputs.domain }}" | sed 's/.*\.\([^.]*\.[^.]*\)$/\1/')
          echo "üîç Root domain: $ROOT_DOMAIN"
          
          ZONE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ROOT_DOMAIN" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" | jq -r '.result[0].id // empty')
          
          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "empty" ]; then
            echo "‚ö†Ô∏è  Could not find Cloudflare zone for domain: $ROOT_DOMAIN"
            echo "üí° Make sure the domain is added to your Cloudflare account"
            exit 0
          fi
          
          echo "‚úÖ Found Cloudflare zone: $ZONE_ID"
          
          # Check if DNS record already exists
          RECORD_NAME=$(echo "$FINAL_DOMAIN" | sed "s/\.$ROOT_DOMAIN$//" | sed "s/^$ROOT_DOMAIN$/@/")
          
          # Check for existing DNS record (CNAME or A record)
          EXISTING_RECORD_DATA=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$FINAL_DOMAIN" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json")
          
          EXISTING_RECORD_ID=$(echo "$EXISTING_RECORD_DATA" | jq -r '.result[0].id // empty')
          EXISTING_RECORD_TYPE=$(echo "$EXISTING_RECORD_DATA" | jq -r '.result[0].type // empty')
          EXISTING_RECORD_CONTENT=$(echo "$EXISTING_RECORD_DATA" | jq -r '.result[0].content // empty')
          
          if [ -n "$EXISTING_RECORD_ID" ] && [ "$EXISTING_RECORD_ID" != "empty" ]; then
            if [ "$EXISTING_RECORD_CONTENT" = "$CNAME_TARGET" ]; then
              echo "‚úÖ DNS record already up to date ($EXISTING_RECORD_TYPE -> $CNAME_TARGET)"
              echo "cloudflare-configured=true" >> $GITHUB_OUTPUT
              DNS_CONFIGURED=true
            else
              echo "üîÑ Updating existing $EXISTING_RECORD_TYPE record: $EXISTING_RECORD_CONTENT -> $CNAME_TARGET"
              RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$EXISTING_RECORD_ID" \
                -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"CNAME\",\"name\":\"$FINAL_DOMAIN\",\"content\":\"$CNAME_TARGET\",\"proxied\":true}")
              DNS_CONFIGURED=false
            fi
          else
            echo "‚ûï Creating new CNAME record: $FINAL_DOMAIN -> $CNAME_TARGET"
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"$FINAL_DOMAIN\",\"content\":\"$CNAME_TARGET\",\"proxied\":true}")
            DNS_CONFIGURED=false
          fi
          
          # Check response only if we made an API call
          if [ "$DNS_CONFIGURED" != "true" ]; then
            SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
            
            if [ "$SUCCESS" = "true" ]; then
              echo "‚úÖ Cloudflare DNS configured successfully!"
              echo "üåê $FINAL_DOMAIN -> $CNAME_TARGET (proxied)"
              echo "cloudflare-configured=true" >> $GITHUB_OUTPUT
            else
              ERROR=$(echo "$RESPONSE" | jq -r '.errors[0].message // "Unknown error"')
              echo "‚ùå Failed to configure Cloudflare DNS: $ERROR"
              echo "cloudflare-configured=false" >> $GITHUB_OUTPUT
            fi
          fi
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          
      - name: Health check
        if: inputs.health-check-url != '' || env.RAILWAY_INTERNAL_URL != '' || env.CUSTOM_URL != ''
        run: |
          # Determine which URL to use for health check
          URL="${{ inputs.health-check-url }}"
          
          if [ -z "$URL" ]; then
            # Prefer custom URL if available, fallback to Railway internal URL
            if [ -n "${{ env.CUSTOM_URL }}" ]; then
              URL="${{ env.CUSTOM_URL }}"
              echo "üîç Using custom domain for health check"
            elif [ -n "${{ env.RAILWAY_INTERNAL_URL }}" ]; then
              URL="${{ env.RAILWAY_INTERNAL_URL }}"
              echo "üîç Using Railway internal URL for health check"
            fi
          fi
          
          if [ -z "$URL" ]; then
            echo "‚ö†Ô∏è  No URL available for health check"
            exit 0
          fi
          
          echo "üè• Performing health check on: $URL"
          
          # Wait for deployment to be ready
          echo "‚è≥ Waiting 30 seconds for deployment to be ready..."
          sleep 30
          
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîç Health check attempt $i/$MAX_RETRIES..."
            
            if curl -f -s --max-time 30 "$URL" > /dev/null; then
              echo "‚úÖ Health check passed!"
              break
            elif [ $i -eq $MAX_RETRIES ]; then
              echo "‚ùå Health check failed after $MAX_RETRIES attempts"
              if [ "${{ inputs.env }}" == "production" ]; then
                echo "‚ö†Ô∏è  Production deployment health check failed - manual intervention may be required"
                exit 1
              else
                echo "‚ö†Ô∏è  Development deployment health check failed - continuing"
              fi
            else
              echo "‚è≥ Health check attempt $i failed, retrying in 30 seconds..."
              sleep 30
            fi
          done
          
      - name: Set deployment info
        id: deploy-info
        run: |
          # Set Railway internal URL
          echo "railway-url=$RAILWAY_INTERNAL_URL" >> $GITHUB_OUTPUT
          
          # Set custom URL (if configured)
          CUSTOM_URL="${{ env.CUSTOM_URL }}"
          echo "custom-url=$CUSTOM_URL" >> $GITHUB_OUTPUT
          
          # Determine final URL (prefer custom, fallback to Railway)
          if [ -n "$CUSTOM_URL" ]; then
            FINAL_URL="$CUSTOM_URL"
          else
            FINAL_URL="$RAILWAY_INTERNAL_URL"
          fi
          echo "final-url=$FINAL_URL" >> $GITHUB_OUTPUT
          
          # Set other outputs
          echo "project-id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "service-id=$SERVICE_ID" >> $GITHUB_OUTPUT
          echo "deployed=true" >> $GITHUB_OUTPUT
          
          # Summary
          echo "üöÄ Deployment completed successfully!"
          echo ""
          echo "üìã Project Details:"
          echo "  ‚Ä¢ Project: $PROJECT_NAME ($PROJECT_ID)"
          echo "  ‚Ä¢ Service: $SERVICE_NAME ($SERVICE_ID)"
          echo "  ‚Ä¢ Environment: ${{ inputs.env }}"
          echo ""
          echo "üåê URLs:"
          echo "  ‚Ä¢ Railway Internal: $RAILWAY_INTERNAL_URL"
          
          if [ -n "$CUSTOM_URL" ]; then
            echo "  ‚Ä¢ Custom Domain: $CUSTOM_URL"
            echo "  ‚Ä¢ Final URL: $CUSTOM_URL"
            
            if [ "${{ steps.cloudflare-dns.outputs.cloudflare-configured }}" = "true" ]; then
              echo "  ‚Ä¢ Cloudflare DNS: ‚úÖ Configured"
            else
              echo "  ‚Ä¢ Cloudflare DNS: ‚ö†Ô∏è  Manual configuration required"
            fi
          else
            echo "  ‚Ä¢ Final URL: $RAILWAY_INTERNAL_URL"
          fi
        env:
          RAILWAY_INTERNAL_URL: ${{ steps.railway-url.outputs.railway-internal-url }}
          PROJECT_ID: ${{ steps.project-setup.outputs.project-id }}
          SERVICE_ID: ${{ steps.service-setup.outputs.service-id }}
          PROJECT_NAME: ${{ steps.project-setup.outputs.project-name }}
          SERVICE_NAME: ${{ steps.service-setup.outputs.service-name }}
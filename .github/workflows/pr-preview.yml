name: Railway PR Preview

# EXTERNAL WORKFLOW - Automated PR preview deployments to Railway
# Deploys each PR to pr-{number}.dev.{base-domain}
# Uses Railway GraphQL API for proper variable timing (fixes canonical URL issue)

on:
  workflow_call:
    inputs:
      app-name:
        description: 'Application name for Railway project'
        required: true
        type: string
      base-domain:
        description: 'Base domain for PR previews (e.g. nextnode.fr)'
        required: true
        type: string
      base-environment:
        description: 'Base Railway environment for PR previews'
        required: false
        default: 'development'
        type: string
      run-quality-checks:
        description: 'Run quality checks (lint + typecheck) before deployment'
        required: false
        default: true
        type: boolean
      working-directory:
        description: 'Working directory'
        required: false
        default: '.'
        type: string
      memory-mb:
        description: 'Memory allocation in MB for PR preview'
        required: false
        default: '512'
        type: string
      timeout-seconds:
        description: 'Deployment timeout in seconds'
        required: false
        default: '300'
        type: string
    secrets:
      RAILWAY_API_TOKEN:
        required: true
    outputs:
      deployment-url:
        description: 'PR preview deployment URL (https://pr-X.dev.domain)'
        value: ${{ jobs.deploy-preview.outputs.deployment-url }}
      custom-domain:
        description: 'Custom domain for PR preview (pr-X.dev.domain)'
        value: ${{ jobs.deploy-preview.outputs.custom-domain }}
      railway-url:
        description: 'Railway internal URL'
        value: ${{ jobs.deploy-preview.outputs.railway-url }}
      cname-target:
        description: 'CNAME target from Railway for DNS configuration'
        value: ${{ jobs.deploy-preview.outputs.cname-target }}
      service-name:
        description: 'Railway service name'
        value: ${{ jobs.deploy-preview.outputs.service-name }}
      deployment-status:
        description: 'Deployment status (SUCCESS/FAILURE)'
        value: ${{ jobs.deploy-preview.outputs.deployment-status }}

jobs:
  validate-tokens:
    name: Validate Tokens
    runs-on: ubuntu-latest
    steps:
      - uses: NextNodeSolutions/github-actions/actions/utilities/validate-tokens@main
        with:
          railway-api-token: ${{ secrets.RAILWAY_API_TOKEN }}
          fail-on-invalid: true

  quality-checks:
    name: Quality Checks
    needs: [validate-tokens]
    if: inputs.run-quality-checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js and pnpm
        uses: NextNodeSolutions/github-actions/actions/node-setup-complete@main
        with:
          working-directory: ${{ inputs.working-directory }}

      - name: Lint
        uses: NextNodeSolutions/github-actions/actions/quality/lint@main
        with:
          working-directory: ${{ inputs.working-directory }}
          fail-on-warning: false

      - name: Type Check
        uses: NextNodeSolutions/github-actions/actions/quality/typecheck@main
        with:
          working-directory: ${{ inputs.working-directory }}

  deploy-preview:
    name: Deploy PR Preview
    runs-on: ubuntu-latest
    needs: [validate-tokens, quality-checks]
    if: |
      always() &&
      needs.validate-tokens.result == 'success' &&
      (needs.quality-checks.result == 'success' || needs.quality-checks.result == 'skipped')
    outputs:
      deployment-url: ${{ steps.domain.outputs.deployment-url }}
      custom-domain: ${{ steps.domain.outputs.custom-domain }}
      service-name: ${{ steps.domain.outputs.service-name }}
      railway-url: ${{ steps.deploy.outputs.railway-url }}
      cname-target: ${{ steps.deploy.outputs.cname-target }}
      deployment-status: ${{ steps.monitor.outputs.status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Calculate PR Service Name and Domain
        id: domain
        shell: bash
        run: |
          echo "::group::ğŸ”§ Calculating PR Preview Configuration"

          PR_NUMBER="${{ github.event.pull_request.number }}"
          APP_NAME="${{ inputs.app-name }}"
          BASE_DOMAIN="${{ inputs.base-domain }}"

          # Generate service name and custom domain
          SERVICE_NAME="pr-${PR_NUMBER}_${APP_NAME}"
          CUSTOM_DOMAIN="pr-${PR_NUMBER}.dev.${BASE_DOMAIN}"
          DEPLOYMENT_URL="https://${CUSTOM_DOMAIN}"
          CNAME_TARGET="pr-${PR_NUMBER}.up.railway.app"

          echo "â€¢ PR Number: $PR_NUMBER"
          echo "â€¢ App Name: $APP_NAME"
          echo "â€¢ Service Name: $SERVICE_NAME"
          echo "â€¢ Custom Domain: $CUSTOM_DOMAIN"
          echo "â€¢ Deployment URL: $DEPLOYMENT_URL"
          echo "â€¢ CNAME Target: $CNAME_TARGET"

          # Set outputs
          echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "custom-domain=$CUSTOM_DOMAIN" >> $GITHUB_OUTPUT
          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "cname-target=$CNAME_TARGET" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Discover Railway IDs
        id: discover
        shell: bash
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          echo "::group::ğŸ” Discovering Railway Resource IDs"

          eval $(.github/scripts/railway-get-ids.sh \
            --project-name "${{ inputs.app-name }}" \
            --environment-name "${{ inputs.base-environment }}" \
            --service-name "${{ steps.domain.outputs.service-name }}")

          echo "project-id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "environment-id=$ENVIRONMENT_ID" >> $GITHUB_OUTPUT
          echo "service-exists=$SERVICE_EXISTS" >> $GITHUB_OUTPUT

          if [[ "$SERVICE_EXISTS" == "true" ]]; then
            echo "service-id=$SERVICE_ID" >> $GITHUB_OUTPUT
            echo "âœ… Service already exists: $SERVICE_ID"
          else
            echo "â„¹ï¸  Service will be created"
          fi

          echo "::endgroup::"

      - name: Deploy Railway Service
        id: deploy
        shell: bash
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          echo "::group::ğŸš€ Deploying Service with GraphQL API"

          # Prepare environment variables
          VARIABLES=$(jq -n \
            --arg url "${{ steps.domain.outputs.deployment-url }}" \
            --arg node_env "production" \
            --arg host "0.0.0.0" \
            --arg port "3000" \
            --arg memory "${{ inputs.memory-mb }}" \
            '{
              URL: $url,
              NODE_ENV: $node_env,
              HOST: $host,
              PORT: $port,
              RAILWAY_SERVICE_MEMORY_LIMIT_MB: $memory
            }')

          echo "ğŸ“¦ Variables configured:"
          echo "$VARIABLES" | jq '.'

          # Build service ID flag if exists
          SERVICE_ID_FLAG=""
          if [[ "${{ steps.discover.outputs.service-exists }}" == "true" ]]; then
            SERVICE_ID_FLAG="--service-id ${{ steps.discover.outputs.service-id }}"
            echo "â™»ï¸  Updating existing service"
          else
            echo "ğŸ†• Creating new service"
          fi

          # Deploy service
          eval $(.github/scripts/railway-service-deploy.sh \
            --project-id "${{ steps.discover.outputs.project-id }}" \
            --environment-id "${{ steps.discover.outputs.environment-id }}" \
            --service-name "${{ steps.domain.outputs.service-name }}" \
            $SERVICE_ID_FLAG \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --domain "${{ steps.domain.outputs.custom-domain }}" \
            --variables "$VARIABLES")

          echo "service-id=$SERVICE_ID" >> $GITHUB_OUTPUT
          echo "railway-url=https://${{ steps.domain.outputs.cname-target }}" >> $GITHUB_OUTPUT
          echo "cname-target=${{ steps.domain.outputs.cname-target }}" >> $GITHUB_OUTPUT

          echo "âœ… Service deployed: $SERVICE_ID"
          echo "::endgroup::"

      - name: Monitor Deployment
        id: monitor
        shell: bash
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          echo "::group::â³ Monitoring Deployment Status"

          if eval $(.github/scripts/railway-monitor-deployment.sh \
            --service-id "${{ steps.deploy.outputs.service-id }}" \
            --environment-id "${{ steps.discover.outputs.environment-id }}" \
            --timeout "${{ inputs.timeout-seconds }}" \
            --interval 15); then
            echo "status=SUCCESS" >> $GITHUB_OUTPUT
          else
            echo "status=FAILED" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "::endgroup::"

      - name: Comment PR with Deployment Info
        uses: actions/github-script@v7
        if: always()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deploymentUrl = '${{ steps.domain.outputs.deployment-url }}';
            const serviceName = '${{ steps.domain.outputs.service-name }}';
            const railwayUrl = '${{ steps.deploy.outputs.railway-url }}';
            const status = '${{ steps.monitor.outputs.status }}';
            const prNumber = ${{ github.event.pull_request.number }};
            const runQuality = ${{ inputs.run-quality-checks }};
            const baseEnv = '${{ inputs.base-environment }}';

            // Calculate deployment duration
            const jobStart = new Date('${{ github.event.pull_request.updated_at }}');
            const now = new Date();
            const durationMinutes = Math.floor((now - jobStart) / 1000 / 60);
            const durationSeconds = Math.floor((now - jobStart) / 1000 % 60);
            const durationStr = `${durationMinutes}m ${durationSeconds}s`;

            let qualityChecks = '';
            if (runQuality) {
              qualityChecks = `
            âœ… Lint passed
            âœ… Typecheck passed`;
            }

            const comment = `## ğŸš€ PR Preview Deployment ${status === 'SUCCESS' ? 'Ready!' : 'Status'}

            ğŸ“ **Preview URL:** ${deploymentUrl}
            ğŸ”§ **Service:** \`${serviceName}\`
            ğŸŒ **Environment:** ${baseEnv}
            ğŸ“Š **Status:** ${status}
            â±ï¸ **Deployed in:** ${durationStr}${qualityChecks}

            ---
            <details>
            <summary>ğŸ” Railway Details</summary>

            - **Railway URL:** ${railwayUrl}
            - **PR Number:** #${prNumber}
            - **Memory:** ${{ inputs.memory-mb }}MB
            - **Deployment Method:** GraphQL API âœ¨

            </details>

            > Preview deployments are automatically updated on each commit and cleaned up when the PR is closed.
            `;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ğŸš€ PR Preview Deployment')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment,
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment,
              });
            }

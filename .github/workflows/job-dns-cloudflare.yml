name: Configure DNS with Cloudflare

on:
  workflow_call:
    inputs:
      domain:
        description: 'Domain to configure'
        required: true
        type: string
      subdomain:
        description: 'Subdomain (empty for root domain)'
        required: false
        default: ''
        type: string
      app-name:
        description: 'Fly.io app name for SSL certificate'
        required: true
        type: string
      proxied:
        description: 'Enable Cloudflare proxy'
        required: false
        default: true
        type: boolean
      ttl:
        description: 'DNS record TTL'
        required: false
        default: 1
        type: number
    secrets:
      FLY_API_TOKEN:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true
    outputs:
      dns-updated:
        description: 'DNS update status'
        value: ${{ jobs.dns.outputs.dns-updated }}
      custom-url:
        description: 'Custom domain URL'
        value: ${{ jobs.dns.outputs.custom-url }}

jobs:
  dns:
    name: Configure DNS
    runs-on: ubuntu-latest
    outputs:
      dns-updated: ${{ steps.dns-update.outputs.updated }}
      custom-url: ${{ steps.dns-update.outputs.custom-url }}
      
    steps:
      - name: Setup Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master
        
      - name: Update DNS records
        id: dns-update
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          # Start timing
          START_TIME=$(date +%s)
          echo "🕐 DNS configuration started at $(date)"
          
          # Construct full domain
          if [ -n "${{ inputs.subdomain }}" ]; then
            FULL_DOMAIN="${{ inputs.subdomain }}.${{ inputs.domain }}"
            RECORD_NAME="${{ inputs.subdomain }}"
          else
            FULL_DOMAIN="${{ inputs.domain }}"
            RECORD_NAME="@"
          fi
          
          echo "🌐 Configuring DNS for: $FULL_DOMAIN"
          
          # Get Zone ID for the domain
          echo "📡 Fetching Zone ID for domain: ${{ inputs.domain }}"
          ZONE_START=$(date +%s)
          ZONE_RESPONSE=$(curl -s "https://api.cloudflare.com/client/v4/zones?name=${{ inputs.domain }}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          ZONE_END=$(date +%s)
          
          CLOUDFLARE_ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id // ""')
          
          if [ -z "$CLOUDFLARE_ZONE_ID" ] || [ "$CLOUDFLARE_ZONE_ID" == "null" ]; then
            echo "::error::Could not find Zone ID for domain ${{ inputs.domain }}"
            echo "API Response: $ZONE_RESPONSE"
            exit 1
          fi
          
          echo "✅ Found Zone ID: $CLOUDFLARE_ZONE_ID (took $((ZONE_END - ZONE_START))s)"
          
          # Get Fly.io IPs
          echo "🚀 Fetching Fly.io IPs for app: ${{ inputs.app-name }}"
          FLY_START=$(date +%s)
          IPV4=$(flyctl ips list --app ${{ inputs.app-name }} --json | jq -r '.[] | select(.Type == "v4") | .Address' | head -1)
          IPV6=$(flyctl ips list --app ${{ inputs.app-name }} --json | jq -r '.[] | select(.Type == "v6") | .Address' | head -1)
          FLY_END=$(date +%s)
          
          if [ -z "$IPV4" ]; then
            echo "::error::No IPv4 address found for app ${{ inputs.app-name }}"
            exit 1
          fi
          
          # Prefer IPv6 if available
          if [ -n "$IPV6" ] && [ "$IPV6" != "null" ]; then
            TARGET_IP="$IPV6"
            RECORD_TYPE="AAAA"
            OLD_TYPE="A"
          else
            TARGET_IP="$IPV4"
            RECORD_TYPE="A"
            OLD_TYPE="AAAA"
          fi
          
          echo "🎯 Target IP: $TARGET_IP (Type: $RECORD_TYPE) - Retrieved in $((FLY_END - FLY_START))s"
          
          # Check existing DNS record
          EXISTING_RECORD=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$FULL_DOMAIN&type=$RECORD_TYPE" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          
          RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // ""')
          CURRENT_IP=$(echo "$EXISTING_RECORD" | jq -r '.result[0].content // ""')
          
          # Update or create DNS record
          if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
            if [ "$CURRENT_IP" != "$TARGET_IP" ]; then
              echo "Updating existing $RECORD_TYPE record"
              curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{
                  \"type\": \"$RECORD_TYPE\",
                  \"name\": \"$RECORD_NAME\",
                  \"content\": \"$TARGET_IP\",
                  \"ttl\": ${{ inputs.ttl }},
                  \"proxied\": ${{ inputs.proxied }}
                }" | jq -r '.success' > /dev/null
              echo "updated=true" >> $GITHUB_OUTPUT
            else
              echo "DNS record already up to date"
              echo "updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Creating new $RECORD_TYPE record"
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"$RECORD_TYPE\",
                \"name\": \"$RECORD_NAME\",
                \"content\": \"$TARGET_IP\",
                \"ttl\": ${{ inputs.ttl }},
                \"proxied\": ${{ inputs.proxied }}
              }" | jq -r '.success' > /dev/null
            echo "updated=true" >> $GITHUB_OUTPUT
          fi
          
          # Clean up old record type if needed
          OLD_RECORD=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$FULL_DOMAIN&type=$OLD_TYPE" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          OLD_RECORD_ID=$(echo "$OLD_RECORD" | jq -r '.result[0].id // ""')
          
          if [ -n "$OLD_RECORD_ID" ] && [ "$OLD_RECORD_ID" != "null" ]; then
            echo "Removing old $OLD_TYPE record"
            curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$OLD_RECORD_ID" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" > /dev/null
          fi
          
          echo "custom-url=https://$FULL_DOMAIN" >> $GITHUB_OUTPUT
          
          # DNS timing summary
          DNS_END_TIME=$(date +%s)
          DNS_TOTAL_TIME=$((DNS_END_TIME - START_TIME))
          
          echo ""
          echo "📊 === DNS Configuration Performance Summary ==="
          echo "🕐 Total DNS setup time: ${DNS_TOTAL_TIME}s"
          echo "🌐 DNS configuration completed at $(date)"
          echo "==============================================="
          
      - name: Configure SSL certificate
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          # Start SSL timing
          SSL_START_TIME=$(date +%s)
          echo "🔒 SSL configuration started at $(date)"
          
          # Construct full domain
          if [ -n "${{ inputs.subdomain }}" ]; then
            FULL_DOMAIN="${{ inputs.subdomain }}.${{ inputs.domain }}"
          else
            FULL_DOMAIN="${{ inputs.domain }}"
          fi
          
          # Check if certificate already exists and its status
          CERT_EXISTS=$(flyctl certs list --app ${{ inputs.app-name }} | grep -q "$FULL_DOMAIN" && echo "true" || echo "false")
          CERT_STATUS="unknown"
          SKIP_CERT_CREATION="false"
          
          if [ "$CERT_EXISTS" == "true" ]; then
            echo "Certificate exists for $FULL_DOMAIN, checking status..."
            CERT_STATUS_OUTPUT=$(flyctl certs show $FULL_DOMAIN --app ${{ inputs.app-name }} --json 2>/dev/null || echo "{}")
            
            if echo "$CERT_STATUS_OUTPUT" | jq . >/dev/null 2>&1; then
              CERT_STATUS=$(echo "$CERT_STATUS_OUTPUT" | jq -r '.status // "unknown"')
              echo "Current certificate status: $CERT_STATUS"
              
              if [ "$CERT_STATUS" == "Ready" ] || [ "$CERT_STATUS" == "ready" ]; then
                echo "✅ SSL certificate is already ready for $FULL_DOMAIN, skipping creation"
                SKIP_CERT_CREATION="true"
              elif [ "$CERT_STATUS" == "Error" ] || [ "$CERT_STATUS" == "error" ]; then
                echo "❌ Certificate is in error state, will recreate"
                flyctl certs delete $FULL_DOMAIN --app ${{ inputs.app-name }} --yes || true
                sleep 5
              else
                echo "⏳ Certificate exists but is not ready (status: $CERT_STATUS), will monitor existing one"
                SKIP_CERT_CREATION="true"
              fi
            fi
          fi
          
          if [ "$SKIP_CERT_CREATION" == "false" ]; then
            echo "Creating SSL certificate for $FULL_DOMAIN"
            flyctl certs create $FULL_DOMAIN --app ${{ inputs.app-name }}
          fi
          
          # Get ACME challenge info
          ACME_CHALLENGE_INFO=$(flyctl certs show $FULL_DOMAIN --app ${{ inputs.app-name }} 2>&1)
          
          # Check if we need to create ACME challenge CNAME
          if echo "$ACME_CHALLENGE_INFO" | grep -q "_acme-challenge"; then
            ACME_TARGET=$(echo "$ACME_CHALLENGE_INFO" | grep -o "[a-zA-Z0-9]\+\.$FULL_DOMAIN\.[a-zA-Z0-9]\+\.flydns\.net" | head -1)
            if [ -n "$ACME_TARGET" ]; then
              echo "Creating ACME challenge CNAME: _acme-challenge.$FULL_DOMAIN -> $ACME_TARGET"
              
              # Create ACME challenge CNAME record
              ACME_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{
                  \"type\": \"CNAME\",
                  \"name\": \"_acme-challenge.$(if [ -n \"${{ inputs.subdomain }}\" ]; then echo \"${{ inputs.subdomain }}\"; else echo \"@\"; fi)\",
                  \"content\": \"$ACME_TARGET\",
                  \"ttl\": 120,
                  \"proxied\": false
                }")
              
              if echo "$ACME_RESPONSE" | jq -r '.success' | grep -q true; then
                echo "ACME challenge CNAME created successfully"
                # Wait for DNS propagation
                echo "Waiting for DNS propagation..."
                sleep 30
              else
                echo "Failed to create ACME challenge CNAME: $(echo "$ACME_RESPONSE" | jq -r '.errors')"
              fi
            fi
          fi
          
          # Only wait for certificate if we created one or it's not already ready
          if [ "$SKIP_CERT_CREATION" == "false" ] || [ "$CERT_STATUS" != "Ready" ] && [ "$CERT_STATUS" != "ready" ]; then
            echo "⏳ Waiting for SSL certificate to be ready..."
            CERT_WAIT_START=$(date +%s)
            MAX_WAIT=300  # 5 minutes
            ELAPSED=0
            RETRY_COUNT=0
            MAX_RETRIES=3
            
            while [ $ELAPSED -lt $MAX_WAIT ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Check certificate status with error handling
            CERT_OUTPUT=$(flyctl certs show $FULL_DOMAIN --app ${{ inputs.app-name }} --json 2>&1)
            
            if echo "$CERT_OUTPUT" | jq . >/dev/null 2>&1; then
              # Valid JSON output
              STATUS=$(echo "$CERT_OUTPUT" | jq -r '.status // "unknown"')
              if [ "$STATUS" == "Ready" ] || [ "$STATUS" == "ready" ]; then
                echo "SSL certificate is ready"
                break
              elif [ "$STATUS" == "Error" ] || [ "$STATUS" == "error" ]; then
                echo "Certificate is in error state, attempting to recreate..."
                # Delete the failed certificate
                flyctl certs delete $FULL_DOMAIN --app ${{ inputs.app-name }} --yes || true
                sleep 5
                # Recreate certificate
                flyctl certs create $FULL_DOMAIN --app ${{ inputs.app-name }}
                RETRY_COUNT=$((RETRY_COUNT + 1))
                ELAPSED=0  # Reset timer for new certificate
                continue
              fi
              echo "Certificate status: $STATUS, waiting..."
            else
              # Invalid JSON or error output
              echo "Certificate check returned error: $CERT_OUTPUT"
              if echo "$CERT_OUTPUT" | grep -q "not found"; then
                echo "Certificate not found, recreating..."
                flyctl certs create $FULL_DOMAIN --app ${{ inputs.app-name }}
                RETRY_COUNT=$((RETRY_COUNT + 1))
                ELAPSED=0
                continue
              fi
            fi
            
            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done
          
            CERT_WAIT_END=$(date +%s)
            if [ $ELAPSED -ge $MAX_WAIT ] || [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
              echo "::warning::Certificate setup timed out or failed after retries. Certificate may still be processing."
              echo "⏱️ Certificate wait time: $((CERT_WAIT_END - CERT_WAIT_START))s (timeout after ${MAX_WAIT}s)"
            else
              echo "✅ SSL certificate is ready after $((CERT_WAIT_END - CERT_WAIT_START))s"
            fi
          else
            echo "✅ SSL certificate is already ready, skipping wait"
          fi
          
          # Final timing summary
          SSL_END_TIME=$(date +%s)
          SSL_TOTAL_TIME=$((SSL_END_TIME - SSL_START_TIME))
          
          echo ""
          echo "📊 === SSL Configuration Performance Summary ==="
          echo "🕐 Total SSL setup time: ${SSL_TOTAL_TIME}s"
          echo "🔒 SSL configuration completed at $(date)"
          echo "==============================================="
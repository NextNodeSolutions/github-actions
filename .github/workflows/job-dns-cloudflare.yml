name: Configure DNS with Cloudflare

on:
  workflow_call:
    inputs:
      domain:
        description: 'Domain to configure'
        required: true
        type: string
      subdomain:
        description: 'Subdomain (empty for root domain)'
        required: false
        default: ''
        type: string
      app-name:
        description: 'Fly.io app name for SSL certificate'
        required: true
        type: string
      proxied:
        description: 'Enable Cloudflare proxy (false recommended for Fly.io SSL)'
        required: false
        default: false
        type: boolean
      ttl:
        description: 'DNS record TTL'
        required: false
        default: 1
        type: number
    secrets:
      FLY_API_TOKEN:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true
    outputs:
      dns-updated:
        description: 'DNS update status'
        value: ${{ jobs.dns.outputs.dns-updated }}
      custom-url:
        description: 'Custom domain URL'
        value: ${{ jobs.dns.outputs.custom-url }}

jobs:
  dns:
    name: Configure DNS
    runs-on: ubuntu-latest
    outputs:
      dns-updated: ${{ steps.dns-update.outputs.updated }}
      custom-url: ${{ steps.dns-update.outputs.custom-url }}
      
    steps:
      - name: Setup Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master
        
      - name: Update DNS records
        id: dns-update
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          # Start timing
          START_TIME=$(date +%s)
          echo "üïê DNS configuration started at $(date)"
          
          # Construct full domain
          if [ -n "${{ inputs.subdomain }}" ]; then
            FULL_DOMAIN="${{ inputs.subdomain }}.${{ inputs.domain }}"
            RECORD_NAME="${{ inputs.subdomain }}"
          else
            FULL_DOMAIN="${{ inputs.domain }}"
            RECORD_NAME="@"
          fi
          
          echo "üåê Configuring DNS for: $FULL_DOMAIN"
          echo "üîß Proxy mode: ${{ inputs.proxied }}"
          
          # Get Zone ID for the domain
          echo "üì° Fetching Zone ID for domain: ${{ inputs.domain }}"
          ZONE_START=$(date +%s)
          ZONE_RESPONSE=$(curl -s "https://api.cloudflare.com/client/v4/zones?name=${{ inputs.domain }}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          ZONE_END=$(date +%s)
          
          CLOUDFLARE_ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id // ""')
          
          if [ -z "$CLOUDFLARE_ZONE_ID" ] || [ "$CLOUDFLARE_ZONE_ID" == "null" ]; then
            echo "::error::Could not find Zone ID for domain ${{ inputs.domain }}"
            echo "API Response: $ZONE_RESPONSE"
            exit 1
          fi
          
          echo "‚úÖ Found Zone ID: $CLOUDFLARE_ZONE_ID (took $((ZONE_END - ZONE_START))s)"
          
          # List existing DNS records for the domain to detect conflicts
          echo "üìã Checking existing DNS records for conflicts..."
          EXISTING_RECORDS=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$FULL_DOMAIN" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          
          # Count existing records
          RECORD_COUNT=$(echo "$EXISTING_RECORDS" | jq '.result | length')
          echo "Found $RECORD_COUNT existing record(s) for $FULL_DOMAIN"
          
          if [ "$RECORD_COUNT" -gt 0 ]; then
            echo "Existing records:"
            echo "$EXISTING_RECORDS" | jq -r '.result[] | "  - \(.type): \(.content) (proxied: \(.proxied))"'
          fi
          
          # Check for wildcard records that might conflict
          WILDCARD_RECORDS=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=*.${{ inputs.domain }}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          WILDCARD_COUNT=$(echo "$WILDCARD_RECORDS" | jq '.result | length')
          
          if [ "$WILDCARD_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $WILDCARD_COUNT wildcard record(s) that might conflict:"
            echo "$WILDCARD_RECORDS" | jq -r '.result[] | "  - \(.type): \(.name) ‚Üí \(.content)"'
          fi
          
          # Get Fly.io IPs
          echo "üöÄ Fetching Fly.io IPs for app: ${{ inputs.app-name }}"
          FLY_START=$(date +%s)
          IPV4=$(flyctl ips list --app ${{ inputs.app-name }} --json | jq -r '.[] | select(.Type == "v4") | .Address' | head -1)
          IPV6=$(flyctl ips list --app ${{ inputs.app-name }} --json | jq -r '.[] | select(.Type == "v6") | .Address' | head -1)
          FLY_END=$(date +%s)
          
          if [ -z "$IPV4" ]; then
            echo "::error::No IPv4 address found for app ${{ inputs.app-name }}"
            exit 1
          fi
          
          # Prefer IPv6 if available
          if [ -n "$IPV6" ] && [ "$IPV6" != "null" ]; then
            TARGET_IP="$IPV6"
            RECORD_TYPE="AAAA"
            OLD_TYPE="A"
          else
            TARGET_IP="$IPV4"
            RECORD_TYPE="A"
            OLD_TYPE="AAAA"
          fi
          
          echo "üéØ Target IP: $TARGET_IP (Type: $RECORD_TYPE) - Retrieved in $((FLY_END - FLY_START))s"
          
          # Clean up ALL existing A and AAAA records for the domain (complete override)
          echo "üßπ Cleaning up existing A and AAAA records for $FULL_DOMAIN..."
          
          # Get all A and AAAA records for this domain
          ALL_RECORDS=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$FULL_DOMAIN" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          
          # Delete all existing A and AAAA records
          echo "$ALL_RECORDS" | jq -r '.result[] | select(.type == "A" or .type == "AAAA") | .id' | while read -r record_id; do
            if [ -n "$record_id" ] && [ "$record_id" != "null" ]; then
              echo "Removing existing record: $record_id"
              curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$record_id" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" > /dev/null
            fi
          done
          
          # Check if there are any remaining records after cleanup
          REMAINING_RECORDS=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$FULL_DOMAIN&type=$RECORD_TYPE" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          
          RECORD_ID=$(echo "$REMAINING_RECORDS" | jq -r '.result[0].id // ""')
          CURRENT_IP=$(echo "$REMAINING_RECORDS" | jq -r '.result[0].content // ""')
          
          # Create the new DNS record (always create since we cleaned up above)
          echo "‚ú® Creating new $RECORD_TYPE record: $RECORD_NAME ‚Üí $TARGET_IP"
          CREATE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "{
              \"type\": \"$RECORD_TYPE\",
              \"name\": \"$RECORD_NAME\",
              \"content\": \"$TARGET_IP\",
              \"ttl\": ${{ inputs.ttl }},
              \"proxied\": ${{ inputs.proxied }}
            }")
          
          if echo "$CREATE_RESPONSE" | jq -r '.success' | grep -q true; then
            echo "‚úÖ Successfully created $RECORD_TYPE record"
            echo "updated=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Failed to create DNS record: $(echo "$CREATE_RESPONSE" | jq -r '.errors')"
            exit 1
          fi
          
          echo "custom-url=https://$FULL_DOMAIN" >> $GITHUB_OUTPUT
          
          # DNS timing summary
          DNS_END_TIME=$(date +%s)
          DNS_TOTAL_TIME=$((DNS_END_TIME - START_TIME))
          
          echo ""
          echo "üìä === DNS Configuration Performance Summary ==="
          echo "üïê Total DNS setup time: ${DNS_TOTAL_TIME}s"
          echo "üåê DNS configuration completed at $(date)"
          echo "==============================================="
          
      - name: Configure SSL certificate
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          # Start SSL timing
          SSL_START_TIME=$(date +%s)
          echo "üîí SSL configuration started at $(date)"
          
          # Construct full domain
          if [ -n "${{ inputs.subdomain }}" ]; then
            FULL_DOMAIN="${{ inputs.subdomain }}.${{ inputs.domain }}"
          else
            FULL_DOMAIN="${{ inputs.domain }}"
          fi
          
          # Check if certificate already exists and its status
          CERT_EXISTS=$(flyctl certs list --app ${{ inputs.app-name }} | grep -q "$FULL_DOMAIN" && echo "true" || echo "false")
          CERT_STATUS="unknown"
          SKIP_CERT_CREATION="false"
          
          if [ "$CERT_EXISTS" == "true" ]; then
            echo "Certificate exists for $FULL_DOMAIN, checking status..."
            CERT_STATUS_OUTPUT=$(flyctl certs show $FULL_DOMAIN --app ${{ inputs.app-name }} --json 2>/dev/null || echo "{}")
            
            if echo "$CERT_STATUS_OUTPUT" | jq . >/dev/null 2>&1; then
              CERT_STATUS=$(echo "$CERT_STATUS_OUTPUT" | jq -r '.status // "unknown"')
              echo "Current certificate status: $CERT_STATUS"
              
              if [ "$CERT_STATUS" == "Ready" ] || [ "$CERT_STATUS" == "ready" ]; then
                echo "‚úÖ SSL certificate is already ready for $FULL_DOMAIN, skipping creation"
                SKIP_CERT_CREATION="true"
              elif [ "$CERT_STATUS" == "Error" ] || [ "$CERT_STATUS" == "error" ]; then
                echo "‚ùå Certificate is in error state, will recreate"
                flyctl certs delete $FULL_DOMAIN --app ${{ inputs.app-name }} --yes || true
                sleep 5
              else
                echo "‚è≥ Certificate exists but is not ready (status: $CERT_STATUS), will monitor existing one"
                SKIP_CERT_CREATION="true"
              fi
            fi
          fi
          
          if [ "$SKIP_CERT_CREATION" == "false" ]; then
            echo "Creating SSL certificate for $FULL_DOMAIN"
            flyctl certs create $FULL_DOMAIN --app ${{ inputs.app-name }}
          fi
          
          # Get ACME challenge info
          ACME_CHALLENGE_INFO=$(flyctl certs show $FULL_DOMAIN --app ${{ inputs.app-name }} 2>&1)
          
          # Check if we need to create ACME challenge CNAME
          if echo "$ACME_CHALLENGE_INFO" | grep -q "_acme-challenge"; then
            ACME_TARGET=$(echo "$ACME_CHALLENGE_INFO" | grep -o "[a-zA-Z0-9]\+\.$FULL_DOMAIN\.[a-zA-Z0-9]\+\.flydns\.net" | head -1)
            if [ -n "$ACME_TARGET" ]; then
              echo "Creating ACME challenge CNAME: _acme-challenge.$FULL_DOMAIN -> $ACME_TARGET"
              
              # Determine correct ACME challenge name
              if [ -n "${{ inputs.subdomain }}" ]; then
                ACME_NAME="_acme-challenge.${{ inputs.subdomain }}"
              else
                ACME_NAME="_acme-challenge"
              fi
              
              # Check if ACME challenge CNAME already exists and remove it
              EXISTING_ACME=$(curl -s "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=_acme-challenge.$FULL_DOMAIN&type=CNAME" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
              ACME_ID=$(echo "$EXISTING_ACME" | jq -r '.result[0].id // ""')
              
              if [ -n "$ACME_ID" ] && [ "$ACME_ID" != "null" ]; then
                echo "Removing existing ACME challenge CNAME"
                curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$ACME_ID" \
                  -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" > /dev/null
              fi
              
              # Create ACME challenge CNAME record
              ACME_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{
                  \"type\": \"CNAME\",
                  \"name\": \"$ACME_NAME\",
                  \"content\": \"$ACME_TARGET\",
                  \"ttl\": 120,
                  \"proxied\": false
                }")
              
              if echo "$ACME_RESPONSE" | jq -r '.success' | grep -q true; then
                echo "ACME challenge CNAME created successfully"
                # Wait for DNS propagation
                echo "Waiting for DNS propagation..."
                sleep 30
              else
                echo "Failed to create ACME challenge CNAME: $(echo "$ACME_RESPONSE" | jq -r '.errors')"
              fi
            fi
          fi
          
          # Simplified certificate waiting - let Fly.io handle the complexity
          if [ "$SKIP_CERT_CREATION" == "false" ] || [ "$CERT_STATUS" != "Ready" ] && [ "$CERT_STATUS" != "ready" ]; then
            echo "‚è≥ Waiting for SSL certificate to be ready..."
            CERT_WAIT_START=$(date +%s)
            MAX_WAIT=180  # 3 minutes (reduced from 5)
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CERT_OUTPUT=$(flyctl certs show $FULL_DOMAIN --app ${{ inputs.app-name }} --json 2>/dev/null || echo "{}")
              
              if echo "$CERT_OUTPUT" | jq . >/dev/null 2>&1; then
                STATUS=$(echo "$CERT_OUTPUT" | jq -r '.status // "unknown"')
                if [ "$STATUS" == "Ready" ] || [ "$STATUS" == "ready" ]; then
                  echo "‚úÖ SSL certificate is ready"
                  break
                fi
                echo "Certificate status: $STATUS, waiting..."
              fi
              
              sleep 30
              ELAPSED=$((ELAPSED + 30))
            done
            
            CERT_WAIT_END=$(date +%s)
            if [ $ELAPSED -ge $MAX_WAIT ]; then
              echo "::warning::Certificate setup still in progress after ${MAX_WAIT}s. This is normal for new domains."
              echo "üîí SSL will be ready shortly. Fly.io will continue processing in the background."
            else
              echo "‚úÖ SSL certificate ready in $((CERT_WAIT_END - CERT_WAIT_START))s"
            fi
          else
            echo "‚úÖ SSL certificate is already ready, skipping wait"
          fi
          
          # Final timing summary
          SSL_END_TIME=$(date +%s)
          SSL_TOTAL_TIME=$((SSL_END_TIME - SSL_START_TIME))
          
          echo ""
          echo "üìä === SSL Configuration Performance Summary ==="
          echo "üïê Total SSL setup time: ${SSL_TOTAL_TIME}s"
          echo "üîí SSL configuration completed at $(date)"
          echo "==============================================="
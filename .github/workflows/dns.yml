name: DNS Cloudflare

# EXTERNAL WORKFLOW - Atomic Cloudflare DNS update workflow
# Configures DNS records via Cloudflare API

on:
  workflow_call:
    inputs:
      domain:
        description: 'Domain to configure'
        required: true
        type: string
      target:
        description: 'Target URL or IP address'
        required: true
        type: string
      record-type:
        description: 'DNS record type (A, AAAA, CNAME)'
        required: false
        default: 'CNAME'
        type: string
      proxied:
        description: 'Enable Cloudflare proxy'
        required: false
        default: true
        type: boolean
      ttl:
        description: 'DNS TTL in seconds (1 = automatic)'
        required: false
        default: '1'
        type: string
      enable-seo-setup:
        description: 'Enable automatic SEO configuration'
        required: false
        default: true
        type: boolean
      blocked-subdomains:
        description: 'Comma-separated list of subdomains to block from search engines'
        required: false
        default: 'dev,staging,test,preview'
        type: string
      enable-optimizations:
        description: 'Enable Cloudflare performance optimizations'
        required: false
        default: true
        type: boolean
    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: false
    outputs:
      dns-updated:
        description: 'Whether DNS was successfully updated'
        value: ${{ jobs.update.outputs.success }}
      record-id:
        description: 'Cloudflare DNS record ID'
        value: ${{ jobs.update.outputs.record-id }}
      seo-configured:
        description: 'Whether SEO configuration was successful'
        value: ${{ jobs.seo-setup.outputs.seo-configured }}
      transform-rules-created:
        description: 'Number of transform rules created for SEO'
        value: ${{ jobs.seo-setup.outputs.transform-rules-created }}

jobs:
  update:
    name: Update DNS
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.cloudflare.outputs.success == 'true' }}
      record-id: ${{ steps.cloudflare.outputs.record-id }}
    steps:
      - name: Update Cloudflare DNS
        id: cloudflare
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          # Get zone ID if not provided
          if [[ -z "$CF_ZONE_ID" ]]; then
            # Extract root domain from full domain
            ROOT_DOMAIN=$(echo "${{ inputs.domain }}" | awk -F. '{print $(NF-1)"."$NF}')
            
            ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ROOT_DOMAIN" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json")
            
            CF_ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')
            
            if [[ -z "$CF_ZONE_ID" || "$CF_ZONE_ID" == "null" ]]; then
              echo "success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # Check if ANY record exists for this domain (A, AAAA, CNAME)
          # First check for the exact type we want
          EXISTING_EXACT=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=${{ inputs.domain }}&type=${{ inputs.record-type }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")
          
          # Then check for any conflicting record types (A, AAAA, CNAME)
          EXISTING_ANY=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=${{ inputs.domain }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")
          
          echo "DEBUG: API Response for exact type (${{ inputs.record-type }}):"
          echo "$EXISTING_EXACT" | jq '.'
          
          echo "DEBUG: API Response for any record type:"
          echo "$EXISTING_ANY" | jq '.'
          
          # Filter for A, AAAA, CNAME records only
          CONFLICTING_RECORDS=$(echo "$EXISTING_ANY" | jq '[.result[] | select(.type == "A" or .type == "AAAA" or .type == "CNAME")]')
          RECORD_COUNT=$(echo "$CONFLICTING_RECORDS" | jq -r 'length')
          echo "DEBUG: Found $RECORD_COUNT conflicting records (A/AAAA/CNAME)"
          
          # Use exact match if available, otherwise use first conflicting record
          if [[ $(echo "$EXISTING_EXACT" | jq -r '.result | length') -gt 0 ]]; then
            echo "DEBUG: Using exact type match"
            RECORD_ID=$(echo "$EXISTING_EXACT" | jq -r '.result[0].id // empty')
            CURRENT_CONTENT=$(echo "$EXISTING_EXACT" | jq -r '.result[0].content // empty')
            CURRENT_PROXIED=$(echo "$EXISTING_EXACT" | jq -r '.result[0].proxied // empty')
            CURRENT_TYPE=$(echo "$EXISTING_EXACT" | jq -r '.result[0].type // empty')
          elif [[ $RECORD_COUNT -gt 0 ]]; then
            echo "DEBUG: Using first conflicting record for replacement"
            RECORD_ID=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].id // empty')
            CURRENT_CONTENT=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].content // empty')
            CURRENT_PROXIED=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].proxied // empty')
            CURRENT_TYPE=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].type // empty')
          else
            RECORD_ID=""
            CURRENT_CONTENT=""
            CURRENT_PROXIED=""
            CURRENT_TYPE=""
          fi
          
          echo "DEBUG: Extracted values:"
          echo "  ‚Ä¢ RECORD_ID: '$RECORD_ID'"
          echo "  ‚Ä¢ CURRENT_TYPE: '$CURRENT_TYPE'"
          echo "  ‚Ä¢ CURRENT_CONTENT: '$CURRENT_CONTENT'"
          echo "  ‚Ä¢ CURRENT_PROXIED: '$CURRENT_PROXIED'"
          
          # Clean target URL for CNAME records (remove https:// if present)
          TARGET_VALUE="${{ inputs.target }}"
          if [[ "${{ inputs.record-type }}" == "CNAME" ]]; then
            # Remove protocol and trailing slash if present
            TARGET_VALUE=$(echo "$TARGET_VALUE" | sed 's|^https\?://||g' | sed 's|/$||g')
            echo "Original target: ${{ inputs.target }}"
            echo "Cleaned CNAME target: $TARGET_VALUE"
          fi
          
          # Check if record already has the correct values
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" && "$RECORD_ID" != "" ]]; then
            echo "Existing record found:"
            echo "  ‚Ä¢ Record ID: $RECORD_ID"
            echo "  ‚Ä¢ Current type: $CURRENT_TYPE"
            echo "  ‚Ä¢ Current content: $CURRENT_CONTENT"
            echo "  ‚Ä¢ New type: ${{ inputs.record-type }}"
            echo "  ‚Ä¢ New content: $TARGET_VALUE"
            echo "  ‚Ä¢ Current proxied: $CURRENT_PROXIED"
            echo "  ‚Ä¢ New proxied: ${{ inputs.proxied }}"
            
            # Convert boolean values for comparison
            EXPECTED_PROXIED="${{ inputs.proxied }}"
            EXPECTED_TYPE="${{ inputs.record-type }}"
            
            if [[ "$CURRENT_TYPE" == "$EXPECTED_TYPE" && "$CURRENT_CONTENT" == "$TARGET_VALUE" && "$CURRENT_PROXIED" == "$EXPECTED_PROXIED" ]]; then
              echo "‚úÖ DNS record already up to date - no changes needed"
              echo "success=true" >> $GITHUB_OUTPUT
              {
              echo 'record-id<<EOF'
              echo "$RECORD_ID"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
              exit 0
            else
              echo "üìù DNS record needs to be updated/replaced"
              echo "  Differences:"
              [[ "$CURRENT_TYPE" != "$EXPECTED_TYPE" ]] && echo "    - Type: '$CURRENT_TYPE' ‚Üí '$EXPECTED_TYPE'"
              [[ "$CURRENT_CONTENT" != "$TARGET_VALUE" ]] && echo "    - Content: '$CURRENT_CONTENT' ‚Üí '$TARGET_VALUE'"
              [[ "$CURRENT_PROXIED" != "$EXPECTED_PROXIED" ]] && echo "    - Proxied: '$CURRENT_PROXIED' ‚Üí '$EXPECTED_PROXIED'"
            fi
          else
            echo "No existing record found - will create new record"
          fi

          # Detect and create wildcard for sub-subdomains (e.g., pr-56.dev.nextnode.fr)
          DOMAIN="${{ inputs.domain }}"
          # Extract TLD (last 2 parts: domain.tld)
          ROOT_DOMAIN=$(echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}')
          # Remove TLD to get subdomain parts
          SUBDOMAIN_PARTS=$(echo "$DOMAIN" | sed "s/\.$ROOT_DOMAIN$//")
          # Count dots in subdomain parts (0 = direct subdomain, 1+ = sub-subdomain)
          DOT_COUNT=$(echo "$SUBDOMAIN_PARTS" | grep -o '\.' | wc -l | xargs)

          echo "DEBUG: Wildcard detection:"
          echo "  ‚Ä¢ Full domain: $DOMAIN"
          echo "  ‚Ä¢ Root domain: $ROOT_DOMAIN"
          echo "  ‚Ä¢ Subdomain parts: $SUBDOMAIN_PARTS"
          echo "  ‚Ä¢ Dot count in subdomain: $DOT_COUNT"

          if [[ $DOT_COUNT -ge 1 ]]; then
            # This is a sub-subdomain (e.g., pr-56.dev.nextnode.fr ‚Üí *.dev.nextnode.fr)
            PARENT_SUBDOMAIN=$(echo "$SUBDOMAIN_PARTS" | cut -d'.' -f2-)
            WILDCARD_DOMAIN="*.${PARENT_SUBDOMAIN}.${ROOT_DOMAIN}"

            echo "üîç Detected sub-subdomain pattern"
            echo "  ‚Ä¢ Creating wildcard: $WILDCARD_DOMAIN"

            # Check if wildcard already exists
            WILDCARD_CHECK=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=$WILDCARD_DOMAIN" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json")

            WILDCARD_EXISTS=$(echo "$WILDCARD_CHECK" | jq -r '.result | length')

            if [[ $WILDCARD_EXISTS -eq 0 ]]; then
              echo "‚ú® Creating wildcard DNS record: $WILDCARD_DOMAIN"

              WILDCARD_DATA=$(jq -n \
                --arg type "${{ inputs.record-type }}" \
                --arg name "$WILDCARD_DOMAIN" \
                --arg content "$TARGET_VALUE" \
                --argjson proxied "${{ inputs.proxied }}" \
                --argjson ttl "${{ inputs.ttl }}" \
                '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')

              WILDCARD_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CF_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "$WILDCARD_DATA")

              WILDCARD_SUCCESS=$(echo "$WILDCARD_RESPONSE" | jq -r '.success')

              if [[ "$WILDCARD_SUCCESS" == "true" ]]; then
                echo "‚úÖ Wildcard record created successfully"
              else
                echo "‚ö†Ô∏è Wildcard creation failed (non-blocking):"
                echo "$WILDCARD_RESPONSE" | jq '.errors'
              fi
            else
              echo "‚úÖ Wildcard record already exists: $WILDCARD_DOMAIN"
            fi
          else
            echo "‚ÑπÔ∏è  Direct subdomain - no wildcard needed"
          fi

          # Prepare record data
          RECORD_DATA=$(jq -n \
            --arg type "${{ inputs.record-type }}" \
            --arg name "${{ inputs.domain }}" \
            --arg content "$TARGET_VALUE" \
            --argjson proxied "${{ inputs.proxied }}" \
            --argjson ttl "${{ inputs.ttl }}" \
            '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')
          
          # Create or update record
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" ]]; then
            RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$RECORD_DATA")
          else
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$RECORD_DATA")
            RECORD_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          fi
          
          # Check success
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          {
              echo 'record-id<<EOF'
              echo "$RECORD_ID"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          
          if [[ "$SUCCESS" != "true" ]]; then
            echo "$RESPONSE" | jq '.errors'
            exit 1
          fi
          
          # Add www subdomain (CNAME to same Railway target)
          if [[ "${{ inputs.domain }}" != www.* ]]; then
            echo "Adding www.${{ inputs.domain }} CNAME to same target..."
            
            WWW_DATA=$(jq -n \
              --arg type "CNAME" \
              --arg name "www.${{ inputs.domain }}" \
              --arg content "$TARGET_VALUE" \
              --argjson proxied true \
              --argjson ttl 1 \
              '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')
            
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$WWW_DATA" || echo "www subdomain might already exist"
          fi

  seo-setup:
    name: Configure SEO
    runs-on: ubuntu-latest
    needs: update
    if: ${{ inputs.enable-seo-setup == true && needs.update.outputs.success == 'true' }}
    outputs:
      seo-configured: ${{ steps.seo.outputs.seo-configured }}
      transform-rules-created: ${{ steps.seo.outputs.transform-rules-created }}
    
    steps:
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: NextNodeSolutions/github-actions
          token: ${{ github.token }}
          path: .github-actions
          
      - name: üéØ Configure Cloudflare SEO
        id: seo
        uses: ./.github-actions/actions/seo/cloudflare-seo-setup
        with:
          domain: ${{ inputs.domain }}
          blocked-subdomains: ${{ inputs.blocked-subdomains }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          cloudflare-zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          enable-www-redirect: true
          enable-optimizations: ${{ inputs.enable-optimizations }}
          dry-run: false
          
      - name: üìä SEO Configuration Summary
        run: |
          echo "## üéØ SEO Configuration Complete!"
          echo ""
          echo "**Domain:** ${{ inputs.domain }}"
          echo "**Success:** ${{ steps.seo.outputs.seo-configured }}"
          echo "**Transform Rules:** ${{ steps.seo.outputs.transform-rules-created }}"
          echo "**Blocked Subdomains:** ${{ inputs.blocked-subdomains }}"
          echo ""
          
          if [[ "${{ steps.seo.outputs.seo-configured }}" == "true" ]]; then
            echo "‚úÖ **DNS + SEO configuration successful!**"
            echo ""
            echo "### Configured automatically:"
            echo "- üåê DNS records for ${{ inputs.domain }}"
            echo "- üö´ SEO blocking for development subdomains (via Transform Rules)"
            echo "- üîÄ WWW redirects (via Single Redirects)"
            echo "- ‚ö° Performance optimizations"
            echo "- ü§ñ X-Robots-Tag headers (automated)"
          else
            echo "‚ùå **SEO configuration failed** (DNS was successful)"
          fi

      - name: ‚úÖ SEO Configuration Complete
        if: steps.seo.outputs.seo-configured == 'true'
        run: |
          echo "::notice title=SEO Configuration Complete::All SEO configuration completed automatically via Transform Rules and Single Redirects. No manual steps required."
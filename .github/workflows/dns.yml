name: DNS Cloudflare

# EXTERNAL WORKFLOW - Atomic Cloudflare DNS update workflow
# Configures DNS records via Cloudflare API

on:
  workflow_call:
    inputs:
      domain:
        description: 'Domain to configure'
        required: true
        type: string
      target:
        description: 'Target URL or IP address'
        required: true
        type: string
      record-type:
        description: 'DNS record type (A, AAAA, CNAME)'
        required: false
        default: 'CNAME'
        type: string
      proxied:
        description: 'Enable Cloudflare proxy'
        required: false
        default: true
        type: boolean
      ttl:
        description: 'DNS TTL in seconds (1 = automatic)'
        required: false
        default: '1'
        type: string
      enable-seo-setup:
        description: 'Enable automatic SEO configuration'
        required: false
        default: true
        type: boolean
      blocked-subdomains:
        description: 'Comma-separated list of subdomains to block from search engines'
        required: false
        default: 'dev,staging,test,preview'
        type: string
      allowed-subdomains:
        description: 'Comma-separated list of subdomains to ALWAYS allow (whitelist, overrides blocked list)'
        required: false
        default: ''
        type: string
      enable-optimizations:
        description: 'Enable Cloudflare performance optimizations'
        required: false
        default: true
        type: boolean
      enable-health-check:
        description: 'Enable health check after DNS configuration'
        required: false
        default: true
        type: boolean
      health-check-mandatory:
        description: 'Make health check mandatory (workflow fails if health check fails)'
        required: false
        default: false
        type: boolean
      health-check-max-attempts:
        description: 'Max health check attempts'
        required: false
        default: '4'
        type: string
      health-check-delay:
        description: 'Delay between health check attempts (seconds)'
        required: false
        default: '30'
        type: string
      dns-propagation-wait:
        description: 'Wait time for DNS propagation (seconds)'
        required: false
        default: '60'
        type: string
      enable-ssl-setup:
        description: 'Enable automatic SSL/TLS mode configuration (recommended for Railway)'
        required: false
        default: true
        type: boolean
      ssl-mode:
        description: 'SSL/TLS mode: off, flexible, full, strict (Railway requires "full")'
        required: false
        default: 'full'
        type: string
    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: false
    outputs:
      dns-updated:
        description: 'Whether DNS was successfully updated'
        value: ${{ jobs.update.outputs.success }}
      record-id:
        description: 'Cloudflare DNS record ID'
        value: ${{ jobs.update.outputs.record-id }}
      ssl-configured:
        description: 'Whether SSL/TLS was successfully configured'
        value: ${{ jobs.ssl-setup.outputs.ssl-configured }}
      ssl-mode:
        description: 'SSL/TLS mode configured'
        value: ${{ jobs.ssl-setup.outputs.ssl-mode }}
      seo-configured:
        description: 'Whether SEO configuration was successful'
        value: ${{ jobs.seo-setup.outputs.seo-configured }}
      transform-rules-created:
        description: 'Number of transform rules created for SEO'
        value: ${{ jobs.seo-setup.outputs.transform-rules-created }}

jobs:
  validate-tokens:
    name: Validate Tokens
    runs-on: ubuntu-latest
    steps:
      - uses: NextNodeSolutions/github-actions/actions/utilities/validate-tokens@main
        with:
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          fail-on-invalid: true

  ssl-setup:
    name: Configure SSL/TLS
    needs: [validate-tokens]
    if: ${{ inputs.enable-ssl-setup == true }}
    runs-on: ubuntu-latest
    outputs:
      ssl-configured: ${{ steps.ssl.outputs.ssl-configured }}
      ssl-mode: ${{ steps.ssl.outputs.new-mode }}
      zone-id: ${{ steps.ssl.outputs.zone-id }}
    steps:
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: NextNodeSolutions/github-actions
          token: ${{ github.token }}
          path: .github-actions

      - name: Configure Cloudflare SSL/TLS
        id: ssl
        uses: ./.github-actions/actions/ssl/cloudflare-ssl-setup
        with:
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          cloudflare-zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          domain: ${{ inputs.domain }}
          ssl-mode: ${{ inputs.ssl-mode }}

  update:
    name: Update DNS
    runs-on: ubuntu-latest
    needs: [validate-tokens, ssl-setup]
    if: |
      always() &&
      needs.validate-tokens.result == 'success' &&
      (needs.ssl-setup.result == 'success' || needs.ssl-setup.result == 'skipped')
    outputs:
      success: ${{ steps.cloudflare.outputs.success == 'true' }}
      record-id: ${{ steps.cloudflare.outputs.record-id }}
    steps:
      - name: Update Cloudflare DNS
        id: cloudflare
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          # Get zone ID if not provided
          if [[ -z "$CF_ZONE_ID" ]]; then
            # Extract root domain from full domain
            ROOT_DOMAIN=$(echo "${{ inputs.domain }}" | awk -F. 'NF>=2{print $(NF-1)"."$NF; next} {print $0}')
            
            ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ROOT_DOMAIN" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json")
            
            CF_ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')
            
            if [[ -z "$CF_ZONE_ID" || "$CF_ZONE_ID" == "null" ]]; then
              echo "success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

          # Detect sub-subdomain depth for Railway compatibility
          # Railway + Cloudflare proxy: sub-subdomains (3+ levels) require proxied=false
          # Example: pr-56.dev.nextnode.fr (3 levels) ‚Üí proxied=false
          # Example: dev.nextnode.fr (2 levels) ‚Üí proxied=true (default)
          DOMAIN="${{ inputs.domain }}"
          DOT_COUNT=$(echo "$DOMAIN" | grep -o '\.' | wc -l | xargs)

          # Override proxied setting if sub-subdomain detected
          PROXIED_OVERRIDE="${{ inputs.proxied }}"
          if [[ $DOT_COUNT -ge 2 ]]; then
            # This is a sub-subdomain (e.g., pr-56.dev.nextnode.fr)
            echo "‚ö†Ô∏è  Sub-subdomain detected ($DOMAIN)"
            echo "   Railway requires DNS-only mode (proxied=false) for sub-subdomains"
            echo "   Cloudflare proxy blocks Railway CNAME detection & SSL provisioning"
            PROXIED_OVERRIDE="false"
          else
            echo "‚úÖ First-level subdomain or apex ($DOMAIN)"
            echo "   Using proxied=$PROXIED_OVERRIDE (Cloudflare proxy compatible)"
          fi

          # Check if ANY record exists for this domain (A, AAAA, CNAME)
          # First check for the exact type we want
          EXISTING_EXACT=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=${{ inputs.domain }}&type=${{ inputs.record-type }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")
          
          # Then check for any conflicting record types (A, AAAA, CNAME)
          EXISTING_ANY=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=${{ inputs.domain }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")
          
          echo "DEBUG: API Response for exact type (${{ inputs.record-type }}):"
          echo "$EXISTING_EXACT" | jq '.'
          
          echo "DEBUG: API Response for any record type:"
          echo "$EXISTING_ANY" | jq '.'
          
          # Filter for A, AAAA, CNAME records only
          CONFLICTING_RECORDS=$(echo "$EXISTING_ANY" | jq '[.result[] | select(.type == "A" or .type == "AAAA" or .type == "CNAME")]')
          RECORD_COUNT=$(echo "$CONFLICTING_RECORDS" | jq -r 'length')
          echo "DEBUG: Found $RECORD_COUNT conflicting records (A/AAAA/CNAME)"
          
          # Use exact match if available, otherwise use first conflicting record
          if [[ $(echo "$EXISTING_EXACT" | jq -r '.result | length') -gt 0 ]]; then
            echo "DEBUG: Using exact type match"
            RECORD_ID=$(echo "$EXISTING_EXACT" | jq -r '.result[0].id // empty')
            CURRENT_CONTENT=$(echo "$EXISTING_EXACT" | jq -r '.result[0].content // empty')
            CURRENT_PROXIED=$(echo "$EXISTING_EXACT" | jq -r '.result[0].proxied // empty')
            CURRENT_TYPE=$(echo "$EXISTING_EXACT" | jq -r '.result[0].type // empty')
          elif [[ $RECORD_COUNT -gt 0 ]]; then
            echo "DEBUG: Using first conflicting record for replacement"
            RECORD_ID=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].id // empty')
            CURRENT_CONTENT=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].content // empty')
            CURRENT_PROXIED=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].proxied // empty')
            CURRENT_TYPE=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].type // empty')
          else
            RECORD_ID=""
            CURRENT_CONTENT=""
            CURRENT_PROXIED=""
            CURRENT_TYPE=""
          fi
          
          echo "DEBUG: Extracted values:"
          echo "  ‚Ä¢ RECORD_ID: '$RECORD_ID'"
          echo "  ‚Ä¢ CURRENT_TYPE: '$CURRENT_TYPE'"
          echo "  ‚Ä¢ CURRENT_CONTENT: '$CURRENT_CONTENT'"
          echo "  ‚Ä¢ CURRENT_PROXIED: '$CURRENT_PROXIED'"
          
          # Clean target URL for CNAME records (remove ALL protocol prefixes)
          TARGET_VALUE="${{ inputs.target }}"
          if [[ "${{ inputs.record-type }}" == "CNAME" ]]; then
            # Remove ALL occurrences of http:// or https:// (not just first one)
            TARGET_VALUE=$(echo "$TARGET_VALUE" | sed -E 's|https?://||g' | sed 's|/$||g')
            echo "Original target: ${{ inputs.target }}"
            echo "Cleaned CNAME target: $TARGET_VALUE"
          fi
          
          # Check if record already has the correct values
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" && "$RECORD_ID" != "" ]]; then
            echo "Existing record found:"
            echo "  ‚Ä¢ Record ID: $RECORD_ID"
            echo "  ‚Ä¢ Current type: $CURRENT_TYPE"
            echo "  ‚Ä¢ Current content: $CURRENT_CONTENT"
            echo "  ‚Ä¢ New type: ${{ inputs.record-type }}"
            echo "  ‚Ä¢ New content: $TARGET_VALUE"
            echo "  ‚Ä¢ Current proxied: $CURRENT_PROXIED"
            echo "  ‚Ä¢ New proxied: $PROXIED_OVERRIDE"

            # Convert boolean values for comparison
            EXPECTED_PROXIED="$PROXIED_OVERRIDE"
            EXPECTED_TYPE="${{ inputs.record-type }}"
            
            if [[ "$CURRENT_TYPE" == "$EXPECTED_TYPE" && "$CURRENT_CONTENT" == "$TARGET_VALUE" && "$CURRENT_PROXIED" == "$EXPECTED_PROXIED" ]]; then
              echo "‚úÖ DNS record already up to date - no changes needed"
              echo "success=true" >> $GITHUB_OUTPUT
              {
              echo 'record-id<<EOF'
              echo "$RECORD_ID"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
              exit 0
            else
              echo "üìù DNS record needs to be updated/replaced"
              echo "  Differences:"
              [[ "$CURRENT_TYPE" != "$EXPECTED_TYPE" ]] && echo "    - Type: '$CURRENT_TYPE' ‚Üí '$EXPECTED_TYPE'"
              [[ "$CURRENT_CONTENT" != "$TARGET_VALUE" ]] && echo "    - Content: '$CURRENT_CONTENT' ‚Üí '$TARGET_VALUE'"
              [[ "$CURRENT_PROXIED" != "$EXPECTED_PROXIED" ]] && echo "    - Proxied: '$CURRENT_PROXIED' ‚Üí '$EXPECTED_PROXIED'"
            fi
          else
            echo "No existing record found - will create new record"
          fi

          # Detect and create wildcard for sub-subdomains (e.g., pr-56.dev.nextnode.fr)
          DOMAIN="${{ inputs.domain }}"
          # Extract TLD (last 2 parts: domain.tld)
          ROOT_DOMAIN=$(echo "$DOMAIN" | awk -F. 'NF>=2{print $(NF-1)"."$NF; next} {print $0}')
          # Remove TLD to get subdomain parts
          SUBDOMAIN_PARTS=$(echo "$DOMAIN" | sed "s/\.$ROOT_DOMAIN$//")
          # Count dots in subdomain parts (0 = direct subdomain, 1+ = sub-subdomain)
          DOT_COUNT=$(echo "$SUBDOMAIN_PARTS" | grep -o '\.' | wc -l | xargs)

          echo "DEBUG: Wildcard detection:"
          echo "  ‚Ä¢ Full domain: $DOMAIN"
          echo "  ‚Ä¢ Root domain: $ROOT_DOMAIN"
          echo "  ‚Ä¢ Subdomain parts: $SUBDOMAIN_PARTS"
          echo "  ‚Ä¢ Dot count in subdomain: $DOT_COUNT"

          if [[ $DOT_COUNT -ge 1 ]]; then
            # This is a sub-subdomain (e.g., pr-56.dev.nextnode.fr ‚Üí *.dev.nextnode.fr)
            PARENT_SUBDOMAIN=$(echo "$SUBDOMAIN_PARTS" | cut -d'.' -f2-)
            WILDCARD_DOMAIN="*.${PARENT_SUBDOMAIN}.${ROOT_DOMAIN}"

            echo "üîç Detected sub-subdomain pattern"
            echo "  ‚Ä¢ Creating wildcard: $WILDCARD_DOMAIN"

            # Check if wildcard already exists
            WILDCARD_CHECK=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=$WILDCARD_DOMAIN" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json")

            WILDCARD_EXISTS=$(echo "$WILDCARD_CHECK" | jq -r '.result | length')

            if [[ $WILDCARD_EXISTS -eq 0 ]]; then
              echo "‚ú® Creating wildcard DNS record: $WILDCARD_DOMAIN"

              WILDCARD_DATA=$(jq -n \
                --arg type "${{ inputs.record-type }}" \
                --arg name "$WILDCARD_DOMAIN" \
                --arg content "$TARGET_VALUE" \
                --argjson proxied "$PROXIED_OVERRIDE" \
                --argjson ttl "${{ inputs.ttl }}" \
                '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')

              WILDCARD_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CF_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "$WILDCARD_DATA")

              WILDCARD_SUCCESS=$(echo "$WILDCARD_RESPONSE" | jq -r '.success')

              if [[ "$WILDCARD_SUCCESS" == "true" ]]; then
                echo "‚úÖ Wildcard record created successfully"
              else
                echo "‚ö†Ô∏è Wildcard creation failed (non-blocking):"
                echo "$WILDCARD_RESPONSE" | jq '.errors'
              fi
            else
              echo "‚úÖ Wildcard record already exists: $WILDCARD_DOMAIN"
            fi
          else
            echo "‚ÑπÔ∏è  Direct subdomain - no wildcard needed"
          fi

          # Prepare record data
          RECORD_DATA=$(jq -n \
            --arg type "${{ inputs.record-type }}" \
            --arg name "${{ inputs.domain }}" \
            --arg content "$TARGET_VALUE" \
            --argjson proxied "$PROXIED_OVERRIDE" \
            --argjson ttl "${{ inputs.ttl }}" \
            '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')
          
          # Create or update record
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" ]]; then
            RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$RECORD_DATA")
          else
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$RECORD_DATA")
            RECORD_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          fi
          
          # Check success
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          {
              echo 'record-id<<EOF'
              echo "$RECORD_ID"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          
          if [[ "$SUCCESS" != "true" ]]; then
            echo "$RESPONSE" | jq '.errors'
            exit 1
          fi

          # Create _acme-challenge record for Railway SSL validation (DNS-only)
          # Required for Railway to issue Let's Encrypt certificates for custom domains
          # Must be DNS-only (proxied=false) to allow Railway ACME validation
          if [[ "${{ inputs.record-type }}" == "CNAME" && "$PROXIED_OVERRIDE" == "false" ]]; then
            ACME_DOMAIN="_acme-challenge.${{ inputs.domain }}"
            echo ""
            echo "üîê Creating ACME challenge record for Railway SSL validation"
            echo "  ‚Ä¢ Record: $ACME_DOMAIN"
            echo "  ‚Ä¢ Target: $TARGET_VALUE"
            echo "  ‚Ä¢ Proxied: false (required for ACME validation)"

            # Check if ACME record already exists
            ACME_CHECK=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=$ACME_DOMAIN&type=CNAME" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json")

            ACME_EXISTS=$(echo "$ACME_CHECK" | jq -r '.result | length')

            if [[ $ACME_EXISTS -eq 0 ]]; then
              ACME_DATA=$(jq -n \
                --arg type "CNAME" \
                --arg name "$ACME_DOMAIN" \
                --arg content "$TARGET_VALUE" \
                --argjson proxied false \
                --argjson ttl 1 \
                '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')

              ACME_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CF_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "$ACME_DATA")

              ACME_SUCCESS=$(echo "$ACME_RESPONSE" | jq -r '.success')

              if [[ "$ACME_SUCCESS" == "true" ]]; then
                echo "‚úÖ ACME challenge record created successfully"
              else
                echo "‚ö†Ô∏è  ACME challenge creation failed (non-blocking):"
                echo "$ACME_RESPONSE" | jq '.errors'
              fi
            else
              echo "‚úÖ ACME challenge record already exists"
            fi
          fi

          # Add www subdomain (CNAME to same Railway target)
          if [[ "${{ inputs.domain }}" != www.* ]]; then
            echo "Adding www.${{ inputs.domain }} CNAME to same target..."
            
            WWW_DATA=$(jq -n \
              --arg type "CNAME" \
              --arg name "www.${{ inputs.domain }}" \
              --arg content "$TARGET_VALUE" \
              --argjson proxied true \
              --argjson ttl 1 \
              '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')
            
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$WWW_DATA" || echo "www subdomain might already exist"
          fi

  seo-setup:
    name: Configure SEO
    runs-on: ubuntu-latest
    needs: update
    if: ${{ inputs.enable-seo-setup == true && needs.update.outputs.success == 'true' }}
    outputs:
      seo-configured: ${{ steps.seo.outputs.seo-configured }}
      transform-rules-created: ${{ steps.seo.outputs.transform-rules-created }}
    
    steps:
      - name: Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: NextNodeSolutions/github-actions
          token: ${{ github.token }}
          path: .github-actions
          
      - name: üéØ Configure Cloudflare SEO
        id: seo
        uses: ./.github-actions/actions/seo/cloudflare-seo-setup
        with:
          domain: ${{ inputs.domain }}
          blocked-subdomains: ${{ inputs.blocked-subdomains }}
          allowed-subdomains: ${{ inputs.allowed-subdomains }}
          cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          cloudflare-zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          enable-www-redirect: true
          enable-optimizations: ${{ inputs.enable-optimizations }}
          dry-run: false
          
      - name: üìä Configuration Summary
        run: |
          echo "## üìä Configuration Summary"
          echo ""
          echo "| Component | Status | Details |"
          echo "|-----------|--------|---------|"
          echo "| üåê DNS Records | ${{ needs.update.outputs.success == 'true' && '‚úÖ Updated' || '‚ùå Failed' }} | ${{ inputs.domain }} |"
          echo "| üéØ SEO Config | ${{ steps.seo.outputs.seo-configured == 'true' && '‚úÖ Configured' || '‚ö†Ô∏è Skipped' }} | Transform Rules + Redirects |"
          echo "| ü§ñ Transform Rules | ${{ steps.seo.outputs.transform-rules-created > '0' && '‚úÖ Active' || '‚ûñ None' }} | ${{ steps.seo.outputs.transform-rules-created }} created |"
          echo "| üîÄ Redirects | ${{ steps.seo.outputs.redirects-count > '0' && '‚úÖ Active' || '‚ûñ None' }} | ${{ steps.seo.outputs.redirects-count || '0' }} created |"
          echo "| ‚ö° Optimizations | ${{ inputs.enable-optimizations == true && '‚úÖ Enabled' || '‚ûñ Disabled' }} | Minify, Brotli, HTTPS |"
          echo "| üè• Health Check | ${{ inputs.enable-health-check == true && '‚úÖ Enabled' || '‚ûñ Disabled' }} | ${{ inputs.health-check-mandatory == true && 'Mandatory' || 'Optional' }} |"
          echo ""
          echo "**Blocked subdomains:** ${{ inputs.blocked-subdomains }}"
          if [[ -n "${{ inputs.allowed-subdomains }}" ]]; then
            echo "**Allowed subdomains (whitelist):** ${{ inputs.allowed-subdomains }}"
          fi

      - name: ‚úÖ SEO Configuration Complete
        if: steps.seo.outputs.seo-configured == 'true'
        run: |
          echo "::notice title=SEO Configuration Complete::All SEO configuration completed automatically via Transform Rules and Single Redirects. No manual steps required."

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [seo-setup]
    if: ${{ inputs.enable-health-check == true }}
    steps:
      - name: Wait for DNS Propagation
        shell: bash
        run: |
          echo "::group::‚è±Ô∏è Waiting for DNS Propagation"
          echo "Waiting ${{ inputs.dns-propagation-wait }} seconds for DNS records to propagate..."
          sleep ${{ inputs.dns-propagation-wait }}
          echo "::endgroup::"

      - name: Check Deployment Health
        uses: NextNodeSolutions/github-actions/actions/health-check@main
        with:
          url: https://${{ inputs.domain }}
          max-attempts: ${{ inputs.health-check-max-attempts }}
          delay-seconds: ${{ inputs.health-check-delay }}
          expected-status: '200'
        continue-on-error: ${{ inputs.health-check-mandatory == false }}

name: DNS Cloudflare

# EXTERNAL WORKFLOW - Atomic Cloudflare DNS update workflow
# Configures DNS records via Cloudflare API

on:
  workflow_call:
    inputs:
      domain:
        description: 'Domain to configure'
        required: true
        type: string
      target:
        description: 'Target URL or IP address'
        required: true
        type: string
      record-type:
        description: 'DNS record type (A, AAAA, CNAME)'
        required: false
        default: 'CNAME'
        type: string
      proxied:
        description: 'Enable Cloudflare proxy'
        required: false
        default: true
        type: boolean
      ttl:
        description: 'DNS TTL in seconds (1 = automatic)'
        required: false
        default: '1'
        type: string
    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: false
    outputs:
      dns-updated:
        description: 'Whether DNS was successfully updated'
        value: ${{ jobs.update.outputs.success }}
      record-id:
        description: 'Cloudflare DNS record ID'
        value: ${{ jobs.update.outputs.record-id }}

jobs:
  update:
    name: Update DNS
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.cloudflare.outputs.success == 'true' && steps.cloudflare-www.outputs.success == 'true' }}
      record-id: ${{ steps.cloudflare.outputs.record-id }}
      www-record-id: ${{ steps.cloudflare-www.outputs.record-id }}
    steps:
      - name: Update Cloudflare DNS
        id: cloudflare
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          # Get zone ID if not provided
          if [[ -z "$CF_ZONE_ID" ]]; then
            # Extract root domain from full domain
            ROOT_DOMAIN=$(echo "${{ inputs.domain }}" | awk -F. '{print $(NF-1)"."$NF}')
            
            ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ROOT_DOMAIN" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json")
            
            CF_ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')
            
            if [[ -z "$CF_ZONE_ID" || "$CF_ZONE_ID" == "null" ]]; then
              echo "success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # Check if ANY record exists for this domain (A, AAAA, CNAME)
          # First check for the exact type we want
          EXISTING_EXACT=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=${{ inputs.domain }}&type=${{ inputs.record-type }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")
          
          # Then check for any conflicting record types (A, AAAA, CNAME)
          EXISTING_ANY=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=${{ inputs.domain }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")
          
          echo "DEBUG: API Response for exact type (${{ inputs.record-type }}):"
          echo "$EXISTING_EXACT" | jq '.'
          
          echo "DEBUG: API Response for any record type:"
          echo "$EXISTING_ANY" | jq '.'
          
          # Filter for A, AAAA, CNAME records only
          CONFLICTING_RECORDS=$(echo "$EXISTING_ANY" | jq '[.result[] | select(.type == "A" or .type == "AAAA" or .type == "CNAME")]')
          RECORD_COUNT=$(echo "$CONFLICTING_RECORDS" | jq -r 'length')
          echo "DEBUG: Found $RECORD_COUNT conflicting records (A/AAAA/CNAME)"
          
          # Use exact match if available, otherwise use first conflicting record
          if [[ $(echo "$EXISTING_EXACT" | jq -r '.result | length') -gt 0 ]]; then
            echo "DEBUG: Using exact type match"
            RECORD_ID=$(echo "$EXISTING_EXACT" | jq -r '.result[0].id // empty')
            CURRENT_CONTENT=$(echo "$EXISTING_EXACT" | jq -r '.result[0].content // empty')
            CURRENT_PROXIED=$(echo "$EXISTING_EXACT" | jq -r '.result[0].proxied // empty')
            CURRENT_TYPE=$(echo "$EXISTING_EXACT" | jq -r '.result[0].type // empty')
          elif [[ $RECORD_COUNT -gt 0 ]]; then
            echo "DEBUG: Using first conflicting record for replacement"
            RECORD_ID=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].id // empty')
            CURRENT_CONTENT=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].content // empty')
            CURRENT_PROXIED=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].proxied // empty')
            CURRENT_TYPE=$(echo "$CONFLICTING_RECORDS" | jq -r '.[0].type // empty')
          else
            RECORD_ID=""
            CURRENT_CONTENT=""
            CURRENT_PROXIED=""
            CURRENT_TYPE=""
          fi
          
          echo "DEBUG: Extracted values:"
          echo "  â€¢ RECORD_ID: '$RECORD_ID'"
          echo "  â€¢ CURRENT_TYPE: '$CURRENT_TYPE'"
          echo "  â€¢ CURRENT_CONTENT: '$CURRENT_CONTENT'"
          echo "  â€¢ CURRENT_PROXIED: '$CURRENT_PROXIED'"
          
          # Clean target URL for CNAME records (remove https:// if present)
          TARGET_VALUE="${{ inputs.target }}"
          if [[ "${{ inputs.record-type }}" == "CNAME" ]]; then
            # Remove protocol and trailing slash if present
            TARGET_VALUE=$(echo "$TARGET_VALUE" | sed 's|^https\?://||g' | sed 's|/$||g')
            echo "Original target: ${{ inputs.target }}"
            echo "Cleaned CNAME target: $TARGET_VALUE"
          fi
          
          # Check if record already has the correct values
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" && "$RECORD_ID" != "" ]]; then
            echo "Existing record found:"
            echo "  â€¢ Record ID: $RECORD_ID"
            echo "  â€¢ Current type: $CURRENT_TYPE"
            echo "  â€¢ Current content: $CURRENT_CONTENT"
            echo "  â€¢ New type: ${{ inputs.record-type }}"
            echo "  â€¢ New content: $TARGET_VALUE"
            echo "  â€¢ Current proxied: $CURRENT_PROXIED"
            echo "  â€¢ New proxied: ${{ inputs.proxied }}"
            
            # Convert boolean values for comparison
            EXPECTED_PROXIED="${{ inputs.proxied }}"
            EXPECTED_TYPE="${{ inputs.record-type }}"
            
            if [[ "$CURRENT_TYPE" == "$EXPECTED_TYPE" && "$CURRENT_CONTENT" == "$TARGET_VALUE" && "$CURRENT_PROXIED" == "$EXPECTED_PROXIED" ]]; then
              echo "âœ… DNS record already up to date - no changes needed"
              echo "success=true" >> $GITHUB_OUTPUT
              {
              echo 'record-id<<EOF'
              echo "$RECORD_ID"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
              exit 0
            else
              echo "ðŸ“ DNS record needs to be updated/replaced"
              echo "  Differences:"
              [[ "$CURRENT_TYPE" != "$EXPECTED_TYPE" ]] && echo "    - Type: '$CURRENT_TYPE' â†’ '$EXPECTED_TYPE'"
              [[ "$CURRENT_CONTENT" != "$TARGET_VALUE" ]] && echo "    - Content: '$CURRENT_CONTENT' â†’ '$TARGET_VALUE'"
              [[ "$CURRENT_PROXIED" != "$EXPECTED_PROXIED" ]] && echo "    - Proxied: '$CURRENT_PROXIED' â†’ '$EXPECTED_PROXIED'"
            fi
          else
            echo "No existing record found - will create new record"
          fi
          
          # Prepare record data
          RECORD_DATA=$(jq -n \
            --arg type "${{ inputs.record-type }}" \
            --arg name "${{ inputs.domain }}" \
            --arg content "$TARGET_VALUE" \
            --argjson proxied "${{ inputs.proxied }}" \
            --argjson ttl "${{ inputs.ttl }}" \
            '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')
          
          # Create or update record
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" ]]; then
            RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$RECORD_DATA")
          else
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$RECORD_DATA")
            RECORD_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          fi
          
          # Check success
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          {
              echo 'record-id<<EOF'
              echo "$RECORD_ID"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          
          if [[ "$SUCCESS" != "true" ]]; then
            echo "$RESPONSE" | jq '.errors'
            exit 1
          fi
          
          # Add www subdomain (CNAME to main domain)
          if [[ "${{ inputs.domain }}" != www.* ]]; then
            echo "Adding www.${{ inputs.domain }} CNAME..."
            
            WWW_DATA=$(jq -n \
              --arg type "CNAME" \
              --arg name "www.${{ inputs.domain }}" \
              --arg content "${{ inputs.domain }}" \
              --argjson proxied true \
              --argjson ttl 1 \
              '{type: $type, name: $name, content: $content, proxied: $proxied, ttl: $ttl}')
            
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "$WWW_DATA" || echo "www subdomain might already exist"
          fi